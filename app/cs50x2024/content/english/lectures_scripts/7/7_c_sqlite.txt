All right, so then the segue is exactly this. I'm going to go ahead now and close favorites.py. And I'm just going to maximize the size of my terminal window here. And I'm going to go ahead and run a program called SQLite3. SQLite3 is a command line program that you can install on your Mac or PC-- it's already on CS50 IDE-- that allows you to use another language called SQL interactively. And it's got this really cool feature whereby if I have this file called, very verbosely, CS520 2019 Lecture 7, and so forth, I'm going to copy that after highlighting it. I'm going to run SQLite3, and I'm going to put SQLite3 into .mode CSV. It's a weird syntax, .mode CSV, but you don't have to use these commands very often. Then I'm going to use one other command here, which is called import. And I'm going to go ahead and import this into a database. 

But what database, exactly? Well, let me go ahead and more specifically-- let me exit out of this here. Whoops. Let me exit out of this here and run SQLite3 in the name of a database. I'm dealing with favorite shows, so maybe I'll call this favorites.db, DB denoting database. I'm going to now go ahead and do .mode CSV. I'm going to now do .import, quoting the name of the file, and quotes are important, because it's got some ugly spaces in it, and I'm going to import this into a table, kind of like a spreadsheet, that I'm just going to call in all lowercase favorites. And hit Enter. Nothing seems to happen now. 

But if I go back to my terminal window and type ls, notice that in addition to my CSV file and favorites.py and src7, which I downloaded in advance with today's code, I now have this file called favorites.db. And if I rerun SQLite, it turns out when I pass in the name of that database, now I can ask the same kinds of questions as before, but I can do it with a different syntax. I can go ahead and select all the titles from my favorites by typing this command, SELECT title FROM favorites; Enter, and voila, we get all of the titles there. 

Suppose I want to sort those titles as before, or I can SELECT title FROM favorites, ORDER BY title; ending with-- oh, sorry. Semicolons are back. Then I'm going to go ahead and hit here. And you'll see that now it's alphabetized, and there's all those Offices by first letter. Now, there are some bugs. If you scroll down, you'll see lowercase letters as well, so we'd have to deal with that situation, too. But this seems to be a user-friendly way of just selecting data that I care about. 

And watch this. Let me try to group things together. I'm going to go ahead and select title, and I'm going to go ahead and say count the number of titles from this table called favorites. But I want to group those things by title. Now, we'll see in a moment what this means, but the effect is what's cool. Voila, I now have output much like my Python program. It's not really as orderly as I would like, but notice what it's done at the very top. The very first line of output, if I keep scrolling is this here. On the left is my title, then a vertical bar. On the right is literally count of title, how many titles match that. 

So let me go ahead and do this. Let me go ahead and first of all limit this to the top 10 titles, so I can just deal with this and see all this at once. So here we have some alphabetized list of titles. But now, suppose I want to go ahead and rename this thing. Let me go ahead and say that. Let me go ahead and say, as-- COUNT AS n. Now notice that the title of this output is title, and then n. But the reason I did that was so that I can do this. I'm going to now do ORDER BY n, descending order, and then limit to the top 10. Enter, and voila. Now, using a completely different language, I think I've gotten the same results, except for the lower casing issue, which we can come back to another time. But The Office is here as the number one hit. Friends then, 19. Game of Thrones, 18, and so forth. 

So what's then the motivation in part for this new language called SQL? And you've seen just snippets of it here. It allows us to solve the same kind of problems much more easily, because I don't have to sit down and write a whole darn Python program, faster though it is then C. I don't have to write custom code just to answer questions about my data. And in fact, if you pursue the web track in a couple of weeks' time or the mobile track, both of those are going to offer support for SQL so that if you want to store data on users or interactive information on an app or a website application, SQL is going to be ultimately where you can put that data and access it later, thereby writing even less code than today.