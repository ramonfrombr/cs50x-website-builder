Mais que s'est-il passé ? Il existe une sorte d'illusion, à la fois dans le nom de mon programme et dans l'erreur rouge. Eh bien, à un moment donné, il n'y a qu'une quantité limitée de bits ; après cela, si vous continuez d'incrémenter, d'incrémenter, d'incrémenter, vous n'aurez pas suffisamment de bits pour effectuer le report de retenue, pour ainsi dire, et mémoriser la valeur encore plus grande. Après tout, si nous revenons à certaines de nos discussions de la semaine dernière pour parler de ce qu'on appelle aujourd'hui l'imprécision des nombres flottants ; les nombres entiers ne peuvent être que d'une certaine taille. Le scénario est le suivant : 123 en décimal, dans notre monde humain ; bien sûr, vous pouvez simplement continuer à ajouter un jusqu'à atteindre neuf, moment auquel le chiffre passe à zéro. Vous reportez ensuite la retenue et vous obtenez 130. Cela fonctionne très bien. Mais bien sûr, même en décimal, si vous atteignez 999 en utilisant seulement trois chiffres et que vous essayez d'ajouter un, vous reportez la retenue, vous reportez la retenue, vous perdez la retenue. Désolé. Que se passe-t-il ensuite ? Cela devient 1 000. Mais si vous n'avez que trois chiffres, vous perdez le un initial et il vous reste seulement zéro. La même chose se produit en binaire. Passons maintenant au changement de contexte ; en binaire, de quel nombre s'agit-il ? Voici les positions des quatre, des deux et des un. Il s'agit donc du chiffre sept. 4 + 2 + 1 = 7. Donc bien sûr, si vous ajoutez 1 à 7, vous aimeriez obtenir 8, ce qui vous donnerait 1 000. Mais si vous n'avez que trois bits, trois chiffres, vous allez déborder, pour ainsi dire. Vous allez perdre la retenue, de sorte que la valeur que vous stockez réellement est simplement zéro. C'est pourquoi : si je compte suffisamment haut avec un entier dans un programme, une fois que j'atteins les milliards, cette retenue sera finalement trop importante. Il ne peut faire que 32 bits. Nous ne pouvons pas stocker un nombre encore plus grand. C'est ce qu'on appelle le dépassement de capacité. Et si vous avez déjà entendu parler du problème de l'an 2000, c'était un horrible et très simple problème que les humains se sont créé à l'époque, lorsque les ordinateurs ont été inventés au milieu des années 1900, en réalité. Les humains ont décidé d'économiser de l'espace, ce qui est très raisonnable, car l'espace était cher au début. Alors, au lieu de stocker l'année comme 1999 ou 1970 pour 1970, qu'ont-ils fait ? Oui, ils n'ont stocké que deux chiffres, n'est-ce pas ? Genre, oh mon Dieu ! Nous n'allons pas utiliser ces ordinateurs dans 50 ans. Stockons simplement deux chiffres. Malheureusement, ce n'était pas le cas. Il y avait beaucoup de codes et beaucoup d'ordinateurs qui fonctionnaient encore en 1999. Mais si vous stockez seulement deux chiffres et que vous incrémentez d'une unité la valeur de l'année, ce qui devrait être 2000 a été mal interprété dans de nombreux systèmes comme 1900, auquel cas le système se plantait. Par conséquent, le monde a dépensé des millions de dollars, probablement, en demandant aux programmeurs de commencer à utiliser davantage de mémoire pour résoudre ce problème en prévision de ce qu'on appelait « l'an 2000 » et prendre de l'avance sur ce problème. Au bout du compte, le monde n'a pas pris fin en 1999, ce qui était formidable. Mais ça a été un problème très réel et très coûteux en raison de ce manque de prévoyance. Il s'avère qu'il existe également d'autres exemples de ce phénomène. Celui-ci, par exemple, se terminera presque sur le Boeing 787. Donc, Boeing n'a pas eu une très bonne presse récemment. Et même il y a quelques années, ils ont eu ce qui semblait être un bug logiciel très simple. Voici une photo d'un avion de modèle 787. Et l'article du New York Times expliquait ce qui suit : « Un avion de modèle 787 qui a été alimenté en continu pendant 248 jours peut perdre tout courant alternatif et électrique, en raison des unités de contrôle du générateur passant simultanément en mode de sécurité intégrée. Cette condition est causée par un compteur logiciel interne aux compteurs qui débordera après 248 jours d'alimentation continue. Boeing, selon la déclaration, est en train de développer une mise à jour logicielle qui remédiera à l'état de sécurité. » Qu'est-ce que cela signifie ? Eh bien, si vous examinez les chiffres, 248 jours correspondent à peu près à la valeur de 2 puissance 32, plus ou moins, en 1/100 de seconde. Cela signifie que Boeing, dans une partie cruciale du matériel de leurs avions 787 réels, utilisait des entiers comptant si haut qu'après le 248ᵉ jour de mise sous tension de l'avion, il y aurait un débordement, ce qui aurait pour conséquence que l'alimentation de l'avion pourrait être entièrement coupée. La solution, si vous lisez tout le jargon technique, c'est qu'ils ont littéralement dû redémarrer leurs avions tous les 248 jours afin de réinitialiser cette variable à zéro. Cela arrive encore aujourd'hui dans le monde réel avec des problèmes de ce type. Vous commencerez donc à remarquer ces tendances chaque fois que les gens parleront d'erreurs matérielles ou logicielles. Honnêtement, vous pouvez généralement les réduire à des problèmes que vous avez vous-mêmes rencontrés. Et laissez-moi vous donner un aperçu de quelques fonctionnalités à venir. Il s'avère que maintenant que nous avons la possibilité d'écrire du code, nos programmes peuvent bien sûr faire un certain nombre de choses, comme dire ou imprimer des choses à l'écran. Nous pourrions bien sûr faire quelque chose comme ça dans un programme que nous pourrions appeler figlet, qui est en fait fourni avec certains systèmes. Et je peux dire quelque chose comme : c'est CS50, et en fait l'imprimer dans ce qu'on appelle ASCII art en utilisant des caractères à l'écran qui ressemblent à des lettres et créent des œuvres d'art sur l'écran assez belles, même si elles sont à l'ancienne. Bien sûr, si vous écrivez du code et que vous comprenez non seulement comment les nombres et les lettres sont représentés, mais aussi les sons, selon notre discussion de la semaine dernière, vous pouvez faire des choses encore plus puissantes, comme cette note sur laquelle nous allons littéralement terminer aujourd'hui. INTERVENANT 2 : Voici CS50. DAVID MALAN : C'est tout pour CS50. On se retrouvera la semaine prochaine. [APPLAUDISSEMENTS]