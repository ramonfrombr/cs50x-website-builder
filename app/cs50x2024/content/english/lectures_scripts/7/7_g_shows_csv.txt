So, OK, it actually finished. So let me go ahead and open up show0.csv. Notice now, in my text editor, I've got a lot less data. I've thrown away everything I don't care about, but I've been left with tconst, primary title, start year, and genres, and everything herein is now consistent with that filtration. But I haven't filtered everything I said. What did I say I wanted to get rid of earlier? 

Yeah, the shows before 1970. And clearly some of these are coming from 1940s and so forth. So let's go ahead and get rid of those, but see how. This is the CSV file that we just opened, but in Google Spreadsheet form. So I literally just imported it into Google Spreadsheets that so we could see it. Literally the same data as before, and there are those 1940s movies. 

But there's something curious that I wanted to be mindful of. If I scroll down in the start years and keep going and going and going, huh, those seem OK. Those are increasing in order. But let me try this. Let me just poke around my data, sorting in reverse order. It's going to take a while, because even this is a decent number of TV shows. Notice this weirdness. At the top of start year now, once I've reversed sorted them, there's a whole bunch of backslash capital N's. Now, this has nothing to do with C, and nothing to do with Python. It has everything to do with the documentation. 

If you read IMDB's data, as I only did carefully eventually, you'll see this. A backslash n and capital N is used to denote that a particular field is missing or null for that title name. Now, this is important, because if I want to filter out movies that are after 1970, I need to be resilient against that. So let me go ahead and do this. So if the current row's startYear does not equal backslash n, then I'm going to go ahead and check that it's a TV series and that it's not an adult show. So that would help. But furthermore, how can I check this here? Let me do year. And how can I convert row startYear to an integer? Well, everything in a spreadsheet, by definition of it having been in a spreadsheet, or a TSV file or a CSV file, is text. 

But start year looks like years, so what Python function can I use to actually convert text that resembles a number to an actual number? Yeah. So we can do something like this. So I can convert year to an int, and now I can say, if year greater than or equal to 1970, now I'm going to go ahead and do those lines instead. 

Now, there's an opportunity, surely, for better design, because once your code starts doing this, you've done something suboptimally, right? This is not going to end well if all of my code starts wrapping. So I could clean up the logic in a little bit, but let's go ahead and run this just one more time. This time, changing this to shows1.CSV so we can see slightly different outputs. Let me go ahead and run Python import.py. Huh, syntax error, Unicode error, codec-- that's a weird one. But this is because backslashes, recall, in C and Python, have special meaning. So when you do something like this, backslash capital n, even though it's not a lower case n, backslash n, recall, is the scape character in C and Python. So this is like telling Python, this is a special character. But it's not. And we've never really had occasion to do this, but how would do you think we could output a literal backslash before a capital N? 

Yeah. So it turns out the solution to this problem, usually, no matter the language, is that if you want a literal character, not an escape character, you literally put another one of it before. So even though this looks a little funky now, this backslash backslash capital N literally will mean backslash N. 

All right. So now, let me go ahead and run this on import.py. This time, I'm hopefully going to actually generate a new file called shows1.csv that has even less data that actually is going to contain my shows, but only a subset of them. And let's go ahead and pull the cake out of the oven this way. This is what I get now this time. So if I actually load the CSV, shows1.csv, into Google Spreadsheet, just because it's pretty easy to look at than the black and white window, now you can see that I apparently am only getting shows 1970 and onward. And indeed, if I sorted them, I would see no backslash N's. I would have thrown away everything that doesn't meet that criteria. 

Well, let me go ahead and do one last thing here. I'm going to go ahead and make one more change. And first, let's improve the design here. This indentation is the result of my asking questions again and again and again and indenting if and only if those things are true. But notice, you can start to flip your logic here, right? Instead of saying if the start year does not equal backslash N, what if I just do this and say continue? I can then unindent this-- because if you've not used it before in Python and in C, if you say continue inside of a loop, it's not going to continue down there, it's going to [WHOOSH] continue to the start of the loop again. So via this logic, we can actually keep wrapping around again and again. And here, too, we could say, if year less than 1970, I can go ahead and say continue, which would then allow me to unindent this as well. So there are solutions, design-wise, to actually avoiding that infinite indentation. 

All right. Let's go ahead and do one last version. Then I'm going to go ahead and pull out of the oven in a-- premade. So the last thing I didn't load before was this. Suppose that I want to load into the CSV file, all of the genres associated with the show. It looks like all of these shows have one or more genres, just like you were asked for your favorite shows. And so now, we have a CSV file with tconst, primary titles, start year, and genres, where genre is itself is a comma-separated list. 

But there's a fundamental problem here. Even though I have all of this data here, the best I can do is a program like this. Let me go ahead and search for, for instance, the following. Let me go ahead and grab a file real fast. Let me go ahead and grab a copy of shows2.csv and write one final program here. If I want to go ahead now and search this very large, still, data set, in shows2.csv, well, let me go ahead and do this. Import CSV. 

Let me go ahead now and ask the user for a title. I could use CS50's get string, but there's really no need for that anymore now that we have the title function-- the input function, recall. So I'll just use that. And then I'm going to go ahead and open up shows2.csv in read-only mode. And I'm going to call that my file. Then I'm going to go ahead and give myself a reader from csv.DictReader, passing in that file. And now I'm going to go ahead and, for row in reader, do the following. The goal now is to write a Python program that allows me to search only those TV shows. So I could say something like this, if title == row "primaryTitle", then I can go ahead, for instance, and print out row "primaryTitle," started in row "startYear." 

So what is the goal of this program? It's going to ask the user for input. It's going to open this big CSV that I've created. But that's still smaller than the 50-megabyte version. It's going to iterate over every row in that file via DictReader, checking if the title the human typed in equals the current row's primary title. And if so, it's going to print the title and year of that show. 

So if I go ahead and run Python of search.py, typing in something like The Crown, Enter, voila, I get that answer. If I go ahead and do The Office, Enter, there's a bunch of Offices. And in fact, if you haven't seen more than the American one, there's the UK one, and apparently several others. And we can actually corroborate this now. If you go to IMDB, where all of this data originally came from, and type The Office, there are all of The Offices that actually line up with our own very data set. It's going to be so damn tedious every time you want to search for data or update data or insert new data to write a Python program to do it, so we need a few more features of SQL. 

But I think first, we need some Halloween candy for our five-minute break outback. 