Pero honestamente, usar una interfaz de línea de comandos en blanco y negro y una ventana de terminal no suele ser divertido, especialmente cuando los datos vuelan por la pantalla. Por eso existen las GUIs, Interfaces Gráficas de Usuario, y de hecho, hay un programa disponible de forma gratuita para Macs, PCs y otros tipos de sistemas operativos, llamado DB Browser. Y de hecho, los guiaré hacia esto en línea. Este es simplemente un programa que te permite explorar archivos SQL en tu propio Mac o PC de manera mucho más visual y agradable que quizás solo permitiría una interfaz de línea de comandos. Así que permítanme abrir, por ejemplo, shows.db.

Veremos un montón de cosas. En primer lugar, la interfaz gráfica de usuario aquí muestra la misma información, pero en un formato ligeramente más agradable. Shows.db, como mencioné en mi diagrama hace un momento, tiene seis tablas: personas, como mencioné; shows, como mencioné; también, estrellas y escritores, clasificaciones, y luego esa tabla separada llamada géneros. Y si miras aquí a la derecha, puedes ver realmente el código SQL que escribimos para crear esas tablas.

Pero más genial que eso es notar estas pestañas aquí arriba. Actualmente estoy en Estructura de la Base de Datos, y si estás usando Windows, tu interfaz se verá un poco diferente, pero las opciones siguen ahí. Voy a hacer clic en Examinar Datos. Y ahora verás un pequeño menú desplegable con todas las tablas. Así que si quiero ver un montón de programas, en realidad puedo ver todos mis datos aquí, algo así como Google Spreadsheets. Pero nota, son 153,331 programas, o shows, que puedo ver todos juntos aquí.

Y por último, lo interesante es que si voy a la pestaña SQL, ahora puedo ejecutar algunas consultas de ejemplo. Déjame hacer esto. SELECT * FROM shows;. Esto me dará muchos shows. Enter. Así que presiono el pequeño botón de Ejecutar que simplemente ejecuta esa consulta, y verás las filas resultantes que han regresado. Entonces, nuevamente, ¿cómo llegamos a este punto? Nosotros, el equipo, descargamos todos esos archivos TSV de antemano. Escribimos un script de Python que importó todos los datos de esos archivos a la memoria, eliminó las cosas que no nos importaban, y luego las insertó en tablas como esta tabla llamada shows.

Y lo bueno de esta herramienta es que, si eres un aspirante a científico de datos o simplemente estás tratando de hacer un trabajo analítico para esta clase o cualquier otro proyecto, una herramienta gráfica se presta para simplemente curiosear. Por ejemplo, verás que la tabla de shows ya no tiene géneros. Pero eso está bien. Podemos reconstituir esos datos. Puedo proceder y SELECT * FROM shows-- pero ¿sabes qué más puedo hacer? Puedo unir realmente en la tabla de géneros. Así que puedo tomar la tabla de shows aquí, la tabla de géneros aquí, y básicamente vincularlas a través del ID.

¿Cómo es posible? Bueno, si miras shows, un show tiene un ID, título, año y episodios. Géneros tienen un show ID. Así que si piensas en el ID en mi mano izquierda como representando mis dedos aquí. El show ID en géneros está representando mi mano derecha aquí. Lo que queremos hacer es alinear el ID con el show ID para formar una tabla más grande y más amplia que constituya todos esos datos juntos.

Entonces, ¿cómo hago esto? Bueno, en SQL, puedes unir dos tablas. Dices qué tabla quieres unir con qué otra tabla y cómo quieres hacerlo. Bueno, quiero proceder y unirlo en shows.id = genres.show_id;. Y ahora, cuando lo ejecuto, tomó un momento, de hecho, tomó 408 milisegundos. Pero, Dios mío, eso es mucho más rápido que escribir un script completo de Python para hacer esto. Ahora tengo una tabla con todos los shows como antes. Pero nota que la tabla se amplió. Esta es una tabla temporal que SQL me ha devuelto. Ahora tiene género e ID de show.

Así que de hecho, permíteme filtrar esto. WHERE título = "The Office" AND año = 2005, Play, solo obtendremos esto. Así que nota que tengo una tabla más amplia que contiene todas las columnas de esas dos tablas unidas. Pero si cambio esto ahora a The Crown, y eso fue en 2016, y presiono play, nota que obtengo información aparentemente redundante. Pero esto podría ser útil de todos modos, porque ahora puedo iterar sobre todas las filas sabiendo que cada fila tiene no solo un título y un año, sino también un género.

Bueno, ¿cómo puedo hacer otras preguntas también, como cuáles son los actores que están en otros shows también? Bien, déjame hacer algo así. Por ejemplo, seleccionemos todas las películas de Steve Carell. O -- seleccionemos a Steve Carell primero. Entonces, SELECT * FROM-- veamos-- no. Hagamos esto. ¿Qué tal Ellen? Así que SELECT * from people where name = Ellen DeGeneres. Lo he deletreado bien. Semicolon, Play.

Bien. Esto es útil, porque ahora sé que el año de nacimiento de Ellen es 1958, pero su ID es 1122. Eso es lo mismo que ese nconst, pero desechamos la nm y nos deshicimos de todos los ceros y lo convertimos en un número apropiado para identificar eficientemente a humanos, típicamente, o cualquier cosa, mediante números que caben en 32 o 64 bits en lugar de cadenas más largas. Así que ahora sé que el ID de Ellen es 1122, ¿qué puedo hacer?

Bueno, permíteme proceder y SELECT * FROM stars WHERE person_id = esto. Esto me dirá qué? Esto me dirá toda la información sobre los shows en los que Ellen actuó, incluyendo, presumiblemente, el suyo propio. OK, así que ahora veo que person_id es el mismo, lo mismo, lo mismo, pero aparentemente Ellen está en todos esos shows. Pero eso no es muy útil, y además, es un poco aburrido que haya codificado el ID de Ellen.

Pero no tengo que hacer eso. Puedo hacer una subconsulta, SELECT id FROM people WHERE name = "Ellen DeGeneres", paréntesis cerrado, Play. Ahora es dinámico, así que no he codificado nada. Pero esto no es muy útil. Permíteme proceder y seleccionar show_id aquí. Así que ahora tengo SELECT show_id FROM stars WHERE el ID de persona es igual al de Ellen aquí.

¿Cómo puedo llevar esto un paso más allá? Bueno, ¿qué pasa si hago SELECT * FROM shows WHERE el ID del show está en la siguiente lista de valores? Así que SQL no solo soporta igualdad cuando quieres comparar un valor con el siguiente, algo así como en Python, tienes la palabra clave IN, donde puedes decir selecciona todo de shows donde el ID del show está en la siguiente lista de IDs de show, que representa la lista de IDs de show en los que Ellen está. Uf.

Vamos a presionar Play en esto. Tomó un momento, pero parece que estos son todos los shows en los que Ellen ha estado, según IMDB. Y parece que The Ellen DeGeneres Show es uno de ellos. Ha estado al aire durante 2,865 episodios. Está Ellen, su programa original de televisión, que estuvo en el aire durante varias temporadas en ese entonces. Parece que está haciendo algunos programas de juegos en estos días a partir de 2017, y así sucesivamente. Así que usando estos procesos de pensamiento paso a paso, podemos realmente construir consultas más interesantes para obtener información como esa.

¿Bien, alguna pregunta antes de que probemos algunas otras consultas también? ¿No? Bien. Permítanme mostrar otro enfoque para este mismo problema. Resulta que estos son lo que se conocen como consultas anidadas. Sigues usando la paréntesisización, al igual que en matemáticas, donde puedes anidar expresiones aritméticas en paréntesis. Puedes hacer lo mismo en SQL. Pero también puedes unir información de formas ligeramente diferentes también. De hecho, puedo hacer algo así.

Permíteme proceder y SELECT Title FROM las siguientes tablas, people JOIN stars ON people.id = stars.person_id-- y caminaremos a través de esto en un momento-- JOIN-- lo siento-- JOIN shows ON stars.show_id = shows.id where name igual a "Ellen DeGeneres". Esto, aunque más largo, es equivalente a lo que acabo de hacer. Nota que he seleccionado el título del show de lo siguiente, el resultado de unir people en stars. ¿Cómo unes la tabla de people y la tabla de stars? Bueno, las personas tienen IDs. Stars tienen person IDs, según el diagrama. ¿Qué más quieres unir juntos? Unámoslo todo con shows. ¿Cómo? Bueno, vamos a proceder y decir stars.show_id = shows.id. Así que es una forma de vincular, de forma transitiva, múltiples tablas juntas, y luego filtrar todo eso con el nombre de Ellen DeGeneres. Esto es lo que llamaríamos una unión explícita.

Y si hago clic en Play ahí, nota que está tomando un momento. Tomó, de hecho, 1,990 milisegundos, casi dos segundos humanos. Así que se volvió más lento, pero me da otra sintaxis para seleccionar datos. Y honestamente, lo interesante de esto es que puedo seleccionar otros campos también. No tienen que venir de la consulta original en mis selects anidados.

Pero permíteme proceder y hacer esto, solo como una muestra, y luego consideraremos algunos problemas antes de terminar. Resulta que 2 segundos son un poco lentos, y si lo hago de nuevo, tomó 2,029 milisegundos. Si lo hago de nuevo, tomó 1,963 milisegundos, y estoy mirando el tiempo aquí. Eso es lento, ¿verdad? Eso significa que si tienes un número finito de servidores en el mundo y cada uno de ellos solo puede manejar cierto número de usuarios a la vez, es una especie de desperdicio de hardware y dinero, discutiblemente, gastar más segundos o milisegundos atendiendo una consulta de un usuario dado en tu aplicación o aplicación web.

Pero resulta que podemos hacer algo inteligente aquí. Nota que en nuestra estructura de base de datos, hemos hecho algunas cosas aquí. Permíteme abrir, por ejemplo, people. Más bien, vayamos a people, y verás algunas palabras clave que ignoré antes. Cuando defines una tabla, puedes especificar que una de tus columnas es lo que se llama una clave primaria. Esa es la columna por la cual vas a identificar de manera única todos tus datos, así como esos IDs numéricos que hemos dado a cada persona y show. Una clave foránea es lo que llamamos el mismo número cuando aparece en otra tabla. Así que cuando vimos un person_id o show_id, esos son lo que llamamos claves foráneas, porque son los mismos números, pero en otra tabla que estamos usando para unir cosas juntas, eventualmente. Y también puedes definir columnas como únicas, o puedes indexarlas para mayor eficiencia. Y eso es, de hecho, a donde vamos ahora.

Si miras la misma consulta, notarás que estoy buscando en un montón de columnas. Claramente estoy buscando en el campo name. También estoy buscando -- es decir, uniendo -- en show_id, y estoy buscando en person_id, sin mencionar los campos ID individuales. Pero lo genial de una clave primaria, que hemos definido de antemano para todas nuestras columnas de ID, es que obtienes una característica de forma gratuita con SQL. SQL construye lo que se llama un índice, una estructura de datos muy sofisticada, una estructura de árbol, que en realidad te permite buscar información de manera bastante eficiente.

Así que cuando defines una columna como clave primaria, obtienes esa velocidad de forma gratuita. Pero también podemos decirle a nuestra base de datos SQL, sabes qué, planeo buscar en los IDs de persona y show, y también en nombres, así que vamos a proceder y crear algunos índices. Permíteme proceder y ejecutar las siguientes consultas solo una vez. Permíteme crear algo llamado un índice llamado person_index en la tabla stars usando su columna person_id. Así que una sintaxis bastante rápida. Esto significa crear un árbol B, crear una estructura de árbol elegante, llamada índice de persona, en la tabla de stars por columna de person_id. Es decir, hacer una tabla como esta en memoria para almacenar todos los IDs de persona. ¿Por qué? Para poder encontrarlos más rápido que una búsqueda lineal en la columna en sí.

Permíteme proceder y ejecutar esto. Y verás que toma un momento. Está pensando. Tomó 1.6 segundos. Un poco lento, pero solo tengo que hacer esto una vez. Permíteme crear dos más. CREATE INDEX llamado show_index ON stars ON la columna show_id. Así que casi lo mismo, pero esto solo significa dame un árbol que se vea así en la memoria, para que cuando busque datos como Ellen DeGeneres, busque una estructura tipo árbol en lugar de una estructura tipo lista en una columna sola.

Permíteme ejecutar eso. Y cometí un error en stars show_ID. Ahí está. Tomó 1 segundo. Y por último, vamos a crear un índice llamado name_index en people en la columna name para poder buscar personas por nombre de manera más eficiente también. De lo contrario, sin estos índices en una columna como name, va a revisar todas las celdas en la columna buscando Ellen DeGeneres, Ellen DeGeneres, Ellen DeGeneres, usando un tiempo de ejecución de big O de N, o búsqueda lineal.

Así que ahora, permíteme volver a mi consulta aquí. No he realizado ningún cambio en la consulta. La última vez que ejecuté esto, tomó casi 2 segundos. Ahora, después de crear estos índices y decirle a mi base de datos SQL que planeo buscar en esas columnas, observa esto y observa el número azul destacado. 8 milisegundos. 8 milisegundos. 7 milisegundos. 7, 7, 7. Parece que 4 milisegundos esa vez. Así que esto es lo que los Google del mundo, los Facebook del mundo, los Microsoft, que tienen datos muy grandes, no solo almacenan sus datos en bases de datos como estamos haciendo aquí, sino que también indexan sus tablas de manera inteligente, incorporando ideas de semanas anteriores, para que la base de datos, para ellos, y de forma gratuita, y de alguna manera mágica, cree este tipo de estructuras en memoria, pero lo haga de manera que puedas buscar, insertar y actualizar tus datos de manera aún más eficiente.