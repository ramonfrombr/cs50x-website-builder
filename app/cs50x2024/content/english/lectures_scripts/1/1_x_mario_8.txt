But let's go ahead and skip ahead, say, to something like this in Mario, where you have a whole lot of bricks underground. And this time, it's not just a column or a row of bricks. This time, it's kind of two dimensions. Well, this is kind of interesting, because now how do you go about printing block, block, block, block, block, block, block, block, block, block, block, block, and actually making a two-dimensional structure instead? Well, there's nothing stopping us in C, as in Scratch, from doing something, for instance, with loops. So let me show this example here. So suppose that with these first lines of code, I've asked the user for the size of this block. So I want to create something that's square-like like this-- block, block, block, block, block, block, block, block, block, and so forth. Well, I can go ahead and prompt them for an int again and again and again until I know that size. And then notice this. This is starting to escalate again, but consider the logic. This now is for int i get 0, i less than n, i plus plus. So do the following n times, right? This is a very cryptic, C-like way of saying, do the following n times. What about line 16? What is line 16 saying? Even though it's using a different variable. I'm using j just because instead of i. AUDIENCE: Same thing. Do the following n times. DAVID MALAN: Yeah, it says the exact same thing-- do the following n times. However, it's counting using j instead of i, just so that my math doesn't kind of commingle incorrectly. So if you think about what this Mario block is, this is like printing rows and columns. Kind of like an old school typewriter that's got to move from left to right and then top to bottom, top to bottom, left to right, and so forth just to print different blocks on different lines. So the effect here-- if I open up mario8-- might be this, make-- oops. Let me go ahead and make mario8, ./mario8. What's the size going to be? Well, maybe three. And now I've printed out three rows and three columns. These essentially represent each of my rows. I'm counting from i up to-- oh. I'm teaching myself now only, OK. Let's rewind. Here is what was amazing me a moment ago. When I was running what's the size of this program, I saw a three-by-three grid of blocks. And if I run it again, maybe with 10, I now see an even bigger grid of 10-by-10 bricks. It's a little taller than it is wide, because the hash marks are taller than they are wide. And you'll see that now this program is dynamic. So how is that working? Well, if I actually look at the code here, notice that, effectively, what line 14 is doing is it's doing one row at a time. It's giving me n rows, and each of those rows I'm thinking of this is i at 0, i1, i2, and so forth. Meanwhile, within each row, I'm using this inner loop, which is deliberately nested inside, to kind of do each of the characters from left to right. So within each row, I want hash, hash, hash, hash. Within each row-- hash, hash, hash, hash. So it's like implementing this two-dimensional process. But again, using the same fundamental ideas. Just a for loop that's very carefully counting from zero on up to some value to do something again and again and again. And so if you think about really any of today's games or graphics or programs, anytime you see redundancy, whether it's this in two dimensions-- maybe it's this vertically in one dimension or this horizontally in another. Odds are, there's just some repetition that's happening again and again and again that can be reduced in C or in Scratch or some other language to ultimately just lines of code. And indeed, this is an allusion to one of the first things you'll do for the first problem set, problem set 1. You'll use CS50 Lab, which is identical to CS50 Sandbox, which I've been using thus far, but which adds instructions, the actual problems to solve, alongside of your sandbox.