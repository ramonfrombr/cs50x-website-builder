En fait, permettez-moi d'aller plus loin et de faire ça. Laissez-moi écrire un programme que je vais appeler float.c. Et ça va simplement être un programme qui obtient quelques valeurs de points flottants de l'utilisateur. Laissez-moi aller plus loin et inclure la bibliothèque CS50. Allons-y et incluons stdio.h, int main void, comme avant. Et tout ce que je veux faire ici avec ce programme est d'obtenir quelques flottants. Donc donnez-moi un flottant. Nous l'appellerons x. Get_float, et je demanderai à l'utilisateur le x. Ensuite, permettez-moi d'aller plus loin et d'en obtenir un autre. Je l'appellerai y. Get_float, autrement dit y. Et rappelez-vous qu'un flottant est juste un nombre qui a une virgule décimale, un nombre réel. Maintenant, faisons simplement une division simple. Je prétends que les ordinateurs peuvent faire des additions, des soustractions, et ainsi de suite. Alors faisons ça. Disons-lui simplement que x divisé par y sera égal à ce qui suit - %f barre oblique inversée n x divisé par y point-virgule. Donc c'est juste une sorte de calculatrice très simpliste que j'ai mise en œuvre et qui prend uniquement en charge la division. Permettez-moi d'aller plus loin et de compiler cela en allant taper make floats. Et vous verrez que ça compile. Donc floats avec dot slash. x sera, disons, 1. y sera 10. OK, viola. x divisé par y est égal à 0.10000. C'est plutôt sympa. Et rappelez-vous, si vous ne voulez pas voir tous ces zéros, vous pouvez simplement dire, montrez-moi une décimale en ajoutant 0.1. Recompilez puis exécutez à nouveau. Et maintenant faites 1, 10. OK, donc maintenant c'est 1/10. Ou l'est-ce? Maintenant que j'ai cette capacité de regarder au-delà de la virgule décimale, pourquoi ne regarderais-je pas à quelques endroits ou à un endroit. Permettez-moi d'aller plus loin et de regarder peut-être 10 endroits après la virgule décimale. Laissez-moi réexécuter cela en tant que make floats, ./floats, 1, 10. Intéressant. Très bien, ça semble un peu étrange. C'était peut-être juste un coup de chance. Regardons un peu plus loin. Regardons 50 décimales plus loin. Allons-y et recompilons cela. Et il s'avère qu'il existe des raccourcis clavier. Je frappe maintenant les flèches haut et bas sur mon clavier, ce qui va faire défiler tout votre historique de commandes afin que vous n'ayez pas à tout mémoriser. Donc pour gagner du temps, je ne fais que monter et descendre. Permettez-moi d'aller plus loin et de faire ./floats maintenant, 1, 10. Oh mon dieu, la division est un mensonge. Donc, quand vos professeurs d'école primaire ou autres vous ont appris que 1 divisé par 10 est 1/10, ou 0.10000 à l'infini, apparemment ce n'est pas vrai. Selon cet ordinateur, 1/10 est en fait cette valeur. Alors comment pouvons-nous concilier cela? Qui a raison, les mathématiques primaires ou les ordinateurs? Et qu'est-ce qui pourrait l'expliquer? Des idées? Oui? AUDIENCE: Il ne stocke que tellement et donc la moitié de ça, vous ne savez pas ce qui se passe là-bas. DAVID MALAN: Oui, c'est une bonne façon de le dire. Les ordinateurs ne peuvent stocker que tellement, donc après un certain point, vous ne savez pas ce qui se passe. J'aime ça. Parce que c'est en effet vrai. Si vous n'avez qu'une quantité finie de matériel, comme une quantité finie de mémoire, à un moment donné, l'ordinateur doit décider, je ne peux pas compter plus haut que cette valeur. Ou je ne peux pas stocker plus que ce nombre de nombres après la virgule décimale. Vous utilisez peut-être 32 bits, ce qui est le cas d'un flottant. Vous pourriez utiliser plus de bits, comme un double, comme je l'ai décrit précédemment, il utilise littéralement deux fois plus de bits, 64 bits. Cela signifie que nous pourrions aller plus loin avant de voir cette imprécision. Mais tu le verras. Les ordinateurs ne sont en effet pas parfaits en ce sens. Ils ne peuvent stocker qu'une quantité finie d'informations. Et donc en ce sens, l'ordinateur stocke la correspondance la plus proche possible de 1 divisé par 10 qu'il puisse faire. Parce que vous ne pouvez pas stocker un nombre infini de nombres avec une précision de 100% en utilisant une quantité finie d'informations. Et nous le voyons aussi dans un autre contexte.