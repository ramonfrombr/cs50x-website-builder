So we are back, and now we begin focusing not just on comparisons of C with Scratch, but on actually writing some code from Scratch but in C. And the goal at hand really is to begin to develop the muscle memory via which you can start with literally empty files and start to fill it with C implementations of your ideas. So rest assured that all of the examples we're about to do live are already pre-baked online, so you'll be able to download all of these examples from the course's website. In Brian's super section will you be able to explore them in more detail. And later this week will you have opportunities hands-on to work on these same types of programs, as well. For now, the overarching goal is exposure and concepts and the beginning of developing that muscle memory. So with that said, let me go ahead and create a new file called int.c, the purpose of which is going to be to get an integer from the user, much like a bit ago I got a string from the user. I'm going to go ahead and, as before, I'm going to include some familiar files. So I'm going to go ahead and include preemptively CS50.h so that have I access to strings and get_string and get_int and get_float and other features, as well. I'm going to include stdio.h so that I have access to printf so I can actually see what we're doing. Then I'm going to do this, which again, for today's purposes and for a couple of weeks, is just kind of copy/paste. This is the equivalent of when green flag clicked, but we'll explain, in a couple of weeks, exactly why you're writing int and why you're writing void. In here, I'm going to do something like this. This time, I want to get not a string but an int. So let's do in age get get_int, what's your age? Now, to be fair, I can probably type that pretty quickly, because I have the muscle memory already for programming in C. But if we look at it real methodically for a moment, this is just another function, get_int, from the CS50 library that's going to get an integer. This is the prompt that the human is going to see with their cursor moving to a new line because of the backslash n. And whatever they type in is going to get copied from right to left into a variable called age, the type of which, so to speak, is int, or integer. Now let me go ahead and compute, like, how many days old this person is. So if I want to do that, I could do something like this. Well, give me an integer. Call it days. And then just do age times 365. I proposed a bit ago that there's a bunch of arithmetic operators like plus and minus and multiplication and subtraction and even the remainder operator. So this line, 7, just says multiply age by 365. Copy that value, from right to left, into a new variable called days. And now I can go ahead and print this if I want. So printf something like, you are at least percent-- not s, because it's not a string, but percent i because it's an integer now-- days old, backslash n. But again, this is a placeholder, so I'm not done yet. What do I need to put inside of these parentheses also on line 8? Yeah, so comma, days, if that's the value that I want to plug in. And I'm missing one more thing. AUDIENCE: Semicolon. DAVID MALAN: Semicolon at the end of the line. Now, hopefully, I got this right. But odds are the first time you write your programs, you're going to see error messages. But let's see, make int is the quickest way now to compile this code. Enter. All right, the big, long white command is OK. So long as you don't see red or yellow or colored output that indicates warnings or errors, you should be OK. I'm going to clear my screen now so I can just now run this program, ./int. And suppose your age is, say, 50. Well, you are at least 18,250 days old. But let me use this as an opportunity to not just do something correct, which I claim this code is, but to just make it better designed. It's fine to be storing this value, age, in a variable called age. And it's fine to be creating a second variable called days, in which my mathematical answer is age times 365. But strictly speaking, I don't need that additional line of code. I could also just do age times 365 here. So C is nice like that. You can compose, just like in Scratch, bigger ideas from multiple smaller pieces. And frankly, if I really want to get crazy, notice I can actually highlight that whole function call, so to speak, get rid of the age all together, and just plug this in here times 365. But at this point, we're starting to cross an inflection point. Yes, this is correct, because I, strictly speaking, don't need a variable, right? I can pass-- we saw last week-- one function's output as another function's input by just nesting them in this way. But honestly, now we're at the point where this line of code is so relatively long, it's just too hard to read. And so this is an example where, for design's sake, you know what? The previous version was probably a bit better, because I can read the code more top to bottom than left to right. But this is a design decision. And indeed, you might agree or disagree. You might agree or disagree with your teaching fellow, or TF, ultimately. These are the kinds of decisions that go into writing good or bad code or good or better code. Much like in an English essay or in any written language, you could argue that one person has written their document better than another. So we'll begin to appreciate these nuances over time.