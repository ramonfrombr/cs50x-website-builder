Let me go ahead and open up an example that builds on this same idea. In, let's see, positive.c, we have this example here, which makes this all the more clear. So here's a program that uses our two libraries, CS50 in standard I/O. It turns out that the CS50 library does not come with a function called get_positive_int. It comes with get_int. And you could imagine programs where you really want a positive integer from the human, because negative numbers for a game or for some program just would make no sense. So how can we implement that? Well, it would be nice to create it so that you can simply write a two-line program like this where you call a function called get_positive_int. And if I scroll down, notice there's actually a new feature here that we've not seen yet, but it's an interesting example of another feature of C. What I've highlighted here between lines 15 and 24 is this logic. Here's a function called get_positive_int. It takes no inputs, so I don't have to pass anything in parentheses. I just want to get any old positive int. But I do want this function to hand me back something, just like get_int handed me back a value that I could put in a variable, just like get_string does. So this is not void. This is int. So this word to the left of a function is the type of its output. This word in parentheses is the type of its input, if any. And if there is nothing, you just say void in either or both place. Now, here's a curiosity-- on line 17, we've not seen this before, but this is just a hint to the computer saying give me a variable called n. I'm not sure what I'm going to put in it yet. So you literally just say int n semicolon. You don't need to assign it anything yet. It has what we'll call a garbage value. You have no idea what's in it, but that doesn't matter. You'll put something in it later. Then there's this loop, which we haven't seen yet, but in C, it's called a do-while loop. It literally says do the following while this Boolean expression is true. So what do I want to do? I want to get an int from the user, prompting the human for a positive integer, and store it in n. However, I want to keep doing this while n is less than 1. Because if the human types in 0 or negative 1 or negative 50 or anything non-positive, I do want to prompt them again and again and again. So a do-while loop is kind of neat, because it will do this first thing at least once. Then it will check the condition and potentially do it again if the human has not cooperated. A while loop, if you think back, actually checked the condition first. It was while some Boolean expression is true, do the following. This one gives you one such iteration, one pass for free, and then it checks the condition. So it's just a different way of programming, but we could do everything we've done thus far using while loops or even for loops, as well.