Très bien, prenons un autre exemple. Comment cela s'appelle-t-il dans Scratch ? Oui, une condition, une décision que vous devez prendre. Donc, si quelque chose est vrai, alors faites-le. En C, nous pourrions le convertir comme suit. Si x est inférieur à y entre parenthèses-- ce qui n'est pas tout à fait la forme anguleuse que nous avons ici en vert, mais en C, vous utilisez des parenthèses ici. Donc, si x est inférieur à y, ouvrez la parenthèse, fermez la parenthèse, puis allez-y et faites ce qui suit. Et tout comme cette pièce de puzzle jaune ou orange semble étreindre la pièce violette, de même cette accolade ouvrante et cette accolade fermante, pour ainsi dire, sont là prêtes à enlacer ou à encapsuler une ou plusieurs lignes de code. Quelle est la ligne de code ? Cela pourrait ressembler à quelque chose comme ça-- printf x est inférieur à y backslash n. Donc, encore une fois, une nouvelle syntaxe, mais nous avons déjà vu les accolades dans le contexte de main. Et nous avons déjà vu des parenthèses dans le contexte des entrées. Donc c'est juste une sorte de modèle que nous allons commencer à suivre en C chaque fois que nous voudrons faire quelque chose conditionnellement. OK, dans Scratch, nous avons vu quelque chose comme ça-- si x est inférieur à y, alors dites que x est inférieur à y. Sinon, concluez que x n'est pas inférieur à y. En C, cela ressemble presque à la même chose, mais vous vous installez avec un bloc else avec deux ensembles d'accolades, sorte de deux caractères prêts à enlacer les lignes de code entre eux. Et nous pouvons simplement brancher maintenant, littéralement, les traductions en printf en disant printf x est inférieur à y ou printf x n'est pas inférieur à y. Maintenant, remarquez, il n'y a que deux points-virgules dans cet exemple. Vous ne terminez généralement pas des choses comme des conditions avec des points-virgules. Vous terminez les fonctions ou les lignes impliquant des fonctions avec des points-virgules. Et ce n'est pas une règle stricte, mais vous ne voulez pas de lignes de code-- vous ne voulez pas de points-virgules après chaque ligne de code. Vous le voulez généralement après certaines actions. Et vous commencerez à remarquer ce modèle, même s'il n'est peut-être pas évident au début. Très bien, et celui-ci ? Si, sinon si, sinon si. Maintenant, remarquez que nous réutilisons simplement le bloc if-else if, puis un autre bloc if ici en bas. Il s'avère qu'en C, c'est presque un peu plus facile. Vous pouvez littéralement simplement dire ceci-- si x est inférieur à y, faites ceci avec des accolades. Sinon, si x est supérieur à y, faites ceci entre accolades. Sinon, si x est égal à y, faites ceci entre accolades. Et que voulez-vous faire dans chaque cas ? Différents printf basés sur les messages de type say que nous voulons afficher. Mais il y a ici une curiosité. Cela ressemble presque à une faute de frappe. Oui, le double signe égal. Mais ce n'est pas un bug. Ce n'est pas une erreur. Pourquoi est-ce que j'utilise peut-être ici un double signe égal au lieu d'un signe égal simple, comme dans Scratch ? Laissez-moi aller ici. D'accord ? PUBLIC : [INAUDIBLE]. DAVID MALAN : Exactement. J'ai dit plus tôt que le signe égal simple était utilisé pour l'affectation de droite à gauche. Et honnêtement, c'est juste une sorte de situation humaine, où nous nous sommes enfermés dans un coin. Nous utilisons déjà le signe égal pour l'affectation. Ensuite, vraisemblablement, un être humain a réalisé, oh, mince, comment posons-nous la question, est-ce égal à cela ? Eh bien, nous avons déjà utilisé ce symbole. Ainsi, les humains, il y a des décennies, ont décidé, très bien, nous allons résoudre ce problème en utilisant simplement deux signes égaux dos à dos. C'est donc ce qu'on appelle l'opérateur d'égalité. Un seul signe égal est juste l'affectation. C'est, haut la main, l'une des erreurs les plus courantes à commettre au début, surtout si vous utilisez Scratch ou d'autres langages au préalable. Et vous développez simplement la mémoire musculaire au fil du temps. Une fois que vous aurez fait cette erreur plusieurs fois, elle disparaîtra. Très bien, mais il s'avère que ce programme, bien qu'arguablement correct-- ou ce code, bien que correct, en ce sens qu'il va faire ceci ou cela-- et je pense que ce sont les trois situations possibles. Si vous avez deux nombres entiers, x et y, x est soit inférieur à y, supérieur à y, soit égal à y. Mais il n'est techniquement pas nécessaire de poser l'une de ces questions. Il y a techniquement trois expressions booléennes ici, n'est-ce pas-- x inférieur à y, x supérieur à y, x est égal à y. Une expression booléenne, rappelons-le, est une question à laquelle elle a une réponse oui/non ou une réponse vrai/faux ou une réponse 1/0. Mais je n'ai pas besoin de poser trois questions ici, n'est-ce pas ? Je pense avoir vu votre main. Pourquoi pas ? PUBLIC : Eh bien, parce que si x est inférieur à [INAUDIBLE].. DAVID MALAN : Exactement. Cette troisième question, cette expression booléenne, x est-il égal à y, va sans dire logiquement. Parce que si x n'est pas inférieur à et qu'il n'est pas supérieur à, si c'est juste [INAUDIBLE], le seul autre scénario auquel je peux penser est qu'il est égal à y. Nous pouvons donc simplifier à la fois le code Scratch et le code C en ayant simplement cette condition else en bas également. Nous allons donc parler, au cours des prochaines semaines, des différentes qualités du code. L'exactitude, comme ce qu'il est censé faire, mais aussi la qualité de la conception, comme avez-vous écrit ce code aussi efficacement que possible, aussi rapidement que possible, de manière à utiliser le moins de mémoire et le moins de CPU, le cerveau de l'ordinateur ? Et ce n'est qu'une allusion à ce genre de capacité.