DAVID MALAN : Très bien. Nous sommes dans CS50, et aujourd'hui nous allons nous pencher davantage sur le fonctionnement, pour ainsi dire, de la programmation, comme nous l'avons fait au cours des dernières semaines, et plus particulièrement sur la programmation en C. De plus, nous allons essayer de nous concentrer sur quelques nouvelles techniques de programmation, vraiment sur les principes de base, pour que ce que vous avez vu au cours des dernières semaines n'ait plus l'air d'une magie.

Si vous tapez en quelque sorte ces incantations magiques et que vous ne comprenez pas vraiment pourquoi ça marche, sachez que vous finirez par comprendre et apprécier d'autant plus la pratique et l'application de ces concepts. Mais aujourd'hui, nous allons revenir aux principes de base, un peu comme le contenu de la semaine 0, pour nous assurer que vous comprenez que ce que nous faisons maintenant dans la semaine 2 n'est pas très différent de ce que nous avons fait lors de la semaine 0.

Donc, en fait, regardons l'un des premiers programmes que nous avons vus en C, qui ressemblait un peu à ceci. C'est notre code source, pour ainsi dire. Il y avait quelques caractéristiques saillantes de la semaine dernière qui correspondaient à la première semaine, semaine 0. C'était ce truc appelé main, qui est juste la fonction main. C'est le principal point d'entrée de votre programme. C'est l'équivalent de Scratches lorsqu'on clique sur le drapeau vert.

Bien sûr, voici un exemple d'une autre fonction, une fonction fournie avec C qui vous permet d'imprimer à l'écran. Elle peut recevoir des entrées, au moins une entrée ici, qui est généralement une chaîne entre guillemets, comme le message « hello world ». Mais bien sûr, pour utiliser printf en premier lieu, vous aviez besoin de ce truc ici. Et Standard io.h représente quoi, d'après votre compréhension ?

Des idées sur ce qu'est Standard io.h ? Oui ?

PUBLIC : Une bibliothèque sur la façon dont [INAUDIBLE].

DAVID MALAN : Oui, c'est une manifestation de ce qu'on appelle une bibliothèque, du code que quelqu'un d'autre a écrit il y a des années. Plus précisément, Standard io.h est un fichier d'en-tête. C'est un fichier écrit en C mais avec une extension de fichier se terminant par un point h qui, entre autres, déclare qu'il a le prototype, pour ainsi dire, de printf pour que Clang, lorsque vous compilez votre code, sache ce qu'est réellement printf.

Et bien sûr, cette petite chose ici, vous avez probablement pris l'habitude d'utiliser ce /n qui est une nouvelle ligne. Et il force le curseur à passer à la ligne suivante. Ce sont donc quelques-unes des caractéristiques les plus laides du code de la semaine dernière, et nous allons disséquer int et void ainsi que quelques autres choses au cours d'aujourd'hui et au-delà.

Donc, lorsque vous compilez votre code avec Clang, hello.c, puis que vous exécutez ce programme, ./a.out, ce que vous n'avez probablement pas fait vous-même depuis, parce que nous vous avons donné un moyen plus simple de le faire, ce processus consistait à créer un fichier contenant des zéros et des uns que l'ordinateur comprend, appelé a.out que vous pouvez exécuter. Bien sûr, a.out est un nom assez stupide pour un programme. Il est à peine descriptif, même si c'est la valeur par défaut.

Donc, le programme suivant que nous avons écrit et compilé, nous avons utilisé -ohhello, qui est un argument de ligne de commande pour Clang. C'est comme une option qu'il fournit et qui vous permet de spécifier le nom du fichier en sortie. Vous l'avez fait la semaine dernière avec l'ensemble de problèmes, avec quelques programmes que vous avez écrits vous-même.

Mais que se passe-t-il réellement lorsque vous compilez votre code via ce processus ? Eh bien, il s'avère que si nous rendons ce programme un peu plus intéressant, cela devient encore plus important avec un code comme celui-ci. Maintenant, j'ai ajouté quelques lignes de code. CS50.h, qui est le représentant de la bibliothèque CS50. Encore une fois, du code que d'autres personnes ont écrit, dans ce cas, le personnel il y a quelques années, qui déclare qu'il a des prototypes pour les lignes uniques pour des fonctions comme GetString afin que vous puissiez utiliser plus de fonctionnalités que celles fournies par C par défaut.

Et il contient des choses comme String lui-même, un type de données. Donc GetString est déclaré dans ce fichier. Le nom est, bien sûr, une variable dans laquelle nous avons stocké mon nom la semaine dernière. String est le type de variable dans laquelle nous avons stocké un nom. Et tout cela est ensuite sorti bonjour, quelque chose, où le rappel percent S était un espace réservé, le nom est la variable que nous avons insérée dans ce code de format, et tout cela est possible grâce à CS50.h, qui déclare la chaîne et nous donne également GetString.

C'est donc un paradigme qui est pour l'instant spécifique à CS50, mais il est représentatif de toute une série d'autres fonctions que nous allons commencer à utiliser aujourd'hui et dans les semaines à venir. Le processus va maintenant être le même. Cependant, lorsque vous avez compilé ce programme qui utilisait la bibliothèque CS50, vous vous en souvenez peut-être et vous avez peut-être été bloqué la semaine dernière si vous avez utilisé Clang et non un autre programme, vous avez besoin de ce -lcs50, et vous en avez besoin à la fin juste parce que. C'est ainsi que Clang l'attend.

C'est un indicateur spécial que nous allons disséquer dans quelques minutes, un argument pour Clang qui lui dit de lier, pour ainsi dire, lier tous les zéros et les uns de la bibliothèque de CS50. Mais nous verrons cela dans un instant. C'est bien sûr ainsi que vous devriez probablement compiler votre code à partir de maintenant. C'est très simple, mais cela automatise tout ce que nous venons de voir de manière plus pédante, étape par étape.

Donc, nous avons compilé notre code la semaine dernière, et nous allons continuer à le faire pendant les prochaines semaines, jusqu'à ce que - spoiler - nous arrivions à Python, et vous n'aurez plus à compiler quoi que ce soit. Ça va juste se faire automatiquement pour vous. Mais jusque-là, la compilation est en fait une simplification excessive de ce qui s'est passé la semaine dernière. Il s'avère qu'il y a en fait quatre étapes distinctes que vous avez toutes induites en exécutant Make ou même en exécutant Clang manuellement à l'invite de commande.

Et juste pour que, encore une fois, nous puissions comprendre ce que vous faites lorsque vous exécutez ces commandes, allons aux principes de base, comprenons ces quatre étapes, mais ensuite nous allons passer à autre chose comme dans la semaine 0 et stipuler, OK, j'ai compris. Je n'ai pas besoin de penser à ce bas niveau après aujourd'hui. Mais j'espère que vous comprendrez ces quatre étapes de bas en haut.