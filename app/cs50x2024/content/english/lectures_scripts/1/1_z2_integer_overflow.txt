But what has happened? And there's kind of an illusion to it, both in my program's name and in the red error. Well, at some point, you only have so many bits after which if you keep incrementing, incrementing, incrementing, you don't have enough bits to sort of carry the one, so to speak, and remember the even bigger value. After all, if we go back to some of our discussion last week to discuss now what's called floating point imprecision or now integer overflow, which means floats can only be so precise and integers can only be so big. What you have is the following scenario. 123 in decimal, in our human world-- of course, you can just keep adding one to it. And as soon as you hit nine, it rolls over to zero. You then carry the one, and you have 130. That works great. But of course, even in decimal, if you're at 999 using only three digits and you try to add one more, you carry the one, you carry the one, you lose the one. Sorry. What happens next? This becomes 1, 0, 0, 0. But if you only have three digits, you lose that initial one, and you're left with just zero. Same thing happens in binary. Now if you context switch-- and this is, in binary, what number? This is the fours place, twos place, ones. So it's seven. 4 plus 2 plus 1, this is 7. So of course, if you add 1 to 7, you'd like to get 8, which would give you 1, 0, 0. But if you only have three bits, three digits, you're going to overflow, so to speak. You're going to lose the carried one so that the value you're actually storing is just zero. That's why if I count high enough with an integer in a program, once I hit the billions, eventually that one has gotten carried too far. It's only 32 bits large. We can't fit a number even bigger than that. That's what's called integer overflow. And if you ever heard of the Y2K problem, this was a horrible, very simple problem that humans created for themselves back in the day when computers were invented in the mid 1900s, really. Humans decided to save space, very reasonable, because space was expensive early on. So instead of storing the year as 1999 or 1970 for 1970, what did they do? Yeah, they just stored two digits, right? Like oh my god, we're not going to be using these computers 50 years from now. Let's just store two digits. Unfortunately, that was not the case. And there was a lot of code out there and a lot of computers out there that were still running in 1999. But if you're only storing two digits and you plus plus one value to the year, what you'd like to be 2000 was misinterpreted in lots of systems as 1900, at which point stuff broke. And the world spent millions of dollars, presumably, having programmers start using more memory to fix this problem in anticipation of what was called Y2K to get ahead of this problem. And in the end, the world did not end in 1999, which was great. But it was a very real and a very expensive problem because of that lack of foresight. It turns out that there's other examples of this, as well. So this one, as an example, will just about end on Boeing 787. So Boeing has not been getting great press recently. And even a few years ago, did they have what appeared to be a very straightforward software bug. Pictured here is a model 787 airplane. And the article from The New York Times explained as follows-- "A model 787 airplane that has been powered continuously for 248 days can lose all alternating current, electrical power, due to the generator control units simultaneously going into failsafe mode. This condition is caused by a software counter internal to the counters that will overflow after 248 days of continuous power. Boeing, according to the statement, is in the process of developing a software upgrade that will remedy the safe condition." So what does this mean? Well, if you actually dig into the numbers, 248 days is roughly the value of 2 raised to the 32nd power, give or take, in 1/100 of a second. Which is to say that Boeing, in some crucial piece of hardware in their 787 actual airplanes, were using integers that were counting so high that after the 248th day of the airplane being powered on would actually overflow, the result of which is that the power in the plane could cut off entirely. And so the solution, if you read through all the technical speak and jargon there, is they literally had to reboot their planes every 248 days in order to reset that variable back to zero. This happens even today in the real world with issues like that. And so you'll begin to notice these trends anytime people talk about hardware mistakes or software mistakes. Quite honestly, can you typically reduce them to problems you yourselves have run into. And let me go ahead and tease just a couple of things, a couple of features now ahead. It turns out that now that we have the ability to write code, our programs, of course, can do any number of things, saying or printing things on the screen. We, of course, might do something like this in a program we might call figlet, which actually comes with some systems. And I can say something like, this is CS50, and actually print it out in what's called ASCII art using characters on the screen that kind of sort of look like letters and create fairly beautiful, if old school, art on the screen. Of course, if you write code and you understand not only how numbers and letters are represented, but also sounds, per our chat last week, you can do even more powerful things, such as this note, which we will literally end on today. SPEAKER 2: This is CS50. DAVID MALAN: That's it for CS50. We will see you next week. [APPLAUSE]