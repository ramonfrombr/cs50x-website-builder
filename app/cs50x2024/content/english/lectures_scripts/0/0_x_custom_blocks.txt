But there's this other idea in computer science, this notion of abstraction. Right now, this is a program that just so happens to implement the notion of coughing. But what if I want to use the same idea in multiple programs and I want to give myself a custom puzzle piece that does not come with Scratch called cough? Well, there's this one other feature up here I can do like my blocks, and I can make a block. And I'm going to go ahead and call this cough. And that puzzle piece, once I click OK, is going to give me this pink block here. I'm going to go ahead now, for instance, and move all of this down to the custom puzzle piece. And now notice because I've made a new block, I have this pink piece here. I can now move this over here. And frankly, out of sight, out of mind. I can literally ignore those puzzle pieces I created because now I have a new puzzle piece just called cough that says what it does. This is an abstraction in the sense that I don't care how you implement coughing, I just care that your program can cough. And so we have this notion of reusability that starts to make our code no less sophisticated, but much, much smaller and much less prone, potentially, to mistakes. And I can take this one step further. Let me go ahead and open up a different variant of this one altogether, this one in cough three. You can have these custom puzzle pieces even take arguments. You can have this puzzle piece called cough say, well, how many times do you want to cough, thereby taking an input. Then you can repeat that number of times cough for a second and wait one second. So if you want to now use this fancier puzzle piece up here, notice this now looks even simpler. Go ahead and cough three times. And everything has been abstracted away. If I scroll up and out of the way, you don't even know or have to care how or why cough was implemented. And so whereas we began this whole conversation just looking for Mike Smith and trying to find an answer to a problem correctly, we talked then about efficiency and finding that solution not only for sure, but also quicker. And now we've spoken a little bit to ideas that lie ahead when it comes to the design of the quality of your code.