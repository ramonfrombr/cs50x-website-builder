Pero ¿qué ha ocurrido? Ambas cosas, el nombre de mi programa y el error rojo, crean una especie de ilusión. Bueno, en algún momento, solo tienes tantos bits, tras los cuales, si sigues incrementando, incrementando e incrementando, no tendrás suficientes bits para transportar el uno, por así decirlo, y recordar el valor aún mayor. Después de todo, si volvemos a parte del debate de la semana pasada para hablar ahora de lo que se conoce como imprecisión de coma flotante o desbordamiento de enteros, lo cual significa que los float solo pueden ser tan precisos y los enteros solo pueden ser tan grandes. Lo que tienes es el siguiente escenario. 123 en decimal, en nuestro mundo humano (por supuesto, puedes seguir sumándole uno). Y en cuanto llegas al nueve, vuelve a cero. Luego transportas el uno y tienes 130. Eso funciona genial. Pero, por supuesto, incluso en decimal, si estás en 999 usando solo tres dígitos e intentas sumar uno más, transportas el uno, transportas el uno y lo pierdes. Lo siento. ¿Qué ocurre después? Esto se convierte en 1, 0, 0, 0. Pero si solo tienes tres dígitos, pierdes ese uno inicial y te quedas solo con cero. Ocurre lo mismo en binario. Ahora, si cambias de contexto (y esto es, en binario, ¿qué número?), es el lugar de las decenas, las unidades y el cero. Así que es siete. 4 más 2 más 1, esto es 7. Así que, por supuesto, si sumas 1 a 7, te gustaría obtener 8, lo cual te daría 1, 0, 0. Pero si solo tienes tres bits, tres dígitos, vas a desbordar, por así decirlo. Vas a perder el uno transportado, así que el valor que realmente estás almacenando es solo cero. Por eso, si cuento lo suficientemente alto con un entero en un programa, una vez llego a los miles de millones, eventualmente el uno se ha transportado demasiado lejos. Solo tiene 32 bits de longitud. No podemos introducir un número más grande que ese. Eso es lo que se conoce como desbordamiento de enteros. Y si alguna vez has oído hablar del problema del año 2000, fue un problema horrible y muy simple que los humanos crearon para sí mismos en la época en la que se inventaron los ordenadores a mediados del siglo XX, en realidad. Los humanos decidieron ahorrar espacio, algo muy razonable, porque el espacio era caro al principio. Entonces, en lugar de almacenar el año como 1999 o 1970, ¿qué hicieron? Sí, solo almacenaron dos dígitos, ¿no? Como: "Dios mío, no vamos a utilizar estos ordenadores dentro de 50 años. Almacenemos solo dos dígitos". Lamentablemente, no fue así. Y había mucho código y muchos ordenadores que seguían funcionando en 1999. Pero si solo estás almacenando dos dígitos y sumas un valor al año, lo que te gustaría que fuera 2000 fue malinterpretado en muchos sistemas como 1900, momento en el que todo se rompió. Y el mundo gastó millones de dólares, presumiblemente, haciendo que los programadores empezaran a utilizar más memoria para solucionar este problema en previsión de lo que se conocía como el año 2000 para adelantarse a este problema. Y al final, el mundo no se acabó en 1999, lo cual fue genial. Pero fue un problema muy real y muy caro debido a esa falta de previsión. Resulta que también hay otros ejemplos de esto. Así que este, como ejemplo, terminará en el Boeing 787. Boeing no ha estado recibiendo buenas críticas últimamente. E incluso hace unos años, tuvieron lo que parecía ser un error de software muy directo. Aquí se muestra un modelo de avión 787. Y el artículo del New York Times lo explicaba de la siguiente manera: "Un avión modelo 787 que ha estado encendido continuamente durante 248 días puede perder toda la corriente alterna, la energía eléctrica, debido a que las unidades de control del generador entran simultáneamente en modo a prueba de fallos. Esta situación está causada por un contador de software interno a los contadores que se desbordará después de 248 días de funcionamiento continuo. Boeing, según la declaración, está en proceso de desarrollar una actualización de software que solucionará la situación segura". Entonces, ¿qué significa esto? Bueno, si realmente analizas los números, 248 días es aproximadamente el valor de 2 elevado a la 32, más o menos, en 1/100 de segundo. Lo que quiere decir que Boeing, en alguna pieza crucial de hardware de sus aviones 787 reales, estaba utilizando enteros que estaban contando tan alto que después del día 248 de encendido del avión, se desbordaban; como resultado, la energía del avión podría cortarse por completo. Y entonces la solución, si lees toda la jerga y los términos técnicos, es que literalmente tenían que reiniciar sus aviones cada 248 días para restablecer esa variable a cero. Esto ocurre incluso hoy en el mundo real con problemas como ese. Y entonces empezarás a notar estas tendencias cada vez que la gente hable de errores de hardware o software. Honestamente, normalmente puedes reducirlos a problemas con los que te has encontrado tú mismo. Y permíteme adelantarme y adelantar un par de cosas, un par de características ahora. Resulta que ahora que tenemos la capacidad de escribir código, nuestros programas, por supuesto, pueden hacer cualquier cantidad de cosas, diciendo o imprimiendo cosas en la pantalla. Nosotros, por supuesto, podríamos hacer algo así en un programa que podríamos llamar figlet, que en realidad viene con algunos sistemas. Y puedo decir algo como: esto es CS50, y realmente imprimirlo en lo que se conoce como arte ASCII usando caracteres en la pantalla que se parecen a las letras y crean arte bastante bonito, aunque antiguo, en la pantalla. Por supuesto, si escribes código y entiendes no solo cómo se representan los números y las letras, sino también los sonidos, según nuestra charla de la semana pasada, puedes hacer cosas aún más potentes, como esta nota, con la que literalmente terminaremos hoy. PONENTE 2: Esto es CS50. DAVID MALAN: Eso es todo por CS50. Te vemos la semana que viene. [APLAUSOS]