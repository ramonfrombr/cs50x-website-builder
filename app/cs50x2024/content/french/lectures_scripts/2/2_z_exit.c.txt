Maintenant, il y a un dernier détail que nous n'avons pas encore expliqué et c'est celui-là. Pourquoi diable main a-t-il une valeur de retour ? Et il n'y a pas vraiment de raison super convaincante ici, mais nous pouvons voir qu'il y a une raison de bas niveau pour laquelle c'est utile, mais ce n'est pas quelque chose sur lequel il faut trop insister. Il s'avère que main par défaut en C a une valeur de retour. Et même si nous n'avons encore jamais rien renvoyé de main, par défaut, main renvoie zéro. Zéro en informatique signifie généralement que tout va bien. C'est un peu paradoxal, car on pourrait penser que zéro---faux---mauvais. Mais non, zéro a tendance à être bon.

La raison en est que main peut renvoyer des valeurs non nulles, comme un, ou moins un, ou 2 milliards, ou moins 2 milliards. En fait, si vous avez déjà vu un message d'erreur sur votre Mac ou votre PC, il y a parfois une petite fenêtre qui s'affiche et c'est un code d'apparence cryptique, comme une erreur s'est produite, moins 42, ou autre. Ce nombre n'est qu'un nombre arbitraire que certains humains ont décidé que leur programme principal renverrait en cas de problème. Et nous pouvons le faire comme suit. Je peux écrire un programme comme celui-ci dans un fichier appelé exit.c qui a, disons, la bibliothèque CS50, qui inclut la norme Io.h, int main void---je vais revenir au vide, parce que je ne vais pas prendre de---ou en fait, non, je vais faire int rc, puis arg v chaînes entre parenthèses, donc je peux prendre un argument de ligne de commande, et je vais commencer à vérifier les erreurs.

Supposons que ce soit un programme pour lequel l'humain est censé fournir un argument de ligne de commande. Je vais le faire. Si arg c n'est pas égal à deux, vous savez ce que je vais faire ? Je vais crier à l'utilisateur, dire qu'il manque un argument de ligne de commande\n, mais maintenant je veux quitter le programme. Je veux faire l'équivalent de exit. Alors, comment faites-vous cela en C ? Vous renvoyez en fait une valeur. Et si tout va bien, vous renverriez zéro. Cependant, si quelque chose s'est mal passé, le ciel est la limite, jusqu'à 2 milliards ou moins 2 milliards. Cependant, nous allons rester simple et en renvoyer un seul, si quelque chose ne va pas.

Pendant ce temps, je pourrais dire printf, bonjour, pourcentage s. Tapez arg v one, comme précédemment. Et puis, si tout va bien, renvoyez zéro. Donc rien de nouveau ne se passe ici. Ce programme est très similaire au dernier, sauf qu'au lieu de dire bonjour par défaut, je vais crier sur l'utilisateur avec ça, argument de ligne de commande manquant, puis renvoyer un pour signaler à l'ordinateur, ce programme n'a pas réussi. Et je vais renvoyer zéro, si et seulement s'il le fait. Oui ?

PUBLIC : Pourquoi arg c est-il différent de zéro ?

DAVID MALAN : Pourquoi arg c n'est-il pas égal---vraiment bonne question. Alors laissez-moi aller de l'avant et changer cela. Qu'y a-t-il dans arg v zéro qui fait qu'il a deux choses au lieu d'une, si j'exécute David---si j'exécute mon nom, David. Eh bien, bonjour---laissez-moi recompiler. Faites arg v one, ou faites arg v, dot slash, arg v, hello---non, mauvais programme. Faites exit. Désolé. Il n'y a aucun programme pour détecter cette erreur. Dot slash exit, argument de ligne de commande manquant. Cependant, si je fais exit David, maintenant je vois---oh, ai-je exécuté arg v avant ? Vérifiez la bande.

Bonjour dot exit. Donc dans arg v, le premier mot que vous tapez, le nom du programme, est stocké dans arg v zéro. Le deuxième mot que vous tapez, le premier argument qui vous intéresse, est un arg v one. Et c'est pourquoi arg c vaut deux. J'ai littéralement tapé deux mots à l'invite, même si un seul d'entre eux est techniquement un argument qui m'importe.