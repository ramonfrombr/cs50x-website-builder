Muy bien, estamos de vuelta. Ahora tenemos muchos más datos, porque ya hemos descargado ese archivo TSV muy pesado de IMDB. Lo he simplificado en algunos archivos CSV, pero eso solo nos lleva a la mitad del camino, porque ahora, si quiero buscar datos con search.py, aún tengo que revisar miles de líneas de series de televisión. Y solo será una búsqueda lineal debido a la naturaleza de cómo se leen los archivos, de arriba a abajo y de izquierda a derecha.

Sin embargo, resulta que Python te permite escribir código SQL. Y CS50 tiene una biblioteca de Python que incluye no solo get string y get int, etc., sino que también tiene una función SQL integrada que te permite conectarte a un archivo que termina en algo como .db, lo que significa que, en un momento, empezaremos a escribir algo de código Python para cargar un conjunto de datos realmente grande como el de IMDB en una base de datos SQL adecuada, lo que nos permitirá usar todo el poder y capacidad expresiva de SQL de aquí en adelante, y más ejemplos como SELECT, UPDATE, DELETE e INSERT, sin tener que escribir mucho código Python.

Para aclarar, en lugar de usar Python para buscar y manipular datos, vamos a escribir un script, un programa en Python, cuyo único propósito es pasar datos de un formato a otro. Y se puede imaginar que es algo útil en general, ya sea una hoja de cálculo de Google que haya descargado o un gran conjunto de datos que haya encontrado en internet que quiera usar para un proyecto final o para otra clase. Python puede ser una forma poderosa de usar una fuente de datos como entrada y producir su salida, ahora, a día de hoy, en SQL.

Pasemos a la iteración final del título.basics.tsv. Pero esta vez no solo lo guardaremos en un archivo CSV. Lo pondremos en una base de datos SQL adecuada en mi Mac o tu PC. Vamos a hacerlo. Primero, debo decir, como en la diapositiva, db = cs50.sql, y luego entre comillas, "sqlite:///--"; la tercera diagonal no es un error tipográfico. Debe estar ahí. Y voy a decir shows3.db, porque es la versión 3 de mi script import. Voy a hacerlo, como la semana pasada, e importar el CSV (la biblioteca de CS50) también.

Pero para que esto funcione, el archivo shows3.db debe existir primero. Y hay un par de formas, normalmente en una Mac, una PC o una computadora Linux, de crear un archivo vacío listo para recibir datos. Puedes usar literalmente el comando touch, que crea un archivo vacío con el nombre que escribas en el símbolo del sistema. O podemos hacerlo mediante programación. Y lo haré mediante programación, porque apuesto a que voy a cometer uno o más errores aquí, y será útil dejar que mi programa Python cree y vuelva a crear la base de datos una y otra vez hasta que lo haga bien.

Permítanme abrir un archivo llamado shows3.db en modo escritura. Y recuerden, desde Python y C, usando fopen, cada vez que abren un archivo en modo escritura, sobrescribirá cualquier archivo existente o creará cualquier archivo que no exista. Eso es todo lo que tenía que hacer. En Python 2, recuerden que podíamos usar esta notación de punto. Y resulta que aquí, cuando abres un archivo, si quieres cerrarlo inmediatamente porque tu único objetivo era crearlo, puedes hacer .close en lo que acabas de abrir. Eso es equivalente, para aclarar, a hacer algo un poco más pedante como esto: file = open y luego file.close. Pero podemos resumirlo en una sola línea elegante, por así decirlo, simplemente haciendo lo que hice hace un momento.

Todo lo que hace es crear un archivo shows3 vacío. Ahora, abre ese archivo para SQLite. Y de nuevo, SQLite es la versión ligera de SQL que cualquiera puede usar en su Mac o PC. No necesitas un servidor especial para empezar a ejecutarlo. Ahora, vamos a abrir title.basics.tsv. Y luego, aquí, voy a crear un DictReader para poder iterar sobre las líneas de ese archivo TSV.

Y ahora, vamos a continuar y, por cada fila en el lector, haremos lo siguiente. Primero quiero filtrar cosas como antes. Así que voy a decir if row["titleType"] == "tvSeries" y "isAdult" == "0", y luego voy a comprobar una cosa más. Voy a crear una variable year inicial, similar a antes, aunque antes la llamé year. Luego, vamos a hacer row["startYear"], solo para poder convertirlo en un int. Pero solo quiero hacerlo si row["startYear"] no es igual a esa barra invertida N especial que IMDB me dijo que debiera tener cuidado. Así que solo quiero hacerlo si no es eso.

Y luego, si startYear es mayor o igual a 1970, vamos a continuar y haremos lo siguiente. Vamos a hacer géneros, get row["genres"]. Vamos a continuar y obtener tconst, get row["tconst"], solo para poder ponerlos en algunos nombres de variable un poco más cortos, solo para mantenerme cuerdo. primaryTitle será de row["primaryTitle"]. Y luego, vamos a crear... ya tenemos startYear, así que esos son los otros tres campos que necesito.

Ahora, quiero continuar e insertar esta fila de mi TSV en una base de datos SQLite. Y la palabra operativa que vimos antes y que aún no hemos usado es INSERT. Usamos SELECT. Usamos UPDATE. Usamos DELETE. Todavía no hemos usado INSERT. Así que lo haré en un momento. Pero primero, necesito que mi base de datos exista realmente, así que necesito crear una tabla real.

Así que voy a subir aquí primero y hacer esto, db es una referencia ahora, una variable que representa mi base de datos, y voy a llamar a la única función dentro de ella que es útil para nuestros propósitos, que se llama execute. Lo que puedo hacer ahora es ejecutar cualquier SQL que quiera. Entonces, ¿qué quiero cargar en esta base de datos? Creo que quiero cargar el tconst, primaryTitle, startYear y géneros, como teníamos antes de title.basics.tsv. Quiero cargar filas que representen este tipo de datos, ¿vale?

Entonces, ¿cómo voy a hacer esto? Bueno, vamos a crear una tabla. La voy a llamar shows, porque parece agradable y conceptualmente consistente. Voy a seguir adelante y crear una lista de columnas ahora. tconst será una columna. primaryTitle será otra. startYear será otra. Y géneros será la última. Puedo literalmente, es decir, escribir SQL dentro de una cadena que paso a una función de Python llamada db.execute. Y como db.execute, o más bien, como db se configuró con shows3.db, cuando ejecuto esta cadena en Python, se ejecutará en ese archivo de base de datos, shows3.db. Es una buena forma de unir estos dos mundos.

Sin embargo, tendré que ser un poco más específico. Recordemos que SQL tiene muchos tipos. Y lo voy a simplificar. Voy a continuar y decir que el tipo de ese valor tconst es texto. El tipo de primaryTitle es texto. El tipo de startYear será numérico, una especie de comodín para fechas y horas. Y luego géneros también será texto. Así que la sintaxis es un poco rara. En realidad, especificas el nombre de la columna y luego el tipo, a diferencia de lo contrario, que hicimos en C. Pero así es SQL.

Así que voy a continuar y guardar eso ahora. Y solo para comentar esto, esto creará una tabla llamada shows en un archivo de base de datos llamado shows3.db, solo para ser súper explícito.

Entonces, ¿qué voy a hacer aquí abajo? Parece que tengo la posibilidad, con la biblioteca de CS50, de ejecutar cualquier SQL que quiera. Así que vamos a insertar en shows los siguientes valores: un tconst, un primaryTitle, un startYear y un género, y géneros. ¿Qué valores? Quiero insertar estos valores. Ahora, no lo sé de antemano, así que literalmente voy a poner algunos signos de interrogación aquí. Y resulta que en SQL, esta es una sintaxis válida para la biblioteca que estamos usando. Esta es esta consulta INSERT. INSERT INTO el nombre de la tabla una lista entre paréntesis de las columnas en las que quieres insertar datos. Luego, un conjunto de valores en paréntesis separados.

Y por ahora, estoy usando signos de interrogación como marcadores de posición, por razones a las que volveremos. Pero voy a continuar y conectar los siguientes valores en esos marcadores de posición, tconst, primaryTitle, startYear y géneros. Y lo que la función db.execute va a hacer por mí automáticamente es mirar esta consulta SQL. Observen que tiene cuatro signos de interrogación o marcadores de posición. Esos, en SQL, son como el %s en C o como las llaves y las cadenas f de Python.

Así que esto dice: dame 1, 2, 3, 4 marcadores de posición e inserta, en última instancia, los siguientes cuatro valores: tconst, que es solo una variable; primaryTitle, que es el mismo; startYear, que es el mismo; y géneros, que es el mismo. Entonces, ¿qué voy a hacer? Para cada serie de televisión en este archivo que no es una serie para adultos y que comenzó después de 1970, la inserto en mi base de datos. Si no he cometido ningún error tipográfico, voy a continuar, cruzar los dedos y Entrar.

Este va a llevar más tiempo, porque resulta que escribir en un archivo CSV es bastante rápido. Puedes simplemente escribir fila, escribir fila, escribir fila, escribir fila, pero insertar en una base de datos SQLite va a llevar