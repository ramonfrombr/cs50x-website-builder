Mais honnêtement, utiliser une invite en noir et blanc et une fenêtre de terminal n'a pas tendance à être amusant, en particulier lorsque les données défilent sur l'écran. C'est pourquoi il existe également des éléments appelés interfaces utilisateur graphiques, et effectivement, il existe un programme qui est disponible gratuitement pour les Macs, les PC et d'autres types de systèmes d'exploitation, appelé DB Browser. Et en effet, il vous orientera vers cette ressource en ligne. Il s'agit simplement d'un programme qui vous permet d'explorer les fichiers SQL sur votre propre Mac ou PC de manière beaucoup plus visible, ou bien plus visuelle et beaucoup plus agréable qu'une simple interface de ligne de commande ne le permet. Alors laissez-moi aller de l'avant et ouvrir par exemple shows.db. 

Et nous verrons un tas de choses. Tout d'abord, l'interface utilisateur graphique m'affiche les mêmes informations, juste dans un format un peu plus joli. Shows.db, selon mon schéma d'il y a un instant, comporte six tables, people, comme je l'ai mentionné ; shows, comme je l'ai mentionné ; également stars et writers, ratings, puis cette table séparée appelée genres. Et si vous regardez ici à droite, vous pouvez en fait voir le code SQL que nous avons écrit pour créer ces tables. 

Mais ce qui est plus sympa que cela, c'est d'observer ces onglets en haut ici ? Je suis actuellement sur la structure de la base de données, et si vous utilisez Windows, votre interface aura l'air un peu différente, mais les options sont toujours là. Je vais aller de l'avant et cliquer sur Parcourir les données. Et maintenant, vous verrez un petit menu déroulant de toutes les tables. Donc, si je veux aller de l'avant et regarder tout un tas de shows, je peux en fait voir toutes mes données ici, un peu comme dans Google Spreadsheets. Mais remarquez que ce sont 153 331 films, ou plutôt des shows, que je peux voir ici tous ensemble. 

Et enfin, ce qui est cool, c'est que si je passe à l'onglet SQL, je peux maintenant exécuter quelques exemples de requêtes. Alors laissez-moi y aller et faire cela. SELECT * FROM shows ;. Cela va me donner tout un tas de shows. Entrée. J'appuie donc sur le petit bouton Play qui exécute simplement cette requête, et vous voyez les lignes résultantes qui sont revenues. Alors encore une fois, comment sommes-nous arrivés à ce stade ? Nous, le personnel, avons téléchargé tous ces fichiers TSV à l'avance. Nous avons écrit un script Python qui a importé toutes les données de ces fichiers en mémoire, jeté ce qui ne nous intéressait pas, puis inséré ces données dans des tables comme cette table appelée shows. 

Et ce qui est bien avec cet outil, c'est que si vous aspirez à devenir un scientifique des données ou si vous essayez simplement d'effectuer un travail analytique pour ce cours ou tout autre, ou tout autre projet, un outil graphique se prête à juste un peu de fouille. Par exemple, vous verrez que la table des shows n'a plus de genres. Mais ce n'est pas grave. Nous pouvons reconstituer ces données. Je peux aller de l'avant et SELECT * FROM shows, mais vous savez ce que je peux faire ? Je peux en fait rejoindre la table des genres. Je peux donc prendre la table des shows ici, la table des genres ici, et les lier essentiellement ensemble par le biais de l'ID. 

Comment cela est-il possible ? Eh bien, si vous regardez les shows, un show a un titre ID, une année et des épisodes. Les genres ont un ID de show. Donc, si vous considérez l'ID sur ma main gauche comme représentant mes doigts ici. L'ID de show dans les genres représente ma main droite ici. Ce que nous voulons faire, c'est aligner l'ID avec l'ID de show pour constituer une table plus grande et plus large qui regroupe toutes ces données ensemble. 

Alors comment je fais ? Eh bien, en SQL, vous pouvez joindre deux tables. Vous indiquez avec quelle table vous souhaitez joindre l'autre table et comment vous souhaitez le faire. Eh bien, je veux aller de l'avant et le joindre sur shows.id = genres.show_id ;. Et maintenant, lorsque je clique sur Exécuter, c'est resté un moment ; en effet, il a fallu 408 millisecondes. Mais mon Dieu, c'est beaucoup plus rapide que d'écrire un script Python entier pour faire cela. J'ai maintenant une table avec tous les shows comme avant. Mais remarquez que la table s'est élargie. Il s'agit d'une table temporaire que SQL m'a renvoyée. Celle-ci possède maintenant un genre et un ID de show. 

En fait, laissez-moi y aller et filtrer cela. WHERE title = "The Office" AND year = 2005, Play, nous obtiendrons simplement ceci. Remarquez donc que j'ai une table plus large contenant toutes les colonnes des deux tables jointes. Mais si je change cela maintenant en The Crown, et que c'était en 2016, et que j'appuie sur Play, remarquez je récupère des informations apparemment redondantes. Mais cela peut néanmoins être utile, car je peux maintenant parcourir toutes les lignes sachant que chaque ligne a non seulement un titre et une année, mais aussi un genre. Je peux donc reconstituer la table comme ça. 

Eh bien, comment puis-je poser d'autres questions, comme quels sont les acteurs qui jouent également dans d'autres shows ? Eh bien, laissez-moi aller de l'avant et faire quelque chose comme ça. Par exemple, sélectionnons tous les films de Steve Carell. Ou bien, sélectionnons d'abord Steve Carell lui-même. Donc, sélectionnez * FROM, voyons voir ; non. Faisons ceci. Et Ellen ? Alors, sélectionnez * from people where name = Ellen DeGeneres. J'ai bien orthographié. Point-virgule, Play. 

Très bien. C'est pratique, car je sais maintenant qu'Ellen est née en 1958, mais que son identifiant est 1122. C'est la même chose que ce nconst, mais nous avons jeté le nm et nous nous sommes débarrassés de tous les zéros pour en faire un nombre correct pour plus d'efficacité, mieux pour identifier de manière unique les humains, en général, ou n'importe quoi, par des nombres qui tiennent en 32 ou 64 bits plutôt que des chaînes plus longues. Alors maintenant que je sais que l'identifiant d'Ellen est 1122, que puis-je faire ? 

Eh bien, laissez-moi aller de l'avant et SELECT * FROM stars WHERE person_id = this. Cela m'indiquera quoi ? Cela m'indiquera toutes les informations sur les shows dans lesquels Ellen a joué, y compris, vraisemblablement, le sien. OK, alors je vois maintenant que person_id est le même, le même, le même, mais Ellen joue apparemment dans tous ces shows. Mais ce n'est pas très utile, et c'est aussi un peu nul que je vienne de coder en dur l'ID d'Ellen. 

Mais je n'ai pas à faire ça. Je peux faire une sous-requête, SELECT id FROM people WHERE name = "Ellen DeGeneres", parenthèse fermée, Play. Maintenant, c'est dynamique, donc maintenant je n'ai rien codé en dur. Mais ce n'est pas si utile. Laissez-moi aller de l'avant et simplement sélectionner show_id ici. J'ai donc maintenant SELECT show_id FROM stars WHERE la personne id ID = quel que soit l'ID d'Ellen ici. 

Comment puis-je aller un peu plus loin ? Eh bien, que se passe-t-il si je fais SELECT * FROM shows WHERE l'ID du show est dans la liste de valeurs suivante ? Non seulement SQL prend en charge les égalités, lorsque vous souhaitez comparer une valeur par rapport à la suivante, un peu comme dans Python, vous avez le mot-clé IN, où vous pouvez dire sélectionnez tout des shows où l'ID du show est dans la liste suivante de shows, ce qui se trouve représenter la liste des ID de show dans lesquels Ellen figure. Ouf. 

Lançons Play sur cela. Cela a pris un moment, mais il semble que ce soit tous les shows dans lesquels Ellen a joué, selon IMDB. Et il semble que The Ellen DeGeneres Show en fasse partie. Elle a été à l'antenne pour 2 865 épisodes. Il y a Ellen, son émission de télévision originale, qui durait quelques saisons à l'époque. On dirait qu'elle fait quelques jeux télévisés ces derniers temps, à partir de 2017, et ainsi de suite. Donc, en utilisant ces processus de pensée étape par étape, pouvons-nous en fait construire des requêtes plus intéressantes pour récupérer des informations comme ça. 

Très bien, des questions avant d'en essayer quelques autres également ? Non ? Très bien. Eh bien, laissez-moi vous montrer une autre approche de ce même problème. Il s'avère qu'il s'agit de ce que l'on appelle des requêtes imbriquées. Vous continuez à utiliser la parenthés