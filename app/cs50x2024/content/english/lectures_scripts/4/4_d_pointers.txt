All right. So let's just go ahead now and make more clear where we can store information here. Let me go ahead and change this code. now as follows. It turns out that you can actually store addresses and variables themselves. I don't have to just do this ampersand thing here. 

Let me go ahead and change the program as follows. Let me go ahead and declare another variable called p and store in it's the address of n. So again, nothing new here, just says, ampersand n, go get the address of n. But I do have to do something different here. On the left hand side is the name of my variable. I've called it p, for pointer. But if you want to store the address of some value in a variable you have to specify not just the type of value that's in that other variable, you have to specify with this star operator in a very confusing, unfortunate, different context, that this is a pointer. 

So whereas n has a data type of int-- just as it has since Week 0 --the only thing new now is that it turns out there's another type of data that you can describe as a pointer. And a pointer is denoted with this star and the int just means this is the pointer to an int or it is the address of an int. And we'll see later we can do floats and-- floats, and chars, and bunches of other data types too. This just means that p is a variable that's going to contain a pointer to an int, a.k.a. The address of an int. 

All right. So what can I do now with this information? Well let me go ahead and print out either of these. If I want to go ahead and print out now, for instance, that address, I can go ahead and print % p and print out p just like this. Let me go ahead and make address, enter-- seems to compile OK --run address. And I'm going to see something cryptic again, 0x 7FFF3977662C, which is different from before but that's because one of the features of modern computers is actually to move things around in memory for you, which is a security feature. But more on that perhaps, later on. But it's still a big cryptic hexadecimal address. 

What if though, just for the sake of demonstration, I didn't want to print out the address because rarely after today are we going to care about the specific addresses where things are? How could I change line 7 here to print out, not the value of p, but what is at the location p? How do I go to the location in p? 

OK. Star p, I heard. So instead of printing p itself, I say star p. I change the format code just to be an int. 

OK. Siri is trying to be helpful here. 

But now I'm saying, go ahead and print me an integer. And the integer I want you to print is the one at p. Star means go to that address, which is p. So let me save this, make address. All right, seems to compile. Dot slash address, let's see what happens. And back to 50. 

So we're just kind of jumping through hoops at the moment, accomplishing nothing real yet. But again, just demonstrating, and applying, and reversing the effects of these two operators. 

Any questions thus far on these addresses, or pointers, or the like? Yeah. 

AUDIENCE: So there's six lines where you stored the address of n-- 

DAVID J. MALAN: Mm hmm. 

AUDIENCE: --pointer of p. 

DAVID J. MALAN: You stored the address of n in p and p is a pointer, specifically a pointer to an integer. Put another way, p is the address of an integer. Which integer? n 

AUDIENCE: Could I just write-- what would happen if I just write int p instead of int star p? 

DAVID J. MALAN: Good question. If you said int p equals ampersand n semicolon, instead of int star p, Clang-- the compiler --would actually yell at you because it realizes that, wait a minute, you're trying to store an address, not an integer like you and I know it, 12345678. Even though technically they are numbers, Clang is smart enough to realize that if you're getting the address of something, you must store it in a pointer. You cannot store it in just an integer.