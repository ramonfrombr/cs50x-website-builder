So let me go ahead and do that. Let me create another version, cough1.c. And I'm going to copy/paste this code, just as a starting point. But now I'm going to go ahead and clean it up. So I'm going to go ahead and instead do a for loop. And I don't quite remember what goes in the parentheses yet, but we'll come back to that. I do know that what I want to do some number of times is just cough. So the only question at hand is, what was the syntax here? Well, we can write this in any number of ways, and we could even use a while loop. But I do recall saying int and then the name of a variable. I could say counter, or I could just say i to keep it succinct, equals 0 by default. I could do this so long as i is less than 3, for instance. And then on each iteration, I can say i equals i plus 1 or, more succinctly, i plus plus. So, again, it's a lot of new syntax. And there's semicolons all over the place now. But if I go ahead now and do make cough1, nothing bad seems to have happened. ./cough1, cough, cough, cough. It seems to be slightly better designed. Unfortunately, there is this paradigm in programming where humans, programmers, tend to think or tend to count starting from zero. However, if you don't like that, at least early on, there's nothing stopping me from initializing i to 1 and then doing i is less than 4 or, even more explicitly, i is less than or equal to 3. There's no less than or equal sign on your keyboard, typically, so you can mimic it by doing a less than and then an equal sign, two characters. This is logically the same. Set i equal to 1. Then go ahead and print cough, and then make sure to increment it. And then make sure it's still less than 3, and 2 is. Make sure it's still less than or equal to 3, and it still is. So that 2 is, logically, going to have the same effect. However, in the interests of convention, this would be the more common approach. Do this while i equals 0 and then 1 and then 2, for a total of 3 times. All right, but recall what we did last time, too, is that if I'm writing a lot of code, for some reason, that involves programs coughing, it would be nice to give myself my own custom function. So let me go ahead and do that. Let me go ahead and write my own first brand-new function. And I'm going to do this as follows. I'm going to go ahead and type void, then the name of the function I want. Then I'm going to say void here, for reasons we'll come back to. And then I'm going to literally just go ahead and say cough. So there are functions we've used today-- printf, get_int, get_string, get_float-- none of which we showed you the implementation of, because people, years ago, both in the staff and in the real world, implemented those functions for us. You, too, can implement your own custom functions or, in Scratch, those puzzle pieces that we made in those pink blocks. So if you want to make your own function whose name is cough, whose purpose in life is to say cough on the screen, this is the syntax. For today's purposes, you say void and void here, but the name of the function is important. I'll call it cough. And then I can use it as follows. I can say cough, cough, cough now in order to cough three times. Or again, we already decided that was bad design. For int i get 0, i less than 3, i plus plus. I can now do something like cough. And so now, again, out of sight, out of mind. I don't need to know or care how the cough function is implemented. I can care that my code just tells the computer what to do. For i from 0 on up to 3, cough, cough, cough. And this is an abstraction. I don't care that cough is implemented with printf. I just care that there's a function called cough. So let me go ahead and run this and see what happens. Let me scroll down to the bottom, do make cough1. OK, amazing. No red errors now. So ./cough1, cough, cough, cough. But notice that this is a little bad design, I would claim, because you know what? If you keep writing custom functions up here, up here, up here, the main part of your program is going to get pushed pretty far down. And it's a human convention to generally have the main function at the top of your file. Seems pretty reasonable. So you open the file, boom, the main function's right there. So let's keep it there. So let me actually move the cough function down below just so that, again, the first thing I see is indeed the main part of my program. And wherever cough is, I don't care. That was the whole point of implementing it. Let me go now to my terminal window and do make cough1. Oh my god, some red errors flew by. What's wrong here? So error, implicit declaration of function cough is invalid in C '99. C '99 means the version of C invented in 1999. What's going on? Implicit declaration? So this is where C differs from Scratch again. C is old, and it's kind of dumb. It only knows what you tell it, and it only knows what you tell it in order top to bottom, left to right. So in this program right now, I have included stdio.h, as before. I've included the beginning of main. I've started a for loop. And then I'm using a function that's apparently called cough. However, where is cough now actually implemented? Way down here on line 11 onwards. C is not that smart. It's not going to presume to look later in your file to see, maybe they put the function cough down below. It's only going to do what you tell it. So there's a fix for this. You can either do what I did initially, which is put all of your custom functions up top. But that's kind of a vicious cycle, because you can't forever put the new functions up top. Eventually, you're going to run into some kind of constraints. And my god, you want the main function, by convention, to be up top. So there's another solution here. And this is the only time where copy/paste is compelling. You literally copy the first line of your function's code on line 11 there. And you go ahead and paste it at the top of your file with a semicolon. So this is a way of sort of tricking C into, oh, you have seen cough before. You haven't seen all of it, but you've seen enough of it-- you've seen its name-- to now tolerate its appearance in my main function. So let me go ahead and recompile this code. I'm going to go ahead and run make cough1 enter. OK, now it compiled. ./cough1, and viola, we're back in business there.