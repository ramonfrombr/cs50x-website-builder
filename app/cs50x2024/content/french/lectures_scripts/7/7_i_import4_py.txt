Alors, comment peut-on s'y prendre ? Eh bien, permettez-moi d'aller plus loin et de faire ce qui suit à la place. Permettez-moi d'aller de l'avant et d'ouvrir une version finale de mon script d'importation, celui qui fait deux choses en premier. En haut, je vais créer deux tables, l'une s'appelant émissions, qui a des codes... Je dois aussi nettoyer les noms de colonnes. La BDFI n'est pas très conventionnelle. Ce que la plupart des gens feraient pour décrire un identifiant unique, ils l'appelleraient ID, pas tconst. Nous allons donc le renommer ID. Ils n'appelleraient pas leur titre titre principal. Ils vont l'appeler titre, donc nous allons le renommer titre. Ils ne vont pas le nommer startYear. Nous allons l'appeler année. Et c'est tout. Nous reviendrons à la clé primaire dans un instant.

Mais remarquez ceci. Dans ma nouvelle et dernière version de ce script, je crée, je propose, une deuxième table appelée genres dont le but dans la vie est de contenir une valeur appelée show_id et une autre appelée genre. Mais alors, que se passe-t-il ? Eh bien, permettez-moi d'aller de l'avant et de vous le montrer. Si je charge la base de données résultante à partir de celle-ci, shows4.db, et que je fais .schema, vous verrez que j'ai en effet deux tables. Permettez-moi d'aller de l'avant et de SÉLECTIONNER * DANS les émissions OÙ titre, cette fois, parce que je l'ai renommé en titre principal, = The Office. D'accord. C'est beaucoup de bureaux. Mais allons-y, ET année = 2005, qui est celle à laquelle nous pensons tous. Et c'est celle-là.

Et maintenant, remarquez ceci. Notez que je reçois quoi ? Un identifiant, je reçois un titre et je reçois une année, mais pas de genres. C'est parce qu'il y a maintenant une autre table appelée genres qui est séparée. Et vous savez, je suis un peu curieux. Je vois qu'une table de genre a show_id. Permettez-moi de faire ceci. SÉLECTIONNEZ * DANS les genres OÙ show_id =, et laissez-moi faire un petit copier-coller ici, = cet show_id. Et que pourrais-je voir ? Comédie.

Alors qu'avons-nous fait maintenant ? Pour toute émission de télévision qui figurait dans la base de données de la BDFI qui était une liste de genres séparés par des virgules, je l'ai explosée, pour ainsi dire. J'ai divisé cette valeur par les virgules. Et si l'émission est une comédie, j'ai ajouté une ligne dans ces genres de table, mais ensuite j'ai inscrit l'ID de l'émission à côté de ce genre pour me souvenir que cette émission était de ce genre. Mais si une autre émission a plusieurs champs, par exemple, allons de l'avant et cherchons non pas The Office mais, disons, The Crown. Et il n'y en a qu'un seul. Et maintenant je fais SÉLECTIONNER * DANS les genres OÙ show_id = ce nombre, nous verrons que, oh, The Crown a maintenant le drame et l'histoire comme genre. Et donc, dans la table des genres, notez qu'il y a deux identifiants et deux genres. Mais maintenant, nous pouvons utiliser une qualité. Je peux maintenant rechercher toutes les comédies de 2019 d'une manière assez puissante, SÉLECTIONNEZ * DANS les émissions OÙ id DANS-- et voici la partie intéressante-- SÉLECTIONNEZ show_id DANS les genres OÙ genre = "Comédie" ET année = 2019.

Alors, c'est certes une bouchée, mais considérons ce qui se passe. D'abord, je sélectionne des étoiles parmi les émissions. Cela signifie que donnez-moi toutes les émissions dans toutes les colonnes. Mais filtrez comme suit, ne me montrez que les émissions dont l'ID est dans la liste d'ID suivante. Maintenant, vous pouvez regarder une requête imbriquée entre parenthèses ici. Cette liste ici sélectionne tous les ID d'émission de la table des genres où genre = "Comédie". Ainsi, la parenthèse mise en évidence renvoie essentiellement une liste de tous les numéros d'identification des émissions associées à la comédie, même si elles sont également associées à d'autres choses. Et nous veillons à ce que l'année soit égale à 2019.

Donc si je clique maintenant sur Entrée, nous verrons un tas de résultats, mais nous devrions voir, si je les compte en utilisant ma syntaxe habituelle, qu'il y avait 1 593 émissions qui étaient des comédies en 2019. Cela se trouve à égaler le même compte que nous avons fait plus tôt en utilisant "comme", mais c'est mieux conçu dans le sens où il n'y a pas d'ambiguïté. Vous ne recherchez pas simplement une sous-chaîne, pour ainsi dire, dans une liste séparée par des virgules. Vous pouvez désormais effectuer une recherche plus fiable en ayant repensé vos données.

Et ce que nous avons fait est vraiment quelque chose comme ça. Au lieu de stocker nos données dans une seule table appelée émissions, et que chaque émission ait un identifiant, un titre, une année et des genres, nous avons plutôt explosé ces genres en deux tables distinctes, de sorte que notre table d'émissions ressemble maintenant à ceci. Nous avons un identifiant, un titre et une année. Et notez que l'identifiant d'une émission peut également apparaître ici dans une autre table appelée genres, et juste par convention, pour nous garder sain d'esprit, au lieu de l'appeler ID ici, nous l'avons appelé show_id pour indiquer qu'il vient d'une table appelée émissions, au pluriel, mais c'est un seul identifiant d'une émission. Donc, par convention, les humains les appellent souvent nom de table, moins le S, underscore ID. Et puis le mot-clé ici ou genre est la comédie ou le drame ou le documentaire ou un autre genre.

Et maintenant, c'est un peu subtil, mais le fait que ce petit symbole ici, tiré du monde de la base de données, s'étende en trois endroits distincts, c'est une relation un-à-plusieurs, pour ainsi dire. Vous pouvez avoir une émission ici mappée à plusieurs genres ici, ou peut-être zéro, mais c'est zéro ou plus de genres possibles.

Très bien. Des questions pour le moment ?

Très bien. Alors le vrai pouvoir vient donc clairement de ce genre d'expressivité. Alors maintenant, jouons avec d'autres requêtes et fonctionnalités. Mais d'abord, donnons-nous un peu plus de données. Il s'avère qu'outre le fichier intitulé title.basics.tsv, IMDB.com en met également un tas d'autres à notre disposition. Il y en a un qui s'appelle name.basics.tsv. Et c'est celui qui contient des informations sur tous les noms d'acteurs et d'actrices, de réalisateurs, d'écrivains et d'autres personnes dans le monde. Ainsi, par exemple, il existe un nconst, qui est comme une constante de nom ou un identifiant, nm2946516, qui appartient à l'acteur dont le nom principal est Claire Foy, la star de The Crown. Elle est née en 1984, et il y a aussi d'autres champs dans ce fichier.

Mais ce fichier, title.principals.tsv, est également intéressant, et c'est là que ça devient intéressant aussi. Dans ce fichier, notez qu'il n'y a pas de titres réels. Il n'y a pas de titres principaux. Il n'y a pas de noms humains réels. Au lieu de cela, il n'y a que deux identifiants uniques, un tconst et un nconst, que la BDFI appelle un identifiant de titre et un identifiant de nom. Ainsi, par exemple, dans l'une des lignes de ce fichier TSV appelé title.principals.tsv, il y a une ligne qui commence par tt4786824 ; a également nm2946516, et a le mot actrice, impliquant ainsi que si vous recherchez le nm-- le nconst dans le fichier des noms et que vous recherchez le tconst dans le fichier des titres, vous pourrez, par transitivité, déduire que Claire Foy est dans The Crown.

Cela nous permet d'avoir une relation plusieurs-à-plusieurs. Un seul film ou une seule émission peut avoir plusieurs acteurs, et un acteur peut être dans plusieurs émissions, nous utilisons donc une sorte de fichier de jointure ici, une table de jointure, qui va en quelque sorte nous permettre de lier deux ensembles de données différents, et plus à ce sujet dans un instant. Mais ce qui est vraiment amusant dans la BDFI, c'est qu'elle contient également un tas de notes que les humains ont tapées en disant, j'obtiens ceci 10 sur 10, un 0 sur 10, et ainsi de suite. Et ils gardent une trace du nombre de votes que les émissions ont obtenus. Et ainsi, dans