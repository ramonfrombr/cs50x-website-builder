So that's all focusing on correctness and style, and that's indeed what every problem set here on out is going to have as one component. Does it work correctly and is it well styled? But the third axis of quality, when it comes to writing software, not just for CS50 but really in general with programming in the real world, is this notion of design. And design isn't quite something that we can assess yet with software, and say you designed that well or you did not design that well, it's more of a subjective measure. And here, too, reasonable people can disagree. 

So what we'll focus on, not only today, but in the weeks to come, is also the process of writing well-designed software and making more intelligent decisions to not just get the problem solved, but to get it solved well. And this is what full-time software engineers at the Facebooks and Googles and Microsofts and others of the world do every day, especially when they have huge amounts of data and many, many users. Every design decision they make matters and might cost money or CPU cycles or memory. And indeed, think back to week zero, finding Mike Smith was possible in three different ways, but that third way, the divide and conquer, was hands down the most efficient. That was better designed than the first couple. 