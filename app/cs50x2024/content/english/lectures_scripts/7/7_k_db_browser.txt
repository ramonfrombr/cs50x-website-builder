But honestly, using a black and white prompt and a terminal window tends not to get fun, especially when the data flies over the screen. So there are also things called GUIs, Graphical User Interfaces, and indeed, there is a program that's freely available for Macs, PCs, and other types of operating systems, called DB Browser. And indeed, will point you at this online. This is just a program that allows you to explore SQL files on your own Mac or PC much more visibly-- or much more visually and much more pleasantly than maybe just a command line interface allows. So let me go ahead and open up, for instance, shows.db. 

And we'll see a whole bunch of things. First of all, the graphical user interface here shows me the same information, just in slightly prettier format. Shows.db, per my diagram a moment ago, has six tables, people, like I mentioned; shows, like I mentioned; also, stars and writers, ratings, and then that separate table called genres. And if you look over here on the right, you can actually see the SQL code we wrote to create those tables. 

But cooler than that is that notice these tabs up top here? I am currently on Database Structure, and if you're using Windows, your interface will look a little different, but the options are still there. I'm going to go ahead and click on Browse Data. And now you'll see a little dropdown of all of the tables. So if I want to go ahead and look at a whole bunch of shows, I can actually see all of my data here, not unlike Google Spreadsheets. But notice, this is 153,331 movies-- or shows, rather, that I can see altogether here. 

And lastly, what's cool is that if I go over to the SQL tab, I can now execute some sample queries. So let me go ahead and do this. SELECT * FROM shows;. This is going to give me a whole lot of shows. Enter. So I hit the little Play button that just executes that query, and you see the resulting rows that have come back. So again, how did we get to this point? We, the staff, downloaded all of those TSV files in advance. We wrote a Python script that imported all of the data from those files into memory, threw away the stuff we didn't care about, and then inserted it into tables like this table called shows. 

And what's nice about this tool is, because if you are an aspiring data scientist or you're just trying to get some analytical work done for this class or any other, or any other project, a graphical tool lends itself to just kind of poking around. So for instance, you'll see that the shows table no longer has any genres. But that's OK. We can reconstitute that data. I can go ahead and SELECT * FROM shows-- but you know what I can do? I can actually join in the genres table. So I can take the shows table here, the genres table here, and essentially link them together by way of the ID. 

How is that possible? Well, if you look at shows, a show has an ID title, year, and episodes. Genres has a show ID. So if you think of ID on my left hand as representing my fingers here. Show ID in genres is representing my right hand here. What we want to do is lineup ID with show ID to make one larger, wider table that constitutes all of that data together. 

So how do I do this? Well, in SQL, you can join two tables. You say what table you want to join with what other table and how you want to do it. Well, I want to go ahead and join it on shows.id = genres.show_id;. And now, when I hit execute, it took a moment-- indeed, it took 408 milliseconds. But my god, that's a lot faster than writing a whole Python script to do this. Now I have a table with all of the shows as before. But notice the table got wider. This is a temporary table that SQL has returned to me. This one now has genre and show ID. 

So in fact, let me go ahead and filter this. WHERE title = "The Office" AND year = 2005, Play, we'll just get this. So notice I have a wider table containing all of the columns from both of those joined tables. But if I change this now to The Crown, and that was 2016, and hit play, notice I get back seemingly redundant information. But this might be useful nonetheless, because now I can iterate over all of the rows knowing that every row has not only a title and a year, but also a genre as well. So I can reconstitute the table like that. 

Well, how can I ask other questions as well, like what are actors that are in other shows as well? Well, let me go ahead and do something like this. For instance, let's select all of Steve Carell's movies. Or-- let's select Steve Carell himself first. So SELECT * FROM-- let's see-- no. Let's do this. How about Ellen? So SELECT * from people where name = Ellen DeGeneres. I spelled that right. Semicolon, Play. 

All right. So this is handy, because I now know that Ellen's birth year is 1958, but her ID is 1122. That's the same thing as that nconst, but we threw away the nm and we got rid of all the zeros and made it into a proper number for efficiency, better to uniquely identify humans, typically-- or anything-- by numbers which fit in 32 or 64 bits rather than longer strings. So now I know Ellen's ID is 1122, what can I do? 

Well, let me go ahead and SELECT * FROM stars WHERE person_id = this. This will tell me what? This will tell me all of the information about shows that Ellen starred in, including, presumably, her own. OK, so I now see person_id is the same, the same, the same, but Ellen is apparently in all of those shows. But that's not that helpful, and also, this is kind of lame that I've just hardcoded Ellen's ID. 

But I don't have to do that. I can do a subquery, SELECT id FROM people WHERE name = "Ellen DeGeneres", closed parenthesis, Play. Now it's dynamic, so now I've not hardcoded anything. But this isn't that useful. Let me go ahead and just select show_id here. So I now have SELECT show_id FROM stars WHERE the person_id ID = whatever Ellen's ID is here. 

How can I take this one step further? Well, what if I do SELECT * FROM shows WHERE the ID of the show is in the following list of values? So not only does SQL support equals, when you want to compare one value against the next, much like in Python, you have the keyword IN, where you can say select everything from shows where the ID of the show is in the following list of shows, which happens to represent the list of show IDs that Ellen is in. Phew. 

Lets hit Play on this. It took a moment, but it looks like these are all of the shows that Ellen has been in, according to IMDB. And it looks like The Ellen DeGeneres Show is one. She's been on the air for 2,865 episodes. There is Ellen, her original TV show, which was on for a few seasons back then. Looks like she's doing some game shows these days as of 2017, and so forth. So using these step-by-step thought processes can we actually build up more interesting queries to get back information like that. 

All right, any questions before we try a few others out as well? No? All right. Well, let me show one other approach to this same problem. It turns out this is what are known as nested queries. You keep using the parenthesization, much like in math, where you can nest arithmetic expressions in parentheses. You can do the same in SQL. But you can also join information in slightly different ways as well. I can actually do something like this. 

Let me go ahead and SELECT Title FROM the following tables, people JOIN stars ON people.id = stars.person_id-- and we'll walk through this in just a second-- JOIN-- sorry-- JOIN shows ON stars.show_id = shows.id where name equals "Ellen DeGeneres." This, while more of a mouthful, is equivalent to what I've just done. Notice that I've select the title of the show from the following, the result of joining people on stars. How do you join the people's table and the stars table? Well, people have IDs. Stars have person IDs, according to the diagram. What else do you want to join together? Let's join all of that with shows. How? Well, let's go ahead and say stars.show_id = shows.id. So it's a way of linking, transitively, multiple tables together, and then filter all of that with the name of Ellen DeGeneres. This is what we would call an explicit join. 

And if I click Play there, notice it's taking a moment. Took, in fact, 1,990 milliseconds, almost two human seconds. So it got slower, but it does give me another syntax via which to select data. And honestly, what's cool about this is I can select other fields as well. They don't have to come from the original query in my nested selects. 

But let me go ahead and do this, just as a teaser, and then we'll consider some problems before wrapping up. So it turns out 2 millisecond-- 2 seconds is kind of slow, and if I do this again, it took 2,029 milliseconds. If I do it again, it took 1,963 milliseconds, and I'm looking at the time here. That's slow, right? That means if you have a finite number of servers in the world and each of them can only handle some number of users at a time, it's kind of a waste of hardware and of money, arguably, to spend more seconds or milliseconds servicing one query from a given user on your app or your web application. 

But it turns out we can do something kind of smart here. Notice that in our database structure, we've done a few things here. Let me open up, for instance, people. Rather, let me go over to people, and you'll see a few keywords that I ignored earlier. When you're defining a table, you can specify that one of your columns is what's called a primary key. That is the column by which you're going to uniquely identify all your data, so it's like those numeric IDs we've given every person and show. A foreign key is what we call the same number when it appears in some other table. So when we saw a person_id or show_id, those are what are called foreign keys, because it's the same numbers, but in another table that we're using to join things together, eventually. And you can also define columns to be unique, or you can index them for efficiency. And that's, in fact, where we're going right now. 

If you look at the same query, you'll notice that I'm searching on a bunch of columns. I'm clearly searching on the name field. I'm also searching on-- that is, joining on-- show_id, and I'm searching on person_id, not to mention the individual ID fields. But the cool thing about a primary key, which we have in advance to find all of our ID columns, all of the columns called ID, to be primary keys, you get a feature for free with SQL. SQL builds up what's called an index, a very fancy data structure, a tree-like structure, that actually allows you to search for information quite efficiently. 

So when you define a column to be a primary key, you get what's called an index. Specifically, if we go back a few weeks, to tree, our discussion of trees, it looks like this. This is what's called the B-tree, which is not a binary tree. It's a B-tree in the sense that it's got a lot of nodes that might be one or two or more children each, but it's very short with a lot of nodes, very-- a lot of width. So that means when you store your data in a tree-like structure, long story short, it just tends to be very efficiently searchable. So when you define a column to be a primary key, you get that speed for free. 

But we can also tell our SQL database, you know what? I plan on searching on person IDs and show IDs and names, also, so let's go ahead and create myself some indexes. Let me go ahead and execute the following queries just once. Let me create something called an index called person_index on the stars table using its person_id column. So pretty quick syntax. This means create a B-tree, create a fancy tree structure, called person index, on the stars table by person-- on the person_id column. That is, make a table like this in memory to store all of the person IDs. Why? So I can find them faster than linear search in the column itself. 

Let me go ahead and execute this. And you'll see it takes a moment. It's thinking. It took me 1.6 seconds. So a little slow, but I only have to do this once. Let me create two more. CREATE INDEX called show_index ON stars ON the show_id column. So almost the same, but this just means give me a tree that looks like this in memory, so that when I query for data like Ellen DeGeneres, it searches a tree-like structure instead of a list-like structure in a column alone. 

Let me execute that. And I screwed up ON stars show_ID. There we go. That took 1 second. And lastly, let's create an index called name index on people on the name column so that I can search for people by name more efficiently as well. Otherwise, without these indexes on a column like name, it is going to check every damn cell in the column looking for Ellen DeGeneres, Ellen DeGeneres, Ellen DeGeneres, using big O of N, running time, or linear search. 

So now, let me go back to my query here. I've not made any changes to the query. The last time I ran this, it took almost 2 seconds. Now, after creating these indexes and telling my SQL database I plan to search on those columns, watch this, and watch the blue highlighted number. 8 milliseconds. 8 millisecond. 7 milliseconds. 7, 7, 7. Looks like 4 milliseconds that time. So this is what the Googles of the world, the Facebooks of the world, the Microsofts, who have very large data, they not only store their data in databases like we are here, but they also index their tables intelligently, drawing in ideas from weeks ago, so that the database, for them, and for free, and sort of magically, creates these kinds of structures in memory, but does it so that you can search and insert and update your data all the more efficiently. 