Well let's consider another example now, this time involving three score, so three integers, instead of something like three characters. What might I actually do with values like this? Well, let me go ahead and write some code, this time in a file called scores dot c. I'm going to go ahead and clean up my terminal here and create a new file called scores dot c. And let's go ahead and do a few similar lines here. Let me go ahead and include say, CS50 dot h, include standard Io dot h, int main void, and now go ahead and start declaring some variables. 

Give me int score one. And I'm going to declare my score on some assignment to be 72, another score on an assignment to be about the same, 73, and another regrettable assignment to be, say, 33. So now I have three variables called integers, and suppose I just want to do something like print the average. I can certainly do this with printf and some math. So I might go ahead and say the average is % i, where that's going to be a placeholder, then a new line. And then the average, of course, is going to be something like score one, plus score two, plus score three, divided by three total, and then semicolon. So again, that's just the average. Add three numbers together, divide by the total number, and voila, we should get an average. 

Let me go ahead and save the file, compile this with make scores, Enter. Seems to compile OK-- dot slash scores. And I should get an average of 59 for those three quiz scores, or assignment scores, in this context. But this isn't the best design now. Now that we're dealing with numbers and scores, especially in the context of like a class where maybe you're going to have four scores or five scores or more scores, ultimately, week to week. What rubs you perhaps the wrong way about this design so far? 

AUDIENCE: [INAUDIBLE] 

DAVID MALAN: Say again. 

AUDIENCE: I 

DAVID MALAN: Yeah, it's very fixed. This is like writing a program at the beginning of the semester and deciding in advance there's only going to be three assignments, and if you want to have a fourth, too bad. The software does not support it. So that's not the best design. And what else might you critique about this code, simple as it is. Yeah? 

AUDIENCE: [INAUDIBLE] 

DAVID MALAN: Yeah, I'm potentially cheating students out of a partial score, especially if their average was like 59.5. I would like to be rounded up to 60, for instance. So we're also having some imprecision issues. And we'll come back to that as well. Any other critiques? Yeah? 

AUDIENCE: [INAUDIBLE] 

DAVID MALAN: Yeah, even though I typed it out manually, this is dangerously close to just copying and pasting the same code again and again and again. So just with the hi example, as with this one, as with our cough example last week and the week before, just doing this thing again and again and again is really an opportunity for a better design. So it turns out, there is that opportunity. And in C, if you know that you want to have more than just one value, but they're all kind of related, what might be a nice name for a variable containing multiple scores? 

AUDIENCE: [INAUDIBLE] 

DAVID MALAN: Scores plural in English. So how can we do that? Well unfortunately, if I just say int scores, I need to decide which score it gets as a value. Now those of you who have prior programming experience, might know where we're going with this, and we're about to get there. It turns out in C, if you want to have one variable that can store multiple values, you use what's called an array. An array is a list of values that can be all the same type in a variable of the same name. So if you want three scores, each of which is an int in C, you literally use square brackets, the number of scores you want, and then a semicolon. That will say to the computer, give me enough memory for three integers. 

Down here now, I get to change my syntax. I don't want score one, score two, score three. I want to put these scores inside of the array by simply saying its name, using square brackets, albeit a little differently this time, and put them at locations one, two, three, but that's actually my first mistake. Computer scientists typically start counting at one-- no-- computer scientists typically start counting at zero, so I need to zero index my array. Arrays are zero indexed, which just means the first location is zero, the second is one, the third is two. So this now, is equivalent code to giving me three variables, but now I've gotten rid of the messiness that you identified by copying and pasting the name again and again, and I can store them all together. 

AUDIENCE: On the scores, the number three stands for three variables, right? It doesn't stand for four? 

DAVID MALAN: Does the three stand for three variables? It stands for enough space for three values in one variable. Good question. Others, questions? Yeah? 

AUDIENCE: [INAUDIBLE] bringing equals and then [INAUDIBLE] 

DAVID MALAN: Really good question. Can you do this all in one line? Yes, but let me just tease you by saying something like this involving curly braces, but we won't go there today. But yes, there are ways to get around this. So let me go ahead and fix this now. If I want to compute the average now, I need to add these three values in this array, score zero, scores one, and scores two. But arithmetically, the answer-- the code is still the same, so if I now make scores and do dot slash scores, my average is still 59. And I do disclaim, there's still probably a mathematical bug because if we're using integers, as was noted, but we'll come back to that in just a little bit. 

So let's push a little harder. Even if you've never programmed before, what might still be a little bad about the design. The program works, but we can do it better. 

AUDIENCE: Still only stores three. 

DAVID MALAN: Still only stores three. So we haven't even solved the very first problem. Other critiques? 

AUDIENCE: [INAUDIBLE] 

DAVID MALAN: I have too much code in the last line. Yeah, it's getting a little wordy, so it's going to be a little harder to read-- quite fair. Yeah? 

AUDIENCE: I 

DAVID MALAN: Sorry, say it a little louder. 

AUDIENCE: The scores are hardcoded into the program. 

DAVID MALAN: Yeah, the scores are hardcoded into the program, which means it doesn't matter what you get on your assignments, we're all getting 59's. So that's another problem as well. And any other critiques? Yeah? 

AUDIENCE: If it could read the input data, it might be better. 

DAVID MALAN: If it could read input data-- yeah, so let me combine those suggestions. It'd be great if, eventually, this program is dynamic. And anything else? Yeah? 

AUDIENCE: [INAUDIBLE] 

DAVID MALAN: Definitely. We can pull loop into the situation and actually get multiple values from the user. 

AUDIENCE: Always dividing by three, so [INAUDIBLE] 

DAVID MALAN: Yeah, it's also always dividing by three. And this is subtle, and it's not a huge problem yet, but there is this principle I'm kind of violating here known as don't repeat yourself. And I have repeated myself in at least two locations. What values appear in two locations? So three up here, and then also three down here. And minor though this detail seems, this is the source of so many common bugs because if you just kind of decide by yourself, well, I'm going to hard code three up here, I'm going to hard code three down here, odds are, tomorrow morning, next week, next month, next year, let alone a colleague of yours, is never going to notice the subtlety that this three just by social contract has to be the same as this three. 

That is not a code constraint. That's just sort of a little thing you knew and decided at the time. So let me fix this in the following way. It turns out that in C we can have variables that just have numbers like this, so maybe int n gets three. I can now just use my variable here and here. That's a little better. It's a little better. But there's this other feature in C, as with other languages too, where if you know you want to hard code some value, at least for now, but you don't want it to change, you will not change it and you want to make sure you don't accidentally change it, you can actually do something like this and even make it global if we want, at the top of the file, I can say not just int n, but const int n, and just because of human convention, I'm also going to now capitalize the variable, just because. 

And now I'm going to change this n to capital, this n to capital. The reason being, I have just created for myself what's called a constant. A constant is exactly what the word implies, even though you just say const, and then the type of the variable, the compiler, clang, we'll make sure that neither you nor some friend or colleague accidentally change the value of n. So now you can use n here, here, and any number of other places. It will always be the same. And what I'm using at the moment is what's called a global variable, which are often frowned upon, even though you can put variables outside of your functions, as we may eventually see, it tends to be sloppy, except with constants. 

When a constant is a value that you want to set and then forget about, if you come back to this program weeks or months later, and you're like oh, this semester we have four assignments, or five, it's just handy to put the values you might want to change before recompiling your code at the very top so you have to go fishing for visually lower in your code. So just a convention. It goes at the top of the file, quite often, and you declare it as const, and you capitalize it, and then you can use that value, n, throughout the code. 

But now let's tie together those other suggestions and make this program even better, such that it's not just hard coding this one value, n, everywhere. Let me go ahead and get rid of this. Let me go ahead now and take your suggestion that we do this dynamically, and we can use arrays for this too. If I know in advance that I want to ask the user for how many assignments there are this semester, well I can do something like this. Int n gets get int, and I'll say number of scores, and then prompt them for their input. And then what I'm going to do after that is give myself an array called scores of size n as step two. 

And then what I might do is something like this. For int i get zero, i less than n, i plus plus, which even though I'm typing it fast, is exactly the same paradigm we've used before, for, for loops. And here, I could do something like scores bracket i gets get int score semicolon, prompting the user again and again and again for a loop for the IFE score, so to speak. And because I start counting at zero, and on up to, but not through n, I will end up filling this with exactly as many scores as the human requested. 

Let's go ahead now and leave this as a to do for a moment. Let me just because the math's about the change-- let me go ahead and delete that and we'll just not do the average yet just so I can compile this first. I'm going to go ahead and make scores again-- seems to compile. Dot slash scores, number of scores-- let's do three, so 72, 73, 33, Enter, and my average is still to do. So we'll come back to that. But you know what? It would be nice to make this a little prettier. Why don't I tell the human what score I want from them, so I can say, give me score number such and such, i. So let me just use get int, like this. 

Now let me go ahead and make scores, dot slash scores. Give me three scores again. Score zero, 72, 73, 33. Now this is kind of stupid, right? At least for normal people who might use my program, what is score zero? What is score one? We can fix this for normal people, and just do that. We're not changing where we're putting the value, but we can certainly change the aesthetics of what we're doing. So let's remake scores. Dot slash scores, and now it's more human friendly-- 72, 73, 33. 

So one piece remains. How do I now compute the average in a way that's dynamic and I'm not hard coding score one, score two, score three again, or even the array version? And you know what? This is a nice opportunity to maybe come up with a helper function that also solves the int issue from before. So let me go ahead and say, you know what? The average could perhaps have a fraction. So what data type do I want to use if my average might have a fraction? So a double or float. So we'll go with either. I'll keep it simple because the scores are going to be crazy big or precise. 

I'm going to create a function called average. And if I want to average all of the numbers that the human has typed in, turns out I need to know two things. I need to know the length of the array that they've been accumulating and I need to have the array itself, so I'm going to denote it with these square brackets here. I don't have to know, at this point, how big it is. The compiler will figure that out for me. But I can now declare a function like this. Well how do you go about averaging some number of values, if you're handed them in a list, otherwise known as an array, but I'm telling you the length of that list, what's this sort of intuition for taking an average here? Yeah? 

AUDIENCE: You could take the sum and then divide it by [INAUDIBLE] number. 

DAVID MALAN: Yeah. Yeah, the average of a bunch of numbers is just add all the numbers together and then divide by the total number of numbers. And I have all of those ingredients. I have the length of the array, apparently, and I have the array of numbers itself, as follows. So let me go ahead and say something like sum is zero, because I'm just going to start counting from zero, and then I'm going to do for int i get zero, i less than length, i plus plus. So again, I typed it fast, but it's identical to my for loop from before. I'm just using the length as the condition. And now what do I want to do here? On each iteration, what do I want to add to the sum? Sum equals sum plus what? 

AUDIENCE: [INAUDIBLE] 

DAVID MALAN: The next item in the array. And I can express that, it turns out, just like before the name of the array, which happens to be literally array, just for convenience. And then how do I get the appropriate value from it? Bracket i, because i is going to start in this loop at zero, going to go up to, but not through its length. So this is just a way of getting bracket zero, bracket one, bracket two, and just adding it to sum on each iteration. Now this is unnecessarily wordy. Recall, that this is shorthand notation for that. I can't just use plus, plus here though, because I want to add the actual scores not just one. So I can use either this syntax or the more verbose syntax, but I'll go with this one. 

And now at the end of this function, notice I have to make a decision. And we haven't seen terribly many functions of our own, but if this is what my function looks like, its name is average, it takes two inputs, one of which is an int called length, the other of which is an array of integers, and I know it's an array not by its name, which I could have called anything, but I know it because of these new square brackets today. However, what does this mention of float mean on the left-hand side of line 18? 

AUDIENCE: [INAUDIBLE] 

DAVID MALAN: That's what it returns. The return value of a function is what it hands back to whoever is using it. So get string, returns a string. Get int, returns an int. Average I want to return a float. And so how do I return this value? Well, let me go ahead and return the sum divided by the length, as I think you proposed? Now there's actually one bug here, but we'll come back to that in a moment. Now let me just go ahead and plug in the average. What's the format code for a floating point value? Percent f, yeah. And then if I want to plug in the average, I can call my function called average. 

And what two inputs do I need to give it? n, which is the length of the array, and scores, which is the name of the array. So again, even though arrays are new, this is not. We have last week called functions that take one or more arguments and it's certainly fine to nest them. However, if you don't like that, you can certainly do something like this-- float average gets that, and then you can plug in average. But again, in the spirit of good design, you're just doubling the number of lines unnecessarily. 

So I'm going to go ahead and nest it just like this. All right, let me save that. And I feel really good about this so far. I feel like everything's making sense. So make scores. And oh, my god. Line 15 seems to be at fault. So we can certainly use help 50, but let's see if we can't reason through. What mistake have I made? It's highlighted here, even though it's very non obvious. Yeah? 

AUDIENCE: [INAUDIBLE] 

DAVID MALAN: Exactly. My function is at the bottom of my file and C is kind of dumb. It only does what it's told, top to bottom, left to right. And if your function averages at the bottom, but you're trying to use it in main, that's too late. So we can fix this in a couple of ways, just as we did last week. I can kind of sloppily just say, all right, well let's just move it to the top. That will solve that problem. But frankly, that moves main farther down and it's a good human convention to keep main at the top so you can see the main part of your program. 

This is why, last week, we introduced the notion of a prototype, where you literally-- and this is the only time where the copy-paste is OK-- you copy-paste the first line of your function and end it with a semicolon without any more currently braces. That's now a clue to solve that problem. Hey clang, here's a function. I'm not going to get around to implementing it yet, but you at least know what it's called. Now there's still a slight logical bug in here. Let me try re-saving and recompiling scores. It compiled this time-- nice. 

Let me go ahead and run scores. Number of scores will be three, 72, 73, 33. OK, that's pretty good. Let me try another one. How about two scores. 100 and suppose you get a 99 on the other, you probably want your grade to be what? 100, right. If it's 99.5, you'd prefer we round up. So where is that bug? Well let me scroll down here, and this is what you were alluding to earlier when you identified this early on. So I'm doing a couple of things incorrectly here. 

One, I'm adding the sum here. I'm using an int and initializing sum to zero, and then I'm dividing an integer by an integer. And this is subtle, but in C, if you divide an integer by an integer, just take a guess-- what do you get as the answer? 

AUDIENCE: An integer. 

DAVID MALAN: An integer. Integers can't store decimal points. So even if your score is 99.900000 ad nauseum, what's going to get thrown away is literally everything after the decimal point. So your grade is actually a 99. So there's a couple of ways we can fix this, but perhaps the simplest is this. I can use that casting feature from before. I can tell the computer, don't treat length as an int, actually treated as a float, and you know, just for good measure, also treat sum as a float. And there's different ways to do this, but now, I'm telling the computer divide a float by a float, which will allow me to return a float, and let's see what happens now. 

Let me save that. Make scores. It compiled. Dot slash scores. Number of scores is two. 100 is the first. 99 is the second. Nice, now I've gotten the grade I deserved. Heck, we could even bring in the round function if we want, which you might have used for p-set one, but we'll leave it as this. But I am going to go ahead and just do a 0.1 there. Recall that with format codes you can really start to get precise and say only show me one digit. So if I recompile this now, make scores, and do dot slash scores-- two scores-- 100, 99. There's my 99.5% Any questions then on these arrays and the use there of? Yeah? 

AUDIENCE: [INAUDIBLE] the average [INAUDIBLE] income scores by [INAUDIBLE] 

DAVID MALAN: Explain the average-- this part here? 

AUDIENCE: Yeah. 

DAVID MALAN: Sure, can I explain this? So, let me just show more of the code. The last line of this program's purpose in life is just to print the average of all of my scores. And I decided, partly for design purposes, but also today to illustrate a point, to relegate the computation of an average to a custom function. This is handy, because now if I ever work on another problem that needs to average, I've got a function I can use in that code too. But in this case, average takes two arguments, apparently the length of the array and the array itself, but I could call these two things anything I want-- x and y, length and array, anything else, but I chose this for clarity. 

But up here, I want to use that function. So just like in Scratch, recall that you can nest blocks and you can join something and then say it. So can we call the average function, passing in the length of the array and the array itself, that gives me back my average 99.5, and then I'm plugging that in to this format code in printf. So just like in math, when you have lots of parentheses, work from the inside out. Look at the innermost parentheses, figure out what that is, then work your way outward. And if you've programmed in Java, or Python, or other languages, you might be wondering why we need to tell the function the length of an array. 

In C, the arrays do not remember their own length. So if you have programmed before, this is necessary. You do not get that feature for free in C. Yeah? 

AUDIENCE: [INAUDIBLE] 

DAVID MALAN: Correct, if you do percent 0.1 you get one decimal point, so 99.5%. 

AUDIENCE: Suppose that the answer was 99.49 [INAUDIBLE] 

DAVID MALAN: Really good question. If the answer is mathematically 99.49, but you do 0.1 here, it will round up for you. It will-- good question as well. Yeah? 

AUDIENCE: What happens [INAUDIBLE]? 

DAVID MALAN: Really good question. What happens if you divide an int by a float or something else? You will typically up cast it to whatever the more powerful type is. So if you divide an int by a float, you will actually get back a float. So strictly speaking, I did not need to cast both the numerator and the denominator to a float. I just did it for consistency and demonstration's sake. 

So it turns out, while we've been looking at numbers here alone and scores, it turns out that there's actually an intricate relationship with all of the h's and the i's and the exhalation points we've been looking at, and all of the strings we've been typing in too, however this was a mouthful, and frankly I feel like a brownie as well, so why don't we take our five minute break here and we'll come back. 

We are back. So thus far, we've introduced arrays as an opportunity to improve the design of our code. So we're going to hear a lot of squeaking now, I think. So thus far, we've introduced arrays as the-- we're going to do my best to keep a straight face. Thus far, we have introduced arrays as a solution to a design problem so that we can actually store multiple values, but in the guise of one variable so as to avoid the copy-paste tendency that we might otherwise have. And those arrays ultimately started from trying to clean this kind of code up. 

But what is it that was ultimately going on inside of the computer's memory we can still consider, because it's actually not all that different. However, when we have three integers, score one, score two, score three, how many bytes is each of those-- it's going to take up? So four, if you think back to the chat from before, char is one, an int is four, at least on most systems, and so the number 72 in the variable called score one, we can draw on our computers memory is taking up four of these boxes. Because again, each box represents one byte, therefore four bytes requires four boxes. 

Score two and score three would similarly be laid out in my computer's memory. If I had three variables, score one, two, and three, as follows, like this. Of course what's underneath the hood is actually bits, but again, we don't need to worry about that level of abstraction anymore. But that's indeed all that's going on there. But we can clean this up. We can instead get rid of this copy-paste approach to variable names and just introduce an array called scores, plural, and then initialize those three values, as in the program I wrote here. 

And then, this picture is similar in spirit, but the names of these boxes, so to speak, become score zero, scores one, and scores two. So the array is now independent of the number of bytes being consumed. Just because an int is four bytes, doesn't mean you do score zero, scores four, scores eight, and so forth. It's still zero, one, two. The computer will figure out exactly how much space to give each of those values based on its type, which is an int. 

But it turns out that there's actually a relationship now to where we began this story when we looked at characters. H-I exclamation point was implemented with three lines of code using c1, c2, and c3. But last week, we already saw the notion of a string, and it turns out strings and chars are fundamentally interrelated in ways that we can now literally see. If we had a string called s, for instance, and that string contains three characters, H-I and an exclamation point, well it turns out you can actually get at the individual letters in a string by doing the name of the string, bracket, zero, close bracket, or s bracket one, or s bracket two. 

If the name of my variable is s, and s is a string, I can actually access the individual characters there in just like an array, which is to say then, what is a string as of this week versus last? It's just an array of chars. It's just an array of characters. So even though it's a data type, thanks to CS50's library and CS50 dot h, and we're going to take this training wheel off within a few weeks, we've essentially just created a string to be for now, at this point in the story, just an array of characters. Why? Because being able to have multiple characters is certainly way more useful than having to spell things out one variable at a time with one char at a time. 