Well, let me try something else. Let me go ahead and copy/paste the beginnings of this code, just to speed things up. So I can implement a program called parity.c. So parity is a fancy way of saying is a value even or odd. And I've gone ahead and just copied and pasted the setup of the code, not the essence of my main function. But let's go ahead, in this program, and ask the user for a number. We'll call it n. And we'll use get_int to get that value. And we're just going to say to the human, what's the value of n? And I'm just going to say n colon space to just prompt them for some integer. Then I'm going to go ahead and ask a question. I want to ultimately print out even if the number is even or odd if the number is odd. So you could imagine doing this the very tedious way, like if n equals equals 1, I could go ahead and print out odd. And then else if n equals equals 2, I could print out even. And then after that, I could support the number three, else if n-- I mean, this is stupid, right? I could do this forever. But it's at least showing a pattern, right? One and then three and then five, of course, are going to be odd, and two and four and six are going to be even, and so forth. Well, it turns out we can compute this mathematically. And a very common trick might be this-- we can actually do this. If n divided by 2 has a remainder of, for instance, 0, then I'm going to go ahead and conclude that the number is even. So this percent sign is a new construction. It's not plus. It's not minus. It's not multiplication or division. This is the remainder operation, or the modulo operation, so to speak. And this just means divide n by 2, and if the answer has a remainder of 0, you can conclude, by definition of even, that the number is even. So I'm going to print that. Else-- I could do else if n percent 2 equals equals 1 and has a remainder of 1, you could imagine saying odd. But as you noted earlier, this is not necessary. What could I instead do to make the program a little better designed, a little more efficient? Yeah? AUDIENCE: You could just use else and that would be fine. DAVID MALAN: Yeah. So if we're talking about integers, I can just conclude, well, if it's not even, it must be odd, by definition. And so here, we can just do even and odd. So this program, once run, is going to look like this. Make parity. Looks like it compiled OK. So ./parity is how I run it. Let's type the number 50. That's even. Let's type the number 49. That's odd. Proof by example. This is not very compelling, but I bet this is going to be correct, just based on those two examples alone. Yeah? AUDIENCE: [INAUDIBLE] user did not understand our comment that answer's a float or not an integer? DAVID MALAN: Sorry, say that again? AUDIENCE: What if the user doesn't understand, I'm saying? Like I just do something like 1 and 1/2 [INAUDIBLE].. DAVID MALAN: Really good question. One of the reasons we provide for the first few weeks of the class a few functions in the CS50 library like get_string and get_int and get_float is that it forces the user to behave as you expect so that your program doesn't crash because of unexpected user input. So to your point, suppose the user is being a little difficult and says, my number is going to be 1.5. Get_int is going to prompt them for the same question again and again and again until they cooperate. If you type in apple, it's going to prompt you again. Only once you provide an actual integer will it cooperate. So those are among the features you get from the CS50 library, just so that we can focus on ideas and not on what we would call error checking, or malicious users, in this case.