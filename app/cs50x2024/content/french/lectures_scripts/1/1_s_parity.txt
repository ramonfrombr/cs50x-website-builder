Bien, laissons-moi essayer autre chose. Permettons-moi de copier/coller le début de ce code, juste pour accélérer les choses. Je peux donc implémenter un programme appelé parity.c. Donc parité est une façon sophistiquée de dire si une valeur est paire ou impaire. Et je suis allé de l'avant, j'ai juste copié et collé la configuration du code, pas l'essence de ma fonction principale. Mais continuons, dans ce programme, et demandons un nombre à l'utilisateur. Nous l'appellerons n. Et nous utiliserons get_int pour obtenir cette valeur. Et nous allons simplement dire à l'utilisateur, quelle est la valeur de n ? Et je vais juste dire n deux points espace pour juste l'inviter à saisir un entier. Ensuite je vais continuer et poser une question. Je veux au final imprimer pair si le nombre est pair ou impair si le nombre est impair. Donc vous pouvez imaginer faire cela de manière très fastidieuse, comme si n est égal à 1, je pourrais aller de l'avant et imprimer impair. Et ensuite sinon si n est égal à 2, je pourrais imprimer pair. Et ensuite après ça, je pourrais prendre en charge le nombre trois, sinon si n-- je veux dire, c'est stupide, pas vrai ? Je pourrais faire cela indéfiniment. Mais au moins ça montre un modèle, pas vrai ? Un puis trois puis cinq, bien sûr, vont être impairs, et deux et quatre et six vont être pairs, et ainsi de suite. Eh bien, il s'avère que nous pouvons calculer cela mathématiquement. Et une astuce très courante pourrait être celle-ci-- nous pouvons en fait faire cela. Si n divisé par 2 a un reste de, par exemple, 0, alors je vais aller de l'avant et conclure que le nombre est pair. Donc ce signe de pourcentage est une nouvelle construction. Ce n'est pas plus. Ce n'est pas moins. Ce n'est pas la multiplication ou la division. C'est l'opération reste, ou l'opération modulo, pour ainsi dire. Et cela veut juste dire divisez n par 2, et si la réponse a un reste de 0, vous pouvez conclure, par définition de pair, que le nombre est pair. Donc je vais imprimer cela. Sinon-- je pourrais faire sinon si n modulo 2 est égal à 1 et a un reste de 1, vous pourriez imaginer dire impair. Mais comme vous l'avez remarqué plus tôt, ce n'est pas nécessaire. Que pourrais-je faire à la place pour rendre le programme un peu mieux conçu, un peu plus efficace ? Oui ? AUDIENCE : Vous pourriez juste utiliser else et ce serait bien. DAVID MALAN : Oui. Donc si nous parlons d'entiers, je peux juste conclure, eh bien, si ce n'est pas pair, ce doit être impair, par définition. Et donc ici, nous pouvons juste faire pair et impair. Donc ce programme, une fois exécuté, ressemblera à ceci. Faire une parité. On dirait qu'il a compilé correctement. Donc ./parity est comment je l'exécute. Saisissons le nombre 50. C'est pair. Saisissons le nombre 49. C'est impair. Preuve par exemple. Ceci n'est pas très convaincant, mais je parie que cela va être correct, juste basé sur ces deux exemples seuls. Oui ? AUDIENCE : [INAUDIBLE] l'utilisateur n'a pas compris notre réponse est un flottant ou non un entier ? DAVID MALAN : Désolé, pouvez-vous répéter ? AUDIENCE : Et si l'utilisateur ne comprend pas, je dis ? Comme si je faisais simplement quelque chose comme 1 et 1/2 [INAUDIBLE].. DAVID MALAN : Vraiment bonne question. L'une des raisons pour lesquelles nous fournissons durant les premières semaines de cours quelques fonctions dans la bibliothèque CS50 comme get_string et get_int et get_float c'est que cela force l'utilisateur à se comporter comme vous l'espérez de façon à ce que votre programme ne plante pas à cause d'une saisie utilisateur inattendue. Donc à votre demande, supposons que l'utilisateur soit un peu difficile et dise, mon nombre va être 1,5. Get_int va lui reposer la même question encore et encore et encore jusqu'à ce qu'il coopère. Si vous saisissez pomme, il va vous demander à nouveau. Ce n'est qu'une fois que vous aurez fourni un entier réel qu'il coopérera. Donc cela fait partie des caractéristiques que vous obtenez de la bibliothèque CS50, juste pour que nous puissions nous concentrer sur les idées et non sur ce que nous appellerions vérification d'erreur, ou utilisateurs malveillants, dans ce cas.