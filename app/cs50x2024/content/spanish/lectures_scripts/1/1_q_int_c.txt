Así que regresamos y ahora empezamos a enfocarnos, no solo en comparaciones de C con Scratch, sino en escribir realmente algún código de Scratch en C. Y el objetivo que tenemos a la mano es realmente comenzar a desarrollar la memoria muscular a través de la cual puedes empezar, literalmente, con archivos vacíos y comenzar a llenarlos con implementaciones de C de tus ideas. Así que ten la seguridad de que todos los ejemplos que estamos a punto de hacer en vivo ya están precocidos en línea, así que podrás descargar todos estos ejemplos desde el sitio web del curso. En la súper sección de Brian podrás explorarlos con más detalle. Y más adelante durante esta semana tendrás oportunidades prácticas para trabajar también en estos mismos tipos de programas. Por ahora, el objetivo general es la exposición y los conceptos y el comienzo del desarrollo de esa memoria muscular. Entonces, una vez dicho esto, permítanme crear un nuevo archivo llamado int.c, cuyo propósito será obtener un entero del usuario, muy parecido a un bit que obtuve una cadena del usuario. Voy a seguir adelante y, como antes, voy a incluir algunos archivos familiares. Así que voy a seguir adelante e incluiré preventivamente CS50.h para tener acceso a cadenas y get_string y get_int y get_float y otras características también. Voy a incluir stdio.h para tener acceso a printf, así que de hecho puedo ver lo que estamos haciendo. Luego voy a hacer esto, que de nuevo, para los propósitos de hoy y para un par de semanas, es simplemente copiar/pegar. Este es el equivalente de cuando se hace clic en la bandera verde, pero explicaremos, en un par de semanas, exactamente por qué estás escribiendo int y por qué estás escribiendo void. Aquí, voy a hacer algo como esto. Esta vez, quiero obtener no una cadena sino un int. Así que hagamos en age get get_int, ¿cuál es tu edad? Ahora, para ser justos, probablemente pueda escribir eso bastante rápido, porque ya tengo la memoria muscular para programar en C. Pero si lo miramos realmente metódicamente por un momento, esta es solo otra función, get_int, de la biblioteca CS50 que va a obtener un entero. Este es el aviso que el humano verá con el cursor moviéndose a una nueva línea debido a la barra invertida n. Y todo lo que escriban se copiará de derecha a izquierda en una variable llamada age, cuyo tipo, por así decirlo, es int, o entero. Ahora déjame seguir adelante y calcular, por ejemplo, cuántos días tiene esta persona. Entonces, si quiero hacer eso, podría hacer algo como esto. Bueno, dame un entero. Llámalo days. Y luego solo haz age times 365. Propuse hace un momento que hay un montón de operadores aritméticos como más y menos y multiplicación y sustracción e incluso el operador de resto. Entonces, esta línea, 7, simplemente dice multiplicar age por 365. Copia ese valor, de derecha a izquierda, en una nueva variable llamada days. Y ahora puedo seguir adelante e imprimir esto si quiero. Entonces, printf algo como, tienes al menos porcentaje-- no s, porque no es una cadena, pero el porcentaje i porque ahora es un entero-- días de edad, barra invertida n. Pero de nuevo, esto es un marcador de posición, así que todavía no he terminado. ¿Qué necesito poner dentro de estos paréntesis también en la línea 8? Sí, coma, días, si ese es el valor que quiero conectar. Y me falta una cosa más. AUDIENCIA: Punto y coma. DAVID MALAN: Punto y coma al final de la línea. Ahora, con suerte, acerté. Pero lo más probable es que la primera vez que escribas tus programas, veas mensajes de error. Pero veamos, hacer int es la forma más rápida ahora de compilar este código. Ingresar. Muy bien, el gran y largo comando blanco está bien. Siempre que no veas rojo o amarillo o salida de color que indique advertencias o errores, deberías estar bien. Voy a borrar mi pantalla ahora para poder ejecutar este programa ahora, ./int. Y supongamos que su edad es, digamos, 50. Bueno, tienes al menos 18,250 días de edad. Pero permítanme usar esto como una oportunidad para no solo hacer algo correcto, lo cual afirmo que es este código, sino para simplemente mejorarlo. Está bien almacenar este valor, age, en una variable llamada age. Y está bien crear una segunda variable llamada days, en la que mi respuesta matemática es age times 365. Pero estrictamente hablando, no necesito esa línea de código adicional. También podría hacer age times 365 aquí. Así que C es bueno en eso. Puedes componer, como en Scratch, ideas más grandes a partir de varias piezas más pequeñas. Y francamente, si realmente quiero volverme loco, fíjate que realmente puedo resaltar toda esa función llamativa, por así decirlo, deshacerme del age por completo y simplemente conectar esto aquí times 365. Pero en este punto, estamos empezando a cruzar un punto de inflexión. Sí, esto es correcto, porque yo, estrictamente hablando, no necesito una variable, ¿verdad? Puedo pasar-- vimos la semana pasada-- la salida de una función como entrada de otra función simplemente anidándolas de esta manera. Pero honestamente, ahora estamos en el punto en el que esta línea de código es tan relativamente larga que es demasiado difícil de leer. Así que este es un ejemplo en el que, por el bien del diseño, ¿sabes qué? La versión anterior probablemente era un poco mejor, porque puedo leer el código más de arriba a abajo que de izquierda a derecha. Pero esta es una decisión de diseño. Y de hecho, puedes estar de acuerdo o en desacuerdo. Es posible que estés de acuerdo o en desacuerdo con tu compañero de enseñanza o TF, en última instancia. Estos son los tipos de decisiones que intervienen en la escritura de código bueno o malo o de código bueno o mejor. Al igual que en un ensayo en inglés o en cualquier idioma escrito, se podría argumentar que una persona ha escrito su documento mejor que otra. Así que comenzaremos a apreciar estos matices con el tiempo.