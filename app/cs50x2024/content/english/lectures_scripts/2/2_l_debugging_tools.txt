So let's go ahead and do this after introducing one other command that exists in the IDE, and that's called debug 50. Suffice it to say, that any command this semester that ends in 50 is a training wheel of sorts that's CS50 specific. But by term's end, well we have essentially taken away all of those CS50 specific tools so that everything you're using is industry standard, so to speak. So if we look now at CS50 IDE, let's go ahead and maybe run that same program. 

So if I click this folder icon up here, you'll see a whole bunch of files, just like in the sandbox. And I've pre downloaded all of today's source code from CS50's website and just uploaded it to the IDE, just like you can in the sandbox. And we'll do this in section or in super section, manually, if you'd like. I'm going to go ahead and open up that same program buggy two, that's now in the IDE instead of the sandbox, and you'll see it looks pretty much the same. 

The color coding might be a little different, but that's just an aesthetic detail. And I can still run this. Make buggy two down here. But notice here, this error, I could use help 50 on this, but notice in advance, I've downloaded all of my code into a folder called source two. That's what's in the zip file, on the course's website. So again, just like we did briefly last week, if you know your code is not just in the default location, but is in another directory, what does cd stand for? 

AUDIENCE: Change directory. 

DAVID MALAN: OK. So change directory-- so not that hard. It changes directory. And now notice what the sandbox does. It's a little more powerful, even though it's a little more cryptic. It always puts a constant reminder of where you are in the folders in your IDE, whereas the sandbox hid this detail altogether. So again, we're removing a training wheel by just reminding you, you are in source two and the tilde is just a computer convention, meaning that is your home directory, that is your personal folder with your CS50 files, demarcated with just a tilde. 

So now I'm going to go ahead and do make buggy two. It does compile, because again, this is not a syntax error. This is a logical problem. I'm to go ahead now and dot slash buggy two. And if I count these up, I've still got 11 hashes on the screen. So I could go in and add printf, but that's not really taking advantage of any new tools. But watch what I can instead do. Let me scroll this down just a little bit so I can see all of my code. 

Let me go ahead and click to the left of the line numbers in the IDE, like in main, and it puts a red dot, like a stop sign that says stop here. This is what's called a breakpoint. This is a feature of a lot of integrated development environments, like CS50 IDE that's telling the computer in advance, when I run this program, don't just run it like usual, stop there, and allow me, the human, to step through my code, step by step by step. 

So to do this, you do not just run buggy two again. You instead run debug 50. So just like help 50 helps you understand error messages, debug 50 lets you walk through your program step by step by step. So let me go ahead and hit Enter. You'll notice now on the right-hand side a new window that the sandbox did not have opened up. And there's a lot going on there, but we'll soon see the pieces that matter. That is the debugger. 

And you'll see that this line here, line seven, is highlighted, because that's the first real piece of code inside of main that's potentially going to get executed. Nothing really happens with the curly braces. Seven is the first real line of code. So what this yellow or greenish bar means is that the debugger has paused your program at that moment in time, has not run all the way through, so we can start to poke around. And in fact, if I zoom in on the right, let's focus today pretty much on variables, you'll notice a nice little visual clue that you have a variable called i. 

At the moment, its value is zero. What is its type? Integer. So watch what happens now when I take advantage of some of the icons that are slightly higher up. I'm just going to scroll up on the debugger, and most of this we'll ignore for today, but there's some icons here. So if I were to hit Play, that will just resume my program and run it all the way to the end-- not very useful if my goal was to step through it. But if you hover over these other icons instead, step over, this will step over one line of code at a time, and execute it one by one by one, so literally allowing you to walk through your own code. 

And so let's try this. When I go ahead and click Step Over, notice that the color moves. Watch my terminal window now, the big blue window at the bottom. I'm going to see hash. Now notice that line seven is highlighted again, because just with a for loop, something's going to happen again and again. So what should we see happen though when I click step over once more? 

AUDIENCE: [INAUDIBLE] 

DAVID MALAN: i should become one. So it's a little small, but watch the right-hand side of the screen where it says variable i, and I click Step Over-- voila, now we see one. And if I continue doing this, not much of interest really happens. I've just really slowed down the same program. But you'll notice that i is incrementing again and again and again. But what's interesting here is I didn't have to go in and change my code by adding a bunch of messy printf statements that I'm going to have to delete later just to submit my code or ship it on the internet. Instead, I can kind of watch what's going on inside of my computer's memory while I'm executing this program. 

And the fact now that the value of i is 10, and yet I'm about to print another hash, therein lies the same logical error. So we're seeing just graphically the same problem as before. So now at this point, the program is pretty much done. If I keep clicking Step Over, it's just going to terminate. If at this point, I'm like, oh my god, now I know it's wrong, you can exit out of most any program in the IDE or in sandbox by hitting Control c, for cancel, and that will kill the debugger, close the window, and get you back to your terminal window. 

And I can't emphasize this enough, moving forward even this week, use help 50 when you have a bug compiling your code, some error message that you don't understand. It will just help you like a member of the staff could. And then certainly reach out to us if you don't understand that. But debug 50 should, moving forward, be your first instinct. If you have a bug where something's not working, the amount of change your computing is wrong, the credit card numbers you're analyzing are wrong, use debug 50, starting this week, not two weeks from now, to develop that muscle memory of using a debugger. And it is truly a lifelong skill, not just for C, but for other languages as well. 

Any questions on that? You'll see more of it in section and beyond. So what else do we have in the way of tools in our toolkit here? Let's go ahead and introduce one other now. That one you've probably used this past week called check 50. This is a tool that allows you to analyze the correctness of your code. And you might recall with check 50, you did a little something like this. If I went ahead and whipped up a program, like my typical hello dot c-- so I've gone ahead and clicked Save, saving this file as hello dot c. Let me go ahead and include standard Io dot h, int main void. Let me go ahead now and printf. Hello comma world backslash n semicolon. 

And I know from the problem sets, that the way to check the correctness of this code with CS50-- check 50 and then a slug, a unique identifier. I'm using a shorter one just for lecture today called CS50 problems hello. That is just the unique set of tests that I want to run on my code called hello dot c. So what's happening here is I'm being prompted to authenticate. GitHub is what this uses, as you've seen. I'm going to go ahead and use my student account. I'm going to go ahead and log in. 

You'll notice a star represents your password, so it kind of sort of masks it, even though everyone in the world now knows how long my password is. And now we're preparing, we're uploading the submission, and in just a few seconds, we'll get some feedback from CS50's server that tells us, hopefully, that my code is perfectly correct-- perfectly correct. But no, it's not in this case. And if you recall from problem set one, you weren't supposed to just print hello world. You were supposed to print hello so and so, whatever the human's name is. 

So you'll see two green smileys here saying hello dot c exists. So I got that one right. I named the file correctly. Step two, it compiled, so there were no error messages when we ran make on your code. But we did get unhappy twice. We expected when passing in the name Emma, for you to say hello Emma. And when we expected to pass in Rodrigo, we expected hello Rodrigo, so you did not pass these two tests. 

So check 50 happens to be CS50 specific, that the TF's and I use to grade and provide automated feedback on code, but it's representative of what in the real world are just quite simply called tests. Whenever you work for a company or write software, part of that process is typically not just to write the code that solves your problem, but to write tests that make sure that your own code is correct, especially so that if you add features to your programs down the road or someone else tries to add features to your code, they and you don't break it-- you're constantly have a capability to make sure your code is still working as expected. 

So while we do use it in academic context to score problems sets, it's fundamentally representative of a real-world process of testing one's own code repeatedly. And then lastly, there's this thing-- style 50. So it's not uncommon when learning how to program, especially in a language like C, to be a little sloppy when it comes to writing your code. Technically speaking, this same program here, I could just make it look like this. And frankly, if I really wanted to, I can make it look like this, and the computer's not going to care. It's smart enough to be able to distinguish the various curly braces from parentheses and semicolons. 

But my god, this is not very pleasant to look at. Or if it is right now, break that mindset. This is not very pleasant to look at. You should be writing code that's easier for you to read, for other people to read, and honestly, easier for you to maintain. There is nothing worse than writing really bad code, coming back to it weeks or months later to fix something, add something, and you don't even know what you're looking at because it's your own code. So style 50 is a tool that just helps you develop muscle memory for writing prettier code. Style has nothing to do with your coach correctness. It's more of the nit picky aesthetics that just makes it pleasant to look at. 

And reasonable people will disagree as to what constitutes pretty code. With style 50, we, like a company, have standardized on what we would propose your C code looks like, so that we can have an objective measure of how clean it is. So if I go ahead and run, after saving my file, style 50 on hello dot c, Enter, you'll see some output like this. You'll see your same code in black and white at the bottom, but you'll see green text telling you where you should add space. So you should literally hit the spacebar four times and that will make style 50 happy. 

By contrast, if I instead do something like this, let me go ahead and correct it incorrectly. There are people in the world that write code that looks like this. This is frowned upon. But if I go ahead and run style 50 now on this file-- Enter-- you'll see the opposite. And it gets a little scarier with this syntax, because we're doing our best to explain what it is we want you to do. But we want you to delete the new line, the Enter key that you hit here, and we want you to pull it up to the top here, and we want you to delete that read here. 

So admittedly, it's sometimes hard for the computer to give you very straightforward advice as to what's going on. So you'll see over time, certain patterns. So in fact, if I go to CS50's own website here, let me go ahead and pull up what's called a style guide. And this is the authoritative answer when it comes to what your code should look like in a class or in a company. You'll see throughout this style guide that's online a lot of examples of what good code, pretty code, readable code should look like. And there, too, reasonable people will disagree, but it's part of the programming process to have good style for your code, as well in style 50 allows you to develop that muscle memory, as well. 

And one aside, whereas the sandbox tool used to auto save your file, the IDE does not do that. So notice I just hit Enter a couple of times in this file, or suppose I said something like Goodbye World more explicitly, and suppose I now move my cursor to the terminal window, you'll see a big red alert saying, hey did not save your file. That's because the IDE is meant to be a little more powerful and a little more of the onus now is on you to actually know OK, red dot up there means I should save. So file, Save, or you can hit Control s or Command s. So just realize that is now unto you. 

And lastly, a summary of what all these tools really figure into. Pretty much, the first four of these tools all relate to the writing correct code, code that works the way you want it to, code the way we want it to, code the way that some problem to be solved wants you to implement it. Style is the last of those, and that's really the best categorization thereof. Of course, not always do these tools solve all of your problems. And undoubtedly, if you didn't experience this, this past week already, you will get frustrated. 

You will get incredibly frustrated sometimes by some bug in your code and you might be staring at it. You might be thinking it through. You might try all of these darn tools, go to office hours tutorial, and it's still not working out for you. Frankly, the solution there is to take a step back. And I can't emphasize enough the value of going for a jog, taking a break, doing something else, changing your mental model and coming back to it later. I have literally, and I'm sure many of the TF's and TA's have, solved code while falling asleep, because there, you're sort of thoughtfully thinking through what it is you did, what it is you're trying to do. 

But undoubtedly, it helps to talk through your problems some time. And there's this other term of art in computer science called rubber duck debugging. The idea being that if you don't have a TF at your side or CA at your side or roommate who has any idea what you're talking about when it comes to programming, you can have one of these little things on your desk that you can literally, probably with the door closed, start talking to, to explain to the duck, just like you would a teaching fellow, what it is you think your code is doing, walking through it line-by-line verbally, until hopefully, you have that self-induced aha moment, like oh, wait a minute, it's supposed to be 10 not 11, at which point, you discretely put the duck back down and go about your work. 

But it is meant to be this proxy for just a very deliberate thoughtful process to which everyone is welcome. You're welcome to take a duck today on your way out and we have lots more tutorials and office hours, because this is not enough here today. This is just because it exists. But the goal with rubber duck debugging is just that additional human mechanism for solving problems by taking the emphasis off of tools and putting it really back on the human. So if a little socially awkwardly, consider deploying that tool as needed as well. 