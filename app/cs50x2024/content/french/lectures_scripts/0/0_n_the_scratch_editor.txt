Passons donc à la pratique avec quelques programmes types. Je vais ouvrir un navigateur ici. Et dans un instant, vous verrez apparaître l'écran scratch.MIT.edu. Si je clique en haut, l'éditeur apparaîtra, avec par défaut ce didacticiel que je vais fermer. Mais maintenant, nous voyons le même environnement. Et vous remarquerez qu'à côté de « Scratch » en haut à droite, il y a un drapeau vert et un panneau d'arrêt. Le drapeau vert est le bouton que vous pouvez cliquer pour lancer le programme. Le panneau d'arrêt interromp l'exécution d'un programme. On remarque également que dans toutes ces catégories, il y en a, par exemple, quelques-unes de couleur orange appelées « Control ». Il y en a d'autres de couleur jaune appelées « Events ». Nous allons nous concentrer sur cette dernière catégorie pour commencer. Si je prends ce puzzle dans « Events » et le dépose ici, je peux commencer à programmer. Lorsque le drapeau vert est cliqué, faites ce qui suit. Que veux-je faire ? Eh bien, laissez ce chat dire bonjour. Et ayant déjà utilisé ce programme, je sais que dans « Looks », je peux dire quelque chose comme « Say hello ». Et remarquez que non seulement la forme correspond à la pièce orange ou jaune du puzzle, mais elle s'emboîte magnétiquement, et si je la relâche, elle restera en place. Et je vais dire l'une des choses les plus classiques à dire dans votre tout premier programme, qui est simplement « Hello World », et en rester là. Je vais maintenant cliquer sur le drapeau vert. Et voilà, notre tout premier programme. Le même effet. [APPLAUDISSEMENTS] Merci. Merci. C'est encore très basique pour l'instant, mais nous allons améliorer ça ensuite car ce chat est assez inanimé et ne fait que dire bonjour. Et si on voulait qu'il fasse plus que ça, et qu'il dise « Hello » non seulement, mais « Hello to me » ou « Hello to you » ? Eh bien, il s'avère que nous pouvons faire ça un peu différemment aussi. Je vais le jeter en le faisant glisser sur la gauche. Et la pièce de puzzle disparaît. Et si je fouille un peu plus sous ces blocs bleus, par exemple « Sensing », il y a un tas de pièces de puzzle liées à l'environnement de Scratch. Et l'une d'entre elles est celle-ci, « Ask », What's your name ? Et wait. Mais l'expression « What's your name » se trouve dans une boîte blanche que je peux modifier. Vous pouvez donc poser n'importe quelle question, mais je vais utiliser la question par défaut. Et maintenant, remarquez aussi qu'ici en bleu, il y a « Answer », qui est une autre forme circulaire qui représente ce que nous allons commencer à appeler une variable. Cette variable va stocker tout ce que la personne tape lorsqu'on lui demande son nom. Alors, que veux-je faire quand j'obtiens le nom de la personne ? Eh bien, revenons à « Looks ». Je vais dire « Hello ». Et je vais ajouter « Hello » et encore une autre fois « Say Hello ». Mais au lieu de ça, je veux qu'il dise mon nom. Mais ça serait incorrect d'écrire simplement mon nom, car mon nom sera toujours David, peu importe qui joue à ce jeu ou à qui la question est posée. Je ne veux donc pas faire ça. Si je vais plutôt dans « Sensing » puis que je glisse et dépose cette pièce de puzzle, remarquez. Elle s'emboîte magnétiquement là-dedans. Et elle grandira pour s'y adapter. Je peux maintenant dire « Hello » puis « name ». Alors, laissez-moi arrêter et rejouer. Quel est votre nom ? Je vais taper David. Entrée. Et maintenant David. Hum, il me semble que nous avons oublié le « Hello ». C'est mon premier bug. Avez-vous des idées sur la raison ? Qu'ai-je fait de mal ? Oui ? PUBLIC : [INAUDIBLE] DAVID MALAN : Oui. Je veux dire, j'ai dit à l'ordinateur via cet algorithme de faire trois choses, demander quel est votre nom et attendre, mais ensuite je dis simplement « Hello » et « Say Answer » en succession rapide. Et mon Dieu, nos Mac, PC et téléphones sont si rapides de nos jours qu'ils vont faire tellement de choses si vite qu'ils ont dit « Hello », mais aucun de nous ne l'a vraiment vu parce que mon nom l'a immédiatement remplacé. Je peux donc résoudre ce problème de plusieurs façons. Je vais revenir à « Looks » un instant, me débarrasser de cette pièce de puzzle, et peut-être dire « Hello » pendant deux secondes. Laissez-moi ensuite dire mon nom ou le nom de l'utilisateur pendant deux secondes en faisant glisser « Answer » ici. C'était donc mon premier bug dans le code, pour ainsi dire. Laissez-moi rejouer, taper David, et maintenant c'est « Hello, David ». Très bien. C'est mieux. C'est un peu bizarre parce que normalement, on ne salue pas quelqu'un en disant « Hello, David » deux secondes plus tard. Et si on combinait ces expressions et qu'on disait non pas « Hello World », mais « Hello Comma David » ? Eh bien, nous pouvons le faire d'une manière différente. Je vais revenir ici et, par exemple, prendre un seul de ces blocs « Say » comme celui-ci. Je ne vais pas m'embêter à le dire pendant un certain nombre de secondes parce que je ne vais dire qu'une seule chose maintenant. Mais je veux en quelque sorte dire « Hello comma » puis le nom de l'utilisateur. Eh bien, si je cherche plus loin, et vous ne le sauriez qu'en l'ayant déjà vu, il s'avère qu'il y a cette pièce de puzzle ici appelée « Join ». Et c'est un peu bizarre que les mots par défaut soient « Apple » et « Banana », mais ce ne sont que des espaces réservés. Si je prends ça et que je le fais glisser ici, il grandit pour remplir l'espace et remplace ce qui était là. Je peux dire « Hello comma » et ensuite au lieu de « Hello Banana », je retourne dans « Sensing », je fais glisser la réponse de l'utilisateur, et maintenant nous disons « Hello comma so and so ». Alors essayons plutôt ça maintenant. Drapeau vert, tapez mon nom, Entrée. « Hello comma David ». Donc maintenant, le programme n'est pas beaucoup plus compliqué, mais remarquez que nous commençons à imbriquer ces verbes, ces fonctions. Nous demandons un nom et ensuite nous disons le résultat de la jonction des deux choses suivantes. Il y a donc quelques idées à suivre à la fois. Mais c'est en fait assez similaire à ce que nous faisions depuis le début, comme suit. Par exemple, si nous voulons simplement dire « Hello World » avec cette pièce de puzzle ici, cela correspond en fait parfaitement à notre définition fondamentale de la résolution de problèmes. L'entrée de cette pièce de puzzle est, bien sûr, juste « Hello World ». La fonction ou l'algorithme que vous voulez exécuter, les instructions étape par étape pour dire quelque chose, que Scratch appelle « Say » en violet, et la sortie que vous voulez, bien sûr, est que Scratch dise « Hello World ». Maintenant, dans l'exemple plus sophistiqué, considérez ceci. Nous avons demandé « Quel est votre nom ? » Et puis nous avons attendu. Eh bien, cette image ressemblerait plutôt à ceci. L'entrée de cette question est, bien sûr, « Quel est votre nom ? ». L'algorithme, ou dans ce cas, la fonction, par lequel nous résolvons ce problème est de demander et d'attendre, en tenant compte de cette entrée. Et la sortie que nous obtenons est maintenant « Answer ». Et enfin, dans ce troisième exemple, où les choses sont devenues un peu plus sophistiquées et où vous avez dû commencer à faire glisser, déposer et imbriquer ces pièces de puzzle, remarquez que c'est la même idée. L'entrée est maintenant deux choses, « Hello » et « Answer ». Ceux-ci entrent dans une fonction appelée « Join », dont le résultat devrait être « Hello comma David ». Mais maintenant, nous voulons passer cette sortie en entrée au bloc « Say » afin que le résultat final soit « Hello, David » directement de la bouche du chat. Ainsi, de cette façon, même avec les pièces de puzzle les plus simples, tout s'intègre dans ce même modèle de résolution de problèmes.