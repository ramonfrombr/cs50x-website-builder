Ahora continúo y hago eso. Permíteme crear otra versión, cough1.c. Y voy a copiar/pegar este código, solo como punto de partida. Pero ahora voy a continuar, para limpiarlo. Así que voy a hacer lo siguiente: en lugar de esto, voy a crear un ciclo for. Y no recuerdo exactamente qué va entre paréntesis, pero ya lo veremos. Lo que sí sé es que quiero toser algunas veces. Entonces, la única pregunta en este momento es, ¿cuál era la sintaxis aquí? Bueno, podemos escribir esto en cualquier cantidad de formas e incluso podríamos usar un ciclo while. Pero recuerdo que dije int y luego el nombre de una variable. Podría decir counter o simplemente i para que sea más conciso, es igual a 0 de forma predeterminada. Podría hacer esto siempre que i sea menor que 3, por ejemplo. Y luego, en cada iteración, puedo decir que i es igual a i más 1 o, más concisamente, i más más. Entonces, nuevamente, es una nueva sintaxis. Y ahora aparecen punto y coma por todas partes. Pero si continuo ahora y hago make cough1, parece que no ha pasado nada malo. ./cough1, cough, cough, cough. Parece tener un diseño ligeramente mejor. Desafortunadamente, existe este paradigma en la programación donde los humanos, los programadores, tienden a pensar o a contar comenzando desde cero. Sin embargo, si no te gusta eso, al menos al principio, no hay nada que me impida inicializar i en 1 y luego hacerlo i es menor que 4 o, incluso más explícitamente, i es menor o igual que 3. Generalmente, no hay un signo menor o igual que en tu teclado, por lo que puedes imitarlo creando un signo menor y luego un signo igual, dos caracteres. Lógicamente, esto es lo mismo. Establecer i igual a 1. Luego, continúa e imprime cough y luego asegúrate de incrementarlo. Y luego asegúrate de que todavía sea menor que 3, y 2 sí lo es. Asegúrate de que todavía sea menor o igual que 3, y todavía lo es. Por lo que, lógicamente, ese 2 tendrá el mismo efecto. Sin embargo, en aras de la convención, este sería el enfoque más común. Haz esto mientras i sea igual a 0 y luego 1 y luego 2, por un total de 3 veces. Muy bien, pero recuerda que también lo que hicimos la última vez es que si estoy escribiendo mucho código, por alguna razón, que involucra programas de tos, sería bueno tener mi propia función personalizada. Entonces, continúo y hago eso. Permíteme continuar y escribir mi primera función completamente nueva. Y voy a hacer esto de la siguiente manera. Voy a continuar y escribir void, luego el nombre de la función que quiero. Luego voy a decir void aquí, por razones que veremos más adelante. Y luego voy a continuar literalmente y decir cough. Entonces, hay funciones que hemos usado hoy: printf, get_int, get_string, get_float, ninguna de las cuales te mostramos la implementación, porque personas, hace años, tanto dentro del personal como en el mundo real, implementaron esas funciones para nosotros. Tú también puedes implementar tus propias funciones personalizadas o, en Scratch, esas piezas de rompecabezas que hicimos en esos bloques rosas. Entonces, si quieres crear tu propia función cuyo nombre es cough, cuyo propósito en la vida es decir "cough" en la pantalla, esta es la sintaxis. Para los propósitos de hoy, dices void y void aquí, pero el nombre de la función es importante. La llamaré cough. Y luego puedo usarla de la siguiente manera. Puedo decir cough, cough, cough ahora para toser tres veces. O de nuevo, ya decidimos que era un mal diseño. Para int i obtengo 0, i menor que 3, i más más. Ahora puedo hacer algo como cough. Y ahora, de nuevo, fuera de la vista, fuera de la mente. No necesito saber o preocuparme por cómo se implementa la función cough. Puedo preocuparme de que mi código solo le diga a la computadora qué hacer. Para i de 0 a 3, cough, cough, cough. Y esta es una abstracción. No me importa que cough se implemente con printf. Solo me importa que haya una función llamada cough. Entonces, permíteme continuar y ejecutar esto y ver qué sucede. Déjame desplazarme hacia abajo hasta el final, hacer make cough1. Está bien, increíble. Ahora no hay errores en rojo. Entonces, ./cough1, cough, cough, cough. Pero observa que este es un diseño un poco malo, diría, porque ¿sabes qué? Si sigues escribiendo funciones personalizadas aquí, aquí, aquí, la parte principal de tu programa se verá muy lejos. Y es una convención humana tener generalmente la función principal en la parte superior de su archivo. Parece bastante razonable. Entonces, abres el archivo, boom, la función principal está ahí mismo. Así que mantengámoslo ahí. Así que déjame mover la función cough hacia abajo solo para que, nuevamente, lo primero que vea sea de hecho la parte principal de mi programa. Y donde sea que esté cough, no me importa. Ese fue todo el punto de implementarlo. Déjame ir ahora a mi ventana de terminal y hacer make cough1. ¡Oh, Dios mío, pasaron algunos errores en rojo! ¿Qué pasa aquí? Por lo tanto, error, la declaración implícita de la función cough no es válida en C '99. C '99 significa la versión de C inventada en 1999. Qué pasa? ¿Declaración implícita? Aquí es donde C difiere de Scratch nuevamente. C es antiguo y es un poco tonto. Solo sabe lo que le dices y solo sabe lo que le dices de arriba hacia abajo, de izquierda a derecha. Entonces, en este programa ahora mismo, he incluido stdio.h, como antes. He incluido el principio de main. He iniciado un ciclo for. Y luego estoy usando una función que aparentemente se llama cough. Sin embargo, ¿dónde está implementada la tos en este momento? En la línea 11 en adelante. C no es tan inteligente. No va a suponer mirar más adelante en tu archivo para ver, tal vez pusieron la función cough abajo. Solo va a hacer lo que le digas. Entonces, hay una solución para esto. Puedes hacer lo que hice inicialmente, que es poner todas tus funciones personalizadas arriba. Pero eso es una especie de círculo vicioso, porque no puedes poner las nuevas funciones arriba para siempre. Finalmente, te vas a encontrar con algún tipo de restricciones. Y Dios mío, quieres que la función principal, por convención, esté arriba. Entonces, hay otra solución aquí. Y esta es la única vez que copiar/pegar es convincente. Literalmente, copias la primera línea del código de tu función en la línea 11 allí. Y continúas y lo pegas en la parte superior de tu archivo con un punto y coma. Entonces, esta es una forma de engañar a C, oh, ya has visto cough antes. No lo has visto todo, pero has visto lo suficiente (has visto su nombre) como para tolerar su aparición en mi función main ahora. Entonces, continuemos y recompilemos este código. Voy a continuar y ejecutaré make cough1 enter. Bien, ahora se compila. ./cough1 y viola, ya estamos de vuelta en el negocio.