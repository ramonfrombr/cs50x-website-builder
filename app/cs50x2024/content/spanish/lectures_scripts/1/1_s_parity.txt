Bueno, permítanme intentar algo más. Voy a copiar y pegar los inicios de este código, tan solo para acelerar las cosas. Así puedo implementar un programa llamado parity.c. Parity es una forma elegante de decir si un valor es par o impar. Ya he copiado y pegado la configuración del código, no la esencia de mi función principal. Pero vayamos adelante, en este programa, y preguntémosle al usuario un número. Lo llamaremos n. Y utilizaremos get_int para obtener ese valor. Y simplemente le preguntaremos al humano: ¿cuál es el valor de n? Yo solo escribiré n dos puntos espacio para pedirles algún entero. A continuación, voy a continuar y hacer una pregunta. Quiero terminar imprimiendo par si el número es par o impar si el número es impar. Puedes imaginar hacer esto de la forma más tediosa, como si n fuera igual a 1, yo podría continuar e imprimir impar. Y después si n fuera igual a 2, yo podría imprimir par. Y después de eso, podría admitir el número tres, si no n... quiero decir, esto es estúpido, ¿no? Podría hacer esto para siempre. Pero al menos muestra un patrón, ¿no? Uno y luego tres y luego cinco, por supuesto, van a ser impares, y dos y cuatro y seis van a ser pares, y así sucesivamente. Bueno, resulta que podemos calcular esto matemáticamente. Y un truco muy común podría ser este: realmente podemos hacer esto. Si n dividido entre 2 tiene un residuo de, por ejemplo, 0, entonces voy a continuar y concluir que el número es par. Entonces, este signo de porcentaje es una nueva construcción. No es suma. No es resta. No es multiplicación ni división. Esta es la operación del residuo, o la operación del módulo, por así decirlo. Y esto solo significa dividir n entre 2, y si la respuesta tiene un residuo de 0, puedes concluir, por definición de par, que el número es par. Entonces, voy a imprimir eso. De lo contrario, podría hacer else si n por ciento 2 es igual a 1 y tiene un residuo de 1, podrías imaginar decir impar. Pero como lo notaste anteriormente, esto no es necesario. ¿Qué podría hacer en su lugar para hacer que el programa tenga un mejor diseño, que sea un poco más eficiente? ¿Sí? AUDIENCIA: Podrías simplemente usar else y eso estaría bien. DAVID MALAN: Sí. Entonces, si estamos hablando de enteros, puedo simplemente concluir, bueno, si no es par, debe ser impar, por definición. Y entonces, aquí, simplemente podemos hacer par e impar. Así que este programa, una vez que se ejecuta, se verá así. Crear paridad. Parece que se compiló correctamente. Entonces, ejecuto ./paridad. Escribamos el número 50. Eso es par. Escribamos el número 49. Eso es impar. Prueba mediante ejemplo. Esto no es muy convincente, pero apuesto a que esto va a ser correcto, solo basándose en esos dos ejemplos. ¿Sí? AUDIENCIA: [INAUDIBLE] ¿el usuario no entendió nuestro comentario de si la respuesta es un flotante o no un entero? DAVID MALAN: Lo siento, ¿podrías repetir eso? AUDIENCIA: ¿Y si el usuario no entiende, eso digo? Como que simplemente hago algo como 1 y 1/2 [INAUDIBLE]... DAVID MALAN: Muy buena pregunta. Una de las razones por las que proporcionamos para las primeras semanas de clase algunas funciones en la biblioteca de CS50 como get_string y get_int y get_float es que obliga al usuario a comportarse como espera para que su programa no se bloquee debido a una entrada inesperada del usuario. Entonces, a lo que apuntas, suponga que el usuario está siendo un poco difícil y dice, mi número va a ser 1,5. Get_int les hará la misma pregunta una y otra vez hasta que cooperen. Si escribe apple, se lo volverá a preguntar. Solo cooperará una vez que proporcione un número entero real. Así que esas son algunas de las características que obtiene de la biblioteca CS50, solo para que podamos centrarnos en ideas y no en lo que llamaríamos comprobación de errores o usuarios malintencionados, en este caso.