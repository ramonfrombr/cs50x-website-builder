Ahora seguiré adelante y abriré un ejemplo que se basa en esta misma idea. En, veamos, positive.c, tenemos este aquí, que aclara aún más esto. Aquí tienen un programa que usa nuestras dos bibliotecas, CS50 en una E/S estándar. Resulta que la biblioteca CS50 no viene con una función llamada get_positive_int. Viene con get_int. Y podrías imaginar programas en los que realmente quieres un número entero positivo del humano, porque los números negativos para un juego o para algún programa simplemente no tendrían sentido. Entonces, ¿cómo podemos implementar eso? Bueno, sería bueno crearlo para que simplemente puedas escribir un programa de dos líneas como este en el que llamas a una función llamada get_positive_int. Y si me desplazo hacia abajo, notarás que realmente hay una función nueva aquí que no hemos visto aún, pero es un ejemplo interesante de otra función de C. Lo que he resaltado aquí entre las líneas 15 y 24 es esta lógica. Aquí hay una función llamada get_positive_int. No toma ninguna entrada, así que no tengo que pasar nada entre paréntesis. Solo quiero obtener cualquier entero positivo. Pero sí quiero que esta función me devuelva algo, justo como get_int me devolvió un valor que podría colocar en una variable, justo como lo hace get_string. Así que esto no es nulo. Esto es un int. Así que esta palabra al lado izquierdo de una función es el tipo de salida. Esta palabra entre paréntesis es el tipo de entrada, si hay alguna. Y si no hay nada, simplemente dices nulo en cualquier lugar o en ambos. Ahora, aquí hay una curiosidad: en la línea 17 no habíamos visto esto antes, pero es solo una pista para que la computadora diga dame una variable llamada n. Aún no estoy seguro de qué voy a colocar en ella. Así que literalmente simplemente dices punto y coma int n. Aún no tienes que asignarle nada. Tiene lo que llamaremos un valor basura. No tienes idea de lo que hay en él, pero eso no importa. Le colocarás algo más tarde. Luego está este ciclo que no hemos visto aún, pero en C se llama ciclo do-while. Literalmente dice haz lo siguiente mientras esta expresión booleana es verdadera. Así que, ¿qué quiero hacer? Quiero obtener un int del usuario pidiéndole un entero positivo a la persona y guardarlo en n. Sin embargo, quiero seguir haciendo esto mientras n sea menor que 1. Porque si la persona escribe 0 o 1 negativo o 50 negativo o algo no positivo, quiero pedirle una y otra y otra vez. Entonces, un ciclo do-while es un poco ingenioso, porque hará esto primero al menos una vez. Luego comprobará la condición y posiblemente lo haga otra vez si la persona no ha cooperado. Un ciclo while, si lo piensas bien, en realidad revisó la condición primero. Era mientras alguna expresión booleana sea verdadera, haz lo siguiente. Este te da una de esas iteraciones, un pase gratis y luego verifica la condición. Así que es simplemente una manera diferente de programar, pero podríamos hacer todo lo que hemos hecho hasta ahora usando ciclos while o incluso ciclos for.