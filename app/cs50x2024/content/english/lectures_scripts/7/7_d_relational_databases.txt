So let's go ahead and take a look at some of the features of these things. What we've really just done is introduce this, something called a relational database. The goal at hand is not to rely on CSV files anymore. CSVs are like the weakest form of databases you can use. Why? Well, every time you want to look in a CSV file for data, you have to open it. You have to read it in. You have to iterate over it, line by line by line, looking for the data you care about, and then you're done. That's going to be super slow when you have a lot of data in a CSV file. And in fact, in a little bit today, we'll download a really big database in text form that we're going to then see 500-plus megabytes later is much better handled by what are called relational databases, pieces of software you can run on your Mac or PC or servers in a company. All they do is store data and provide you with faster access to it. So SQLite3 is just a command line program via which we can interact with that data. It's not terribly compelling. It's, again, a black and white blinking prompt, but we'll see a graphical user interface, or GUI, in a bit, too, that'll allow us to navigate that same data. 

Here's how we went ahead and imported the data. And .schema is the last of the commands. In fact, let me go ahead and type this at the prompt. Not .mode or .import but .schema. And you'll see what automatically happened for me is something like this, CREATE TABLE favorites. This all happened automatically when I imported my data, but in a bit, we'll be doing this more manually ourselves. 

So where does this then bring us in terms of features? Well, in the world of storing data, whether it's storing users who've registered for your websites or the number of likes a post on Instagram has gotten or any form of data that you might want to read or write, there are four fundamental operations in the world. CRUD is the sort of crude way of remembering this. These stand for Create, Read, Update, Delete. And I dare say that with these four operations you can do anything you want when it comes with data. Creating that data, reading that data, updating it, or deleting it. 

Now, in the world of SQL, or Structured Query Language, or S-Q-L, this is just another programming language. It tends to be used only in the context of databases, but you can use it to solve problems not unlike Python, but in the context of the data you care about. So with SQL, these four CRUD operations actually have different keywords mapped to them. They happen to be these, INSERT, SELECT, UPDATE, DELETE. That is to say, unlike Python, which has hundreds of functions available to you, today is kind of neat in so far AS SQL has maybe a dozen or so total functions that you can use, a few dozen functions total that you can use. Much more manageable, and these are the four that we'll use most frequently. 

So beyond this, how do you go about creating a table? Well, what does that mean? Well, relational database is literally that. It's like a fancier version of Google Spreadsheets or Microsoft Excel or Apple Numbers that allows you to store all of your data in rows and columns. But it gives you these four functions and more via which to select data you care about, or delete or update or insert data that you care about as well. So we'll see in a bit that this is going to be the syntax VIA which in SQL you can create a new table. In Google Spreadsheets you would literally go to the plus icon and say New Sheet. In SQL, you would express this more programmatically with a line of code like this. 

But you're going to have to make a few decisions along the way, and that's because SQL has its own data types. Now, fortunately, they're pretty reminiscent of C and Python. But there's five main ones here. Let's just walk through a few examples thereof. So first, INTEGER. If you know in advance that you want to store a whole bunch of information in a database like someone's age or the number of likes a post has or anything that lends itself to an integer, SQL supports an integer data type. But in some versions of SQL, you actually have a decision to make. Do you want an integer, a smallint, or a bigint? And these speak to, as in C, the size, the number of bits that are used to store it. An integer is 32 bits. A bigint is 64 bits. A smallint is fewer than both those. 

Now, we're using, for class, something called SQLite. It's a free and open source, very user friendly version of SQL. But there's others you might have heard about. So if you've ever heard of the company Oracle, their bread and butter is a database program called Oracle that is a SQL database that allows companies to store huge amounts of data and select and create and update and delete data using software they've written. MySQL, Postgres, MariaDB, Microsoft Access Server, SQL Server, and bunches of others, are all examples of SQL servers. And they'll each support data types, typically, like this. 

We happen to be showing you ones from Postgres, which is a super popular open source one that you can use on the internet, for instance for final projects. Real numbers, just like in Python or C, are similar in spirit to floats. However, you have a couple of options. One is a real, which uses 32 bits. Another is called double precision. It's actually two words, but it gives you 64 bits as well, to give you more precision numerically. 

Then you've got this catch-all known as numeric in SQL, whereby if you have a number that's number-like, essentially, but isn't just an integer, categories-- this category encompasses things like Boolean values, dates, which have a predefined format like YYYY, four digits typically implements a year. That would be considered numeric here, as would be a date and a date time, which has something like 00:00:00 for hours, minutes, seconds. And then you have other values as well. 

What's nice about this numeric type specifically is you can actually solve the floating point problem in both Python and C. Recall that floats or even doubles in C ultimately have finite precision, which is bad in terms of values not quite adding up as you intend. But with numeric data types and databases, you can specify exactly how many digits you want before the decimal point and after, maximally. So if you're doing with financial information or scientific information, you can be super, super precise thanks to this data type in the database. So finally, a problem that we've solved, versus those other languages. 

Text. When it comes to storing data in a database, you can specify that your columns can either be characters, which isn't an individual characters or chars. You literally specify n, the number of characters that every cell in that column will be. You never do this in Excel. You never do this in Google Spreadsheets or Apple Numbers. In a database, though, you can tell the database ever more precisely, I want to store two characters in every cell in some column. 

Why? Well, maybe like US state codes. If you have MA for Massachusetts or CA for California, it might be nice to tell the database that you can store, minimally and maximally, two characters for every value I'm going to give you. Varchar is a little different. This is a variable number of characters. If your column might have a few characters or a lot of characters based on what some human types in, you can give an upper bound n on how many characters will be stored in every cell. So if you don't know in advance how long a user's email address is going to be or how long my name or your name is going to be in advance, you can specify varchar and then pick some upper bound, some value that, ugh, no one's going to have more than 20 characters in their name or 200 characters in their name, whatever line you decide to draw in the sand. 

As an aside, does anyone want to conjecture what a good upper bound is for the number of characters in a human name that might register for a website you're making? 

AUDIENCE: [INAUDIBLE] 

DAVID MALAN: 25? Pretty good. 

AUDIENCE: [INAUDIBLE] 

DAVID MALAN: 30, I heard. 

AUDIENCE: [INAUDIBLE] 

DAVID MALAN: 32, OK. 

AUDIENCE: [INAUDIBLE] 

DAVID MALAN: 45? Higher. 60? 

AUDIENCE: 64. 

DAVID MALAN: 64? This is the kind of thing that Google, I dare say, is good at. So let me go ahead and open up Google real fast. Suppose the goal at hand is the store, in a database table, that is the equivalent of a spreadsheets column, the longest name in world. All right. Looks like we had 988 characters in a fellow's name, Hubert. And I won't even try to pronounce his last name, but there it is. So if you want to fill-- if you to be able to fit everyone's name-- oh, and note, senior. 

[LAUGHTER] 

You might need even more characters than that. So this is a rabbit hole we won't really go down today, but suffice it to say that the answers to these questions are often not obvious. And if you think about websites you've visited in the real world, whether on campus or off, odds are, you have tried typing in some input to some web-based form or even some mobile application, where all of a sudden your keyboard stops working, right? They won't tolerate any more characters. Maybe it's the Common Application and the length of your essay. Maybe it's the length that your resume can be in a field. Maybe it's the length of your name when registering for a website. Well, why is that? Those applications are probably using a database, probably using SQL, and they had to decide, in advance, what is the maximum length of an input that we're going to tolerate from a human? And then the computer ultimately enforces that. 

Why? Well that would be a very clever attack, for some bad actor out there to exploit. If you had no bounds on how big the input could be that a human could type in, they could-- much like I need to try the other day with Emma's name-- just keep pasting pasting, pasting, pasting a massive input, hoping to overwhelm your computer's memory, maybe make your server crash, and therefore deny service to other people. So there are reasons for these kinds of defenses. 

Lastly is BLOB. At the very top, Binary Large Object. Don't need it typically that often, but if you want to store binary data, raw zeros and ones that represent files or the like, you can store it in a BLOB format as well. 

Now, just to give you a whirlwind tour of other syntax before we start using it, you can insert data into a database using syntax quite like this. You can select data from a database using syntax like I already did. You can use functions as well. In fact, in just a bit, when we load more data into the database, I could actually select all of the distinct names from a database-- and in fact, I could have done this a moment ago. Rather than SELECT title FROM favorites, as I did earlier-- that's going to give me all of the titles in that database. I could instead do something like SELECT DISTINCT title FROM favorites, and that's going to filter out all of the duplicates without me having to write a single line of code to do that. You can also count, as we did before. You can compute averages, mins, or max, which is really useful for analytical work that you might want to do as a data scientist or the like. And there's a whole bunch of other functions available to as well. 

But there's some more powerful features. And we'll begin to use these in just a little bit. We used WHERE before. I used LIMIT before. I used GROUP BY before. And we'll see a bunch of examples that reinforce all of these. But there's keywords like LIKE, whereby if you want to search for everyone's input who mentions The Office, you know what? I bet we could do something like this instead. I know that I can SELECT star for-- oh, let's go ahead and SELECT title FROM favorites WHERE, and this is kind of nonsensical, but title equals "The Office," quote unquote. And I get back everyone who typed in literally The Office. 

However, if I instead did something like this, "the office" in lower case, I'm going to get one of you who typed in "the office" in lowercase. And the thing here is just the title of this output. But what if I want to do anything like The Office? I could say something like LIKE "%office%", and it turns out in SQL, this new language, percent is a placeholder. It's a wild card that just says, eh, anything can go before, and, eh, anything can go after. So now I'm searching for any titles that have the word The Office. We picked up another entry here. So one of you said Office, without the word "the," also pretty reasonable. Some of the uppercase and lowercase is all over the place. Now we've caught those. 

And if you want to count the total number of offices now, now I can do something like this. COUNT title-- so I can combine all of these building blocks, not unlike Scratch, and get back the total number of offices, which looks now to be 33 when we tolerate a lot more variability in our users' input. 

Most powerfully of all, we'll see something like JOIN in just a little bit, and that'll be all toward the end of using databases better with better design. But with SELECTs, we, of course, don't just want to select all of the titles. We might select where some condition is true. So conditions, just like in Python and C, exist in SQL, but at the end of our queries, as we've seen. If you want to update something, for instance, you can update data in a database by saying UPDATE table name SET the column name equal to some value, WHERE condition is true. 

So how might I use this? Well, let's again look at the data where it's like The Office. And you know what? I'm going to go ahead and do this. If I want to clean all of this data up-- so data cleaning is a very common approach, whether you're doing research or analytical work, often when you have messy data, the first pass is honestly grunt work. Like, writing some code, or god forbid, manually copying and pasting in an Excel file, just to clean up your data. You can do this a lot more powerfully in SQL. 

So for instance, let me go ahead and say UPDATE my favorites SET title equal to "The Office," the canonical form, capital T, capital O, WHERE title LIKE-- and now let me do this wildcard search, knowing that that's going to slurp in all 30-plus of those rows. But now, when I hit Enter, nothing seems to happen. But if I then SELECT title again WHERE LIKE "%office%", now they all look the same, because I've updated my data. And so in fact, now I could go back to The Office, because I've canonicalized my data, and everything now looks the same. 

So with SQL, can you do that as well? Previously, let's go ahead and SELECT a title FROM favorites. And let's just limit this to 10 of them this time, so they don't all fly by. Suppose-- VEEP is a good show. Maybe I'm not a fan of, say-- let's give ourselves 20 here, see what comes up next. OK, I actually don't like Friends, even though everyone in the world seems to. No problem. DELETE FROM favorites-- 

[LAUGHTER] 

--WHERE title = "Friends";. Now, no more Friends. And so you can delete your data as well. 

[LAUGHTER] 

You can delete your data as well as by using a query of this form. This one is perhaps the most dangerous of all. Consider what might happen if you're a little sloppy, a little hasty, and omit the WHERE condition. What happens if you go ahead and DELETE FROM favorites;? Everything goes away. And slightly worse than that, though we won't have occasion to use it, there's another function called DROP, where if you just want to delete the table altogether, delete all of your rows and columns, you can say DROP TABLE favorites;, and that will delete all of the data as well. 

And we'll come back to that, because the mere fact that you can scarily delete lots of data at once makes you super vulnerable to bad actors on the internet or in the office who want to potentially wreak havoc on your data.