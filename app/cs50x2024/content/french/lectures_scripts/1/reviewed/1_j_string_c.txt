Très bien, allons maintenant passer à quelques autres fonctionnalités que nous pouvons utiliser, à commencer par l'implémentation du même programme que j'avais jusqu'à présent. Laissez-moi fermer ce fichier et créer un nouveau fichier, string.c, par exemple, car je vais maintenant faire des expériences avec des chaînes de caractères. Je vais commencer comme avant: include stdio.h int main void. Et ici, je vais ajouter string reponse = get_string, entre guillemets, "Quel est ton nom?", point d'interrogation, barre oblique inverse n, point-virgule.

Je vais ensuite faire un printf, entre guillemets, "Bonjour response". Eh bien, pas reponse, parce que nous avons dit que c'était mauvais. Cela dirait littéralement reponse. Je dois faire un espace réservé, %s. Et maintenant barre oblique inverse n, virgule, reponse, point-virgule. Je pense donc avoir transcrit le code de la diapositive dans mon environnement de programmation, dans un fichier appelé string.c.

Si je veux compiler ce programme, le convertir du code source au code machine, quelle commande puis-je saisir ici? Clang. Donc, clang string.c. Mais cela va me donner un programme, par défaut, appelé a.out, ce qui n'est pas très utile. Je vais donc ajouter tiret O (-o) string, juste pour que mon programme s'appelle string. Mais je pourrais l'appeler comme je veux. Je vais donc appuyer sur Entrée. Oh, mon Dieu, il y a plus d'erreurs que de lignes de code, ce qui est un peu inquiétant.


Mais vous n'êtes pas si mauvais en programmation que vous générez plus d'erreurs que de lignes de code que vous avez écrites vous-même. C'est juste que l'ordinateur est devenu vraiment confus à un moment donné, et il commence à s'embrouiller, pour ainsi dire, conceptuellement. Il ne sait pas où se trouve l'erreur, alors il commence à mal interpréter le code correct comme étant du code incorrect. Il faut donc toujours commencer par le premier message d'erreur.

Donc concentrez-vous sur la première erreur que vous voyez, et peut-être que les autres ne sont que des erreurs fantômes, de la confusion qui a surgi à la place. Laissez-moi agrandir cette partie de l'écran et voir si nous ne pouvons pas diagnostiquer ce problème. La commande que j'ai exécutée était Clang -o string string.c. Cela signifie simplement que mon entrée est mon code source dans string.c. Je veux que ma sortie soit du code machine dans un fichier appelé string.

Très bien, la ligne 5 de string.c est l'endroit où commence l'erreur, cela semble donc être un endroit familier. Ce message en anglais se traduit par "Utilisation d'un identifiant non déclaré string. Vouliez-vous dire stdin?" Non, je ne le voulais pas. Je voulais dire string dans ce cas. Ici aussi, l'ordinateur est devenu confus, et même son message d'aide n'est en fait pas utile. Donc, je veux en fait une string, c'est-à-dire une chaîne. Je ne veux pas de stdin.

Mais la raison en est que techniquement, du moins à ce stade de l'histoire, il n'existe pas de chaîne, il n'existe pas de string en C. C'est en fait une sorte de petite roue d'entraînement que nous allons utiliser pendant quelques semaines seulement jusqu'à ce que, nous montrions ce qui se passe réellement sous le capot de l'ordinateur, pour ainsi dire, lorsqu'il s'agit d'implémenter une chaîne. Une chaîne est donc quelque chose que le cours CS50 vous fournit dans un fichier appelé CS50.h. Donc, tout comme il existe un fichier appelé stdio, où I/O signifie simplement input/output, c'est-à-dire, entrée/sortie d'informations, comme l'impression et l'obtention d'entrées. Tout comme il existe un fichier appelé stdio.h, dans lequel printf a été inventé, toutes les autres fonctions que je pourrais utiliser dans ce programme, comme get_string, sont stockées dans un fichier appelé CS50.h.

Mon problème est donc survenu il y a un instant lors de la compilation de ce code, car l'ordinateur n'avait aucune idée de ce qu'était une chaîne. Et il n'a aucune idée, nous verrons ce qu'est la fonction get_string. Je vais donc recompiler tout de suite. Je vais faire Clang -o string string.c. Et voilà. Entrée. OK, des progrès.

Il y a encore un problème. Il y a encore une erreur, car le rouge ne peut pas signifier quelque chose de bon dans ce contexte. Et en effet, c'est une erreur. Mais il y a beaucoup moins d'erreurs. C'est donc le dernier élément des commandes que nous devons introduire maintenant. Remarquez ce que dit le message d'erreur. Donc, après avoir exécuté Clang -o string string.c, il y a toujours un problème dans ma fonction main. Quel est le problème? la traduction de ce message erreur dit "Référence non définie à get_string".