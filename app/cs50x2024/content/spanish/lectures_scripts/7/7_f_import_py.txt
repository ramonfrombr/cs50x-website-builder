Bien, veamos, y abramos un archivo llamado import .py. Y voy a continuar e importar el módulo CSV, como siempre, y voy a continuar y abrir este archivo, que se llama title.basics.tsv en modo de sólo lectura, y llamaré a esta variable títulos. ¿Qué voy a hacer después? Voy a crearme un lector usando csv.DictReader, como antes, leyendo esos títulos. Pero csv.DictReader no parece el lector adecuado. ¿Por qué? Para que quede claro.

Sí, bueno, quizás quiero TSV. Pero resulta que TSV no existe. Entonces, aunque me incline, por ejemplo, a cambiar esto a una T y esto a una T, el módulo CSV hace suficiente por mí, pero necesito decirle que quiero usar un delimitador diferente. En lugar del predeterminado, que se ve así, en realidad puedo anular eso y decir, ¿sabes qué? Usa una tabulación. Y como la barra invertida n en C y en Python, es una nueva línea. La barra invertida t en ambos idiomas es un carácter de tabulación.

Muy bien, una vez hecho esto, déjame continuar y abrir, ahora, déjame continuar y abrir shows0.csv. Mi objetivo en este momento es hacer que este archivo sea mucho más manejable para mí. Quiero tomar un archivo de 500 megabytes y extraer solo los programas de televisión que contiene. Además, ¿qué tal solo los programas de televisión desde 1970 en adelante? No vamos a ir más atrás que eso.

Así que, voy a continuar y abrir, en modo de escritura, un archivo llamado show0.csv. Y voy a llamar a esa variable shows. Luego voy a continuar y obtener un escritor. Y puedes recordar haber usado esto en el pasado. Esto simplemente me dará una variable llamada escritor, a través de la cual puedo escribir en un nuevo archivo. Porque, de nuevo, el objetivo es leer este archivo y escribir en este archivo un subconjunto de los datos que contiene.

Así que voy a continuar y escribir una fila primero. Escribir una fila, pasando una lista de valores, específicamente tconst, que es el título, que es el campo de identificación; primaryTitle, que es el campo de título; startYear, que es el campo de año; y genres, que era uno de los campos que mencioné anteriormente. Entonces, mi objetivo es exportar solo esas cuatro columnas que me interesan por ahora.

Así que voy a continuar y hacer esto. Para cada fila en mi lector, voy a continuar y decir que si el titleType de la fila == tvSeries, que, recuerdo, The Crown fue un ejemplo de eso, entonces voy a continuar y escribirle al escritor -- oops -- writer.writeRow, una lista que contiene ¿qué? El valor tconst de la fila, el valor de título principal de la fila, la fila -- oops -- el año de inicio de la fila, y por último, la fila -- [RISAS] los géneros de la fila.

Entonces, ¿qué estoy haciendo aquí, para que quede claro? Lo que he hecho es que primero escribí, una y solo una vez, literalmente estos valores, porque quiero encabezados en la primera línea de mi archivo. Después de eso, para cada fila en el lector, que actualmente está iterando sobre este archivo en modo de solo lectura, quiero imprimir el tconst de la fila actual, el título principal de la fila actual, el año de inicio de la fila actual y la fila actual. géneros. Pero fíjate, estoy ignorando películas y cortos y documentales y muchos otros valores también.

¿Y sabes qué? Solo por si acaso, hagamos esto un poco más pequeño. Y la fila, ¿qué tal si es adult == "0", para los propósitos de hoy? Así que eso filtrará aún más la lista. Si quieres darle la vuelta más tarde, está bien. Así que déjame continuar y hacer Python 3, para la versión 3 en mi Mac, en realidad, no, hagamos Python de import.py, ¿de acuerdo? Voy a cruzar los dedos aquí. Ojalá el archivo esté funcionando, funcionando, funcionando. Pero está tomando una buena cantidad de tiempo. Por ejemplo, esta es la cantidad de tiempo que lleva, aparentemente, procesar millones de filas de datos. Sigue corriendo. Sigue corriendo. Pero el objetivo, de nuevo, es reducir la cantidad de datos que tengo que cuidar en última instancia para que podamos buscarlos de manera mucho más efectiva.