Ok, alors bon, il est réellement terminé. Donc laissez-moi aller de l'avant et ouvrir show0.csv. Notez maintenant que dans mon éditeur de texte, j'ai beaucoup moins de données. J'ai jeté tout ce dont je ne me souciais pas, mais il me reste tconst, primary title, start year et genres, et tout ce qu'il y a dans le document est maintenant conforme à cette filtration. Mais je n'ai pas filtré tout ce que j'ai dit que je voulais filtrer. De quoi ai-je dit que je voulais me débarrasser tout à l'heure ?

Oui, des émissions avant 1970. Et il est clair que certaines d'entre elles viennent des années 1940, etc. Alors allons-y, débarrassons-nous-en, mais voyons comment. C'est le fichier CSV que nous venons d'ouvrir, mais sous forme de feuille de calcul Google. Je l'ai donc littéralement importé dans Google Spreadsheets pour que nous puissions le voir. Les données sont littéralement les mêmes que précédemment et il y a ces films des années 1940.

Mais il y a quelque chose de curieux que je voulais garder à l'esprit. Si je fais défiler les années de début, vers le bas et que je continue, hein, celles-ci semblent correctes. Elles augmentent dans l'ordre. Mais laissez-moi essayer ceci. Laissez-moi simplement consulter mes données, les classer dans l'ordre inverse. Cela va prendre un certain temps, car ce nombre d'émissions de télévision est décent. Remarquez cette bizarrerie. En haut de l'année de début maintenant, une fois que je les ai classées par ordre inverse, il y a tout un tas de backslash majuscule N. Maintenant, cela n'a rien à voir avec C et rien à voir avec Python. Cela a tout à voir avec la documentation.

Si vous lisez les données d'IMDB, comme je ne l'ai fait soi gneusement qu'à la fin, vous verrez ça. Une barre oblique inverse N majuscule est utilisée pour indiquer qu'un champ particulier est manquant ou nul pour ce nom de titre. Maintenant, c'est important, parce que si je veux filtrer les films postérieurs à 1970, je dois être résistant à cela. Alors laissez-moi aller de l'avant et le faire. Donc, si startYear de la ligne actuelle n'est pas égal à backslash N, alors je vais aller de l'avant et vérifier que c'est une série télévisée et que ce n'est pas une émission pour adultes. Cela aiderait. Mais, par ailleurs, comment puis-je vérifier cela ici ? Laissez-moi faire l'année. Et comment puis-je convertir row startYear en un entier ? Eh bien, tout dans une feuille de calcul, par définition, ayant été dans une feuille de calcul, ou un fichier TSV ou un fichier CSV est du texte.

Mais start year ressemble à des années, alors quelle fonction Python puis-je utiliser pour convertir réellement du texte qui ressemble à un nombre en un nombre réel ? Oui. On peut faire quelque chose comme ça. Donc, je peux convertir l'année en int, et maintenant je peux dire, si l'année est supérieure ou égale à 1970, maintenant je vais aller de l'avant et faire ces lignes à la place.

Maintenant, il existe une opportunité, bien sûr, pour une meilleure conception, car une fois que votre code commence à faire cela, vous avez fait quelque chose de sous-optimal, n'est-ce pas ? Cela ne va pas bien se terminer si tout mon code commence à s'enrouler. Je pourrais donc nettoyer un peu la logique, mais allons-y et exécutons-le juste une fois de plus. Cette fois, en changeant cela en shows1.CSV pour que nous puissions voir des sorties un peu différentes. Laissez-moi aller de l'avant et exécuter Python import.py. Hein, erreur de syntaxe, erreur Unicode, codec -- c'est bizarre. Mais c'est parce que les barres obliques inverses, rappelons-le, en C et Python, ont une signification particulière. Donc, lorsque vous faites quelque chose comme ceci, barre oblique inverse N majuscule, même si ce n'est pas un n minuscule, une barre oblique inverse, rappelons-le, est le caractère d'échappement en C et Python. C'est donc comme dire à Python, c'est un caractère spécial. Mais ce n'est pas le cas. Et nous n'avons jamais vraiment eu l'occasion de faire cela, mais comment pensez-vous que nous pourrions générer une barre oblique inverse littérale avant une majuscule N ?

Oui. Il s'avère que la solution à ce problème, généralement, quelle que soit la langue, est que si vous voulez un caractère littéral, pas un caractère d'échappement, vous en mettez littéralement un autre avant. Donc, même si cela semble un peu funky maintenant, cette barre oblique inverse barre oblique inverse majuscule N signifiera littéralement barre oblique inverse N.

Très bien. Alors maintenant, laissez-moi aller de l'avant et exécuter cela sur import.py. Cette fois, j'espère réellement générer un nouveau fichier appelé shows1.csv qui contient encore moins de données qui vont réellement contenir mes émissions, mais seulement un sous-ensemble d'entre elles. Et continuons à sortir le gâteau du four de cette façon. C'est ce que j'obtiens maintenant. Donc, si je charge réellement le CSV, shows1.csv, dans Google Spreadsheet, simplement parce qu'il est assez facile de regarder à la fenêtre en noir et blanc, vous pouvez maintenant voir que je n'obtiens apparemment que des émissions de 1970 et après. Et en effet, si je les triais, je ne verrais pas de barre oblique inverse N. J'aurais jeté tout ce qui ne répond pas à ce critère.

Eh bien, laissez-moi aller de l'avant et faire une dernière chose ici. Je vais aller de l'avant et apporter un changement de plus. Et d'abord, améliorons la conception ici. Cette indentation est le résultat de mes questions encore et encore, et d'indenter si et seulement si ces choses sont vraies. Mais notez que vous pouvez commencer à inverser votre logique ici, n'est-ce pas ? Au lieu de dire si l'année de début n'est pas égale à backslash N, et si je fais simplement ceci et dis continuer ? Je peux ensuite supprimer l'indentation de ceci, car si vous ne l'avez jamais utilisé auparavant en Python et en C, si vous dites continuer dans une boucle, cela ne va pas continuer là-bas, ça va continuer à [WHOOSH] recommencez la boucle. Ainsi, grâce à cette logique, nous pouvons réellement continuer à nous enrouler encore et encore. Et ici aussi, on pourrait dire, si l'année est inférieure à 1970, je peux continuer, ce qui me permettrait alors de supprimer l'indentation de cela également. Il existe donc des solutions, en termes de conception, pour éviter réellement cette indentation infinie.

Très bien. Allons-y et faisons une dernière version. Ensuite, je vais aller de l'avant et sortir du four dans un -- tout prêt. Donc, la dernière chose que je n'ai pas chargée avant était ceci. Supposons que je veuille charger dans le fichier CSV tous les genres associés à l'émission. On dirait que toutes ces émissions ont un ou plusieurs genres, tout comme on vous a demandé vos émissions préférées. Et donc maintenant, nous avons un fichier CSV avec tconst, primary titles, start year et genres, où genre est lui-même une liste séparée par des virgules.

Mais il y a un problème fondamental ici. Même si j'ai toutes ces données ici, le mieux que je puisse faire est un programme comme celui-ci. Laissez-moi aller de l'avant et rechercher, par exemple, ce qui suit. Laissez-moi aller de l'avant et récupérer un fichier très rapidement. Laissez-moi aller de l'avant et prendre une copie de shows2.csv et écrire un dernier programme ici. Si je veux aller de l'avant maintenant et rechercher cet ensemble de données très volumineux, toujours, dans shows2.csv, eh bien, laissez-moi aller de l'avant et le faire. Importer CSV.

Laissez-moi aller de l'avant maintenant et demander un titre à l'utilisateur. Je pourrais utiliser la fonction get string de CS50, mais ce n'est plus vraiment nécessaire maintenant que nous avons la fonction titre -- la fonction input, rappelons-le. Je vais donc simplement l'utiliser. Et puis je vais aller de l'avant et ouvrir shows2.csv en mode lecture seule. Et je vais appeler ça mon fichier. Ensuite