D'accord, travailler avec des variables uniques est assez amusant. Mais que faire si nous voulons travailler avec beaucoup de variables sans avoir plusieurs noms différents dans notre code? Dans ce cas, les tableaux seront vraiment utiles. Les tableaux sont une structure de données fondamentale pour n'importe quel langage de programmation que vous utiliserez. Et ils sont vraiment, vraiment utiles, en particulier, comme nous le verrons, dans CS50.

Nous utilisons des tableaux pour contenir des valeurs du même type de données à des emplacements de mémoire contigus. Autrement dit, c'est une façon de regrouper un tas d'entiers ensemble en mémoire ou un tas de caractères ou de flottants en mémoire très proches les uns des autres et de travailler avec eux sans avoir à donner à chacun un nom unique, ce qui peut devenir fastidieux après un certain temps.

Une façon de comprendre les tableaux est de les imaginer comme des boîtes alignées côte à côte qui peuvent stocker des valeurs et des données. Il est important de savoir que chaque boîte dans le tableau a la même taille, ce qui signifie que la quantité d'information que chaque boîte stocke est la même. Chacune de ces boîtes dans le tableau est considérée comme un élément du tableau, et ces éléments, ces boîtes, ne peuvent stocker que des données du même type. Si vous créez un tableau d'entiers, les boîtes du tableau, les éléments du tableau, ne pourront stocker que des nombres entiers. Si le tableau est constitué de caractères, les éléments du tableau ne pourront stocker que des caractères. Enfin, il est important de savoir que nous pouvons accéder aux éléments du tableau à partir de leurs indices. Vous vous souvenez que j'ai dit que les tableaux ressemblent à des boîtes placées les unes à côté des autres ? Cela signifie que dans la mémoire de l'ordinateur, les éléments du tableau sont littéralement placés côte à côte, comme des boîtes alignées dans une armoire dans un entrepôt. Et cela nous permet d'énumérer les éléments du tableau en leur attribuant des indices.

En langage C, les éléments d'un tableau sont numérotés à partir de zéro, et non à partir de un. C'est très important. En fait, c'est pour cette raison que nous, ici à CS50, et beaucoup d'autres informaticiens comptons souvent à partir de zéro, en raison de la numérotation des tableaux dans le langage C, qui commence toujours à zéro.

Donc, si un tableau se compose de n éléments, le premier élément de ce tableau sera situé à l'indice zéro et le dernier élément de ce tableau sera situé à l'indice n moins un. Je répète, s'il y a n éléments dans notre tableau, l'indice du premier élément sera zéro et l'indice du dernier élément sera n moins un. Donc, si notre tableau a cinquante éléments, le premier élément sera situé à l'indice zéro et le dernier à l'indice quarante-neuf.

Malheureusement, ou heureusement, selon votre point de vue, le langage C est très indulgent à ce sujet. Il ne vous empêchera pas de dépasser les limites de votre tableau. Vous pourriez accéder à l'élément moins trois (-3) de votre tableau ou au cinquante-neuvième (59e) élément de votre tableau, même si celui-ci ne comporte que 50 éléments. Cela n'empêchera pas votre programme de se compiler, mais à l'exécution, vous pourriez rencontrer une erreur fatale de segmentation si vous commencez à accéder à de la mémoire en dehors des limites de ce que vous avez demandé à votre programme. Donc, soyez prudent.

# LA SYNTAXE D'UN TABLEAU

À quoi ressemble une déclaration de tableau? Comment codons-nous un tableau comme nous codons n'importe quelle autre variable? Il y a trois parties dans une déclaration de tableau: un type, un nom, et une taille. C'est très similaire à une déclaration de variable, qui se compose uniquement d'un type et d'un nom, la taille étant le cas particulier pour un tableau, car nous obtenons plusieurs éléments à la fois.

Le type est le genre de variable que vous voulez que chaque élément du tableau soit. Voulez-vous un tableau d'entiers ? Alors, votre type de donnée doit être int. Voulez-vous qu'il soit un tableau de doubles ou de flottants? Le type de donnée doit être double ou float. Le nom est comment vous souhaitez appeler votre tableau. Comment voulez-vous nommer cette banque géante d'entiers, de flottants, de caractères ou de doubles, ou tout ce que vous avez à disposition? Comment voulez-vous l'appeler ? C'est assez explicite.

Enfin, la taille, qui est indiquée entre crochets, correspond au nombre d'éléments que vous souhaitez que votre tableau contienne. Combien d'entiers voulez-vous? Combien de flottants voulez-vous?

Donc, par exemple, int notes_des_etudiants 40. Cela déclare un tableau appelé "notes_des_etudiants", qui contient 40 entiers. C'est assez explicite, j'espère. Voici un autre exemple: double prix_des_menus 8. Cela crée un tableau appelé "prix_des_menus", qui contient de la place en mémoire pour huit doubles.

Si vous pensez à chaque élément d'un tableau de type "type de données", par exemple un élément unique d'un tableau de type int, de la même manière que vous penseriez à n'importe quelle autre variable de type int, toutes les opérations familières que nous avons discutées précédemment dans la vidéo sur les opérations auront du sens. Ici, nous pourrions déclarer un tableau de Booléens appelé "Table_de_vérité", qui contient de la place pour 10 Booléens.

Et puis, tout comme nous pourrions attribuer une valeur à n'importe quelle autre variable de type Booléen, nous pourrions dire quelque chose comme Table_de_vérité[2], qui est comment nous indiquons quel élément du tableau de vérité? Le troisième élément de la table de vérité, car souvenez-vous, nous comptons à partir de 0. Donc, c'est ainsi que nous indiquons le troisième élément de la table de vérité. Table_de_vérité[2] = false, tout comme nous pourrions déclarer ou plutôt attribuer à n'importe quelle variable de type Booléen la valeur false.

Nous pouvons également l'utiliser dans des conditions. if(Table_de_vérité[7] == true), ce qui signifie que, si le huitième élément de Table_de_vérité est vrai, peut-être que nous voulons afficher un message à l'utilisateur, printf("TRUE!\n");.

Cela nous amène à dire Table_de_vérité[10] = true, n'est-ce pas? Eh bien, je peux le faire, mais c'est assez dangereux, car souvenez-vous, nous avons un tableau de 10 booléens. Donc, l'indice le plus élevé que le compilateur nous a donné est 9.

Ce programme va se compiler, mais si quelque chose d'autre en mémoire existe là où nous attendons que Table_de_vérité[10] aille, nous pourrions rencontrer une erreur de segmentation. Nous pourrions nous en sortir, mais en général, c'est assez dangereux. Ce que je fais ici est légal en langage C, mais ce n'est pas forcément la meilleure solution.

Maintenant, lorsque vous déclarez et initialisez un tableau simultanément, il existe en fait une syntaxe spéciale que vous pouvez utiliser pour remplir le tableau avec ses valeurs de départ. Cela peut devenir fastidieux de déclarer un tableau de taille 100, puis de devoir dire, élément 0 égal à ceci ; élément 1 égal à cela ; élément 2 égal à autre chose. Ce n'est pas optimal, non ?

Si c'est un petit tableau, vous pourriez faire quelque chose comme ceci. Bool Table_de_vérité[3] = (accolades) {false, true, true} ;. Cela crée un tableau de taille trois appelé Table_de_vérité, avec les éléments false, true, et true. Et en fait, la syntaxe d'instanciation que j'ai utilisée ici est exactement la même que celle utilisée pour les éléments individuels ci-dessous. Ces deux manières de coder produiraient exactement le même tableau.

De même, nous pourrions itérer sur tous les éléments d'un tableau en utilisant une boucle, ce qui, en fait, est un exercice à faire chez soi fortement recommandé. Comment créer un tableau de 100 entiers, où chaque élément du tableau est son indice? Par exemple, nous avons un tableau de 100 entiers, et dans le premier élément, nous voulons mettre 0. Dans le deuxième élément, nous voulons mettre 1. Dans le troisième élément, nous voulons mettre 2 ; et ainsi de suite. C'est un excellent exercice à faire chez soi.

# OMETTANT LA TAILLE

Ici, il ne semble pas que beaucoup de choses aient changé. Mais remarquez qu'entre les crochets, cette fois, j'ai en fait omis le nombre. Si vous utilisez cette syntaxe spéciale d'instanciation pour créer un tableau, vous n'avez en réalité pas besoin d'indiquer la taille du tableau à l'avance. Le compilateur est assez intelligent pour savoir que vous voulez en fait un tableau de taille 3, car vous avez mis trois éléments à droite du signe égal. Si vous en aviez mis quatre, il vous aurait donné un tableau de vérité de taille quatre ; et ainsi de suite.

# TABLEAUX MULTIDIMENSIONNELS

Les tableaux ne sont pas limités à une seule dimension, ce qui est plutôt cool. Vous pouvez en fait avoir autant de dimensions que vous le souhaitez. Par exemple, si vous voulez créer un plateau pour le jeu Bataille navale, qui, si vous y avez déjà joué, est un jeu qui se joue avec des chevilles sur une grille de 10 par 10, vous pourriez créer un tableau comme ceci: Bool bataille_navale[10][10];.

Vous pouvez alors choisir d'interpréter cela dans votre esprit comme une grille de cellules 10 par 10. Maintenant, en réalité, en mémoire, cela reste vraiment un tableau unidimensionnel de 100 éléments. Et cela s'applique également si vous avez trois, quatre ou cinq dimensions. Il suffit de multiplier tous les indices ou toutes les spécifications de taille ensemble, et vous obtenez un tableau unidimensionnel de cette taille.

Mais en termes d'organisation, de visualisation et de perception humaine, il peut être beaucoup plus facile de travailler avec une grille si vous travaillez sur un jeu comme le morpion ou la bataille navale, ou quelque chose comme ça. C'est une excellente abstraction, au lieu de devoir penser à un plateau de morpion comme une ligne de neuf cases ou à un plateau de bataille navale comme une ligne de 100 cases. Une grille de 10 par 10 ou de 3 par 3 est probablement beaucoup plus facile à percevoir.

# COPIER DES TABLEAUX

Maintenant, quelque chose de très important à propos des tableaux. Nous pouvons traiter chaque élément individuel du tableau comme une variable. Nous avons vu cela plus tôt lorsque nous attribuions la valeur True à certains booléens ou que nous les testions dans des conditions. Mais nous ne pouvons pas traiter les tableaux eux-mêmes comme des variables entières. Nous ne pouvons pas, par exemple, attribuer un tableau à un autre tableau en utilisant l'opérateur d'affectation. Ce n'est pas autorisé en langage C.

Si nous voulons, par exemple—ce que nous ferions dans cet exemple serait de copier un tableau dans un autre. Si nous voulons faire cela, nous devons en réalité utiliser une boucle pour copier chaque élément individuel un par un. Je sais, c'est un peu long.

Donc, par exemple, si nous avions ces quelques lignes de code, est-ce que cela fonctionnerait ? Eh bien, non, cela ne fonctionnerait pas, n'est-ce pas? Parce que nous essayons d'attribuer tableau1 à tableau2. Cela ne va pas fonctionner, car c'est un tableau, et nous venons de décrire que ce n'est pas autorisé en C.

À la place, si nous voulons copier le contenu de tableau1 dans tableau2, ce que nous essayons de faire ici, nous aurions besoin d'une syntaxe comme celle-ci. Nous avons une boucle for qui va de J égal à 0 jusqu'à 5, et nous incrémentons J à chaque itération de la boucle et attribuons les éléments de cette manière. Cela donnerait à tableau2 les valeurs 1, 2, 3, 4, 5, mais nous devons le faire de cette manière lente, élément par élément, au lieu de simplement copier tout le tableau. Dans d'autres langages de programmation, plus modernes, vous pouvez en fait faire cette simple syntaxe avec l'opérateur égal. Mais en C, malheureusement, nous n'avons pas le droit de faire cela.

# PASSER PAR VALEUR ET PAR RÉFÉRENCE

Maintenant, il y a une autre chose que je veux mentionner à propos des tableaux, qui peut être un peu compliquée la première fois que vous travaillez avec eux. Nous avons discuté dans une vidéo à propos de la portée des variables que la plupart des variables en C, lorsqu'elles sont appelées dans des fonctions, sont passées par valeur. Vous vous souvenez de ce que cela signifie de passer quelque chose par valeur? Cela signifie que nous faisons une copie de la variable qui est transmise. La fonction appelée, celle qui reçoit la variable, ne reçoit pas la variable elle-même. Elle obtient sa propre copie locale avec laquelle elle peut travailler.

Les tableaux, bien sûr, ne suivent pas cette règle. Plutôt, ce que nous appelons cela, c'est passer par référence. La fonction appelée reçoit en fait le tableau. Elle ne reçoit pas sa propre copie locale. Et si vous y réfléchissez, cela a du sens. Si les tableaux sont vraiment grands, il faut tellement de temps et d'efforts pour faire une copie d'un tableau de 100, 1 000 ou 10 000 éléments, que cela ne vaut pas la peine pour une fonction de recevoir une copie, de faire un travail avec, puis d’en finir avec la copie; elle n'a plus besoin de l'avoir en mémoire.

Comme les tableaux sont encombrants et lourds, nous les passons simplement par référence. Nous faisons confiance à la fonction pour qu'elle ne casse rien. Donc, elle reçoit réellement le tableau. Elle ne reçoit pas sa propre copie locale.

Alors, que se passe-t-il lorsque la fonction appelée manipule des éléments du tableau? Que se passe-t-il? Pour l'instant, nous allons passer rapidement sur la raison exacte pour laquelle cela se produit, pourquoi les tableaux sont passés par référence et tout le reste par valeur. Mais je vous promets que nous reviendrons plus tard avec une explication dans une autre vidéo.

Voici encore un exercice pour vous avant que nous terminions sur les tableaux. Le bloc de code ici n'est pas particulièrement bien stylé; je tiens à faire cette mise en garde. Il n'y a aucun commentaire, ce qui est une mauvaise pratique. Mais c'est seulement parce que je voulais tout faire tenir à l'écran.

En haut, vous pouvez voir que j'ai deux déclarations de fonction pour définir_tableau et définir_entier. Définir_tableau prend apparemment un tableau de quatre entiers en entrée. Et définir_entier prend apparemment un seul entier en entrée. Mais aucune des deux fonctions n'a de sortie. Le type de retour de chacune est void. Dans la fonction Main, nous avons quelques lignes de code. Nous déclarons une variable entière appelée A et lui assignons la valeur 10. Nous déclarons un tableau de quatre entiers appelé B et assignons les éléments 0, 1, 2 et 3, respectivement. Ensuite, nous appelons définir_entier et définir_tableau. Les définitions de définir_tableau et définir_entier sont en bas.

Encore une fois, je vous pose la question. Qu'est-ce qui sera imprimé à la fin de la fonction Main? Il y a un appel à printf. J'imprime deux entiers. J'imprime le contenu de A et le contenu de B[0]. Mettez la vidéo en pause ici et prenez une minute. Pouvez-vous deviner ce que ce programme imprimera à la fin ? J'espère que si vous vous souvenez de la distinction entre passer par valeur et passer par référence, ce problème n'a pas été trop difficile pour vous. Et la réponse que vous auriez trouvée est celle-ci. Si vous n'êtes pas tout à fait sûr de pourquoi c'est le cas, prenez un moment, revenez en arrière, relisez ce que je viens d'expliquer sur le passage des tableaux par référence par rapport au passage d'autres variables par valeur, et j'espère que cela aura un peu plus de sens.

Je suis Ramon, et ceci est CS50.