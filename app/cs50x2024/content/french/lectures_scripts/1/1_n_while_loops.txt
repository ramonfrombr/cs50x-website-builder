D'accord, seulement quelques comparaisons supplémentaires avant de revenir à l'écriture de code. Qu'en est-il de quelque chose comme ça ? Dans Scratch, nous avons bien sûr appelé cela une boucle : un cycle qui a lieu encore et encore et encore. Et une boucle ainsi peut être implémentée en C, pas tout à fait de la même manière, mais comme cela. Le mot le plus proche du mot « pour toujours » dans Scratch s'avère être le mot « alors que ». Cela suggère en quelque sorte l'idée de faire quelque chose encore et encore. C'est le mot que les humains ont choisi il y a des années. Mais vous ne dites pas seulement « alors que ». Vous ne devez pas seulement dire ce que vous voulez faire pour toujours, mais vous devez répondre à une expression booléenne. Par conséquent, en C, si vous voulez implémenter une boucle, vous devez être capable de dire littéralement « alors que quelque chose est vrai ». Vous devez poser une question dont la réponse est oui, vrai ou un. Tous cela équivaut à un programmeur. Donc, quel est un exemple d'expression, une expression booléenne, qui est toujours vraie, si mon objectif est de faire quelque chose pour toujours ? AUDIENCE : Cinq est égal à cinq. DAVID MALAN : Est-ce que cinq est égal à cinq, d'accord. Je pourrais dire que quatre est égal à quatre. Je pourrais dire que deux est supérieur à un. Je pourrais dire qu'un est inférieur à deux. Je pourrais trouver un nombre infini d'expressions booléennes qui sont simplement logiquement toujours vraies. Mais la manière la plus simple est simplement de dire vrai littéralement. Donc, c'est un peu précipité, mais il s'agit peut-être de la question la plus simple que vous puissiez poser, car vrai, par définition, s'avère être toujours vrai, tout comme faux est toujours faux. Et je peux donc simplement dire littéralement « alors que vrai » afin d'induire une boucle infinie, pour ainsi dire ; qui fait quelque chose pour toujours. D'accord, essayons un autre type de construction de boucle. Il s'agit d'une boucle qui a fait quelque chose 50 fois. Celle-ci, maintenant nous devons être un peu plus intelligents, et nous devons en quelque sorte relier des choses. Donc, si je veux faire quelque chose 50 fois, voici une manière de procéder. Pourquoi ne pas me donner une variable et l'appeler compteur. Mais je pourrais l'appeler comme je veux et l'initialiser à zéro. Alors, laissez-moi y aller : vous savez quoi ? Compteur est en fait assez verbeux. La plupart des programmeurs, lorsqu'ils comptent simplement, utilisent par convention simplement la lettre i, i pour entier. Mais vous pouvez l'appeler comme vous voulez. Je vais donc l'appeler int i est égal à zéro. Ensuite, je vais y aller et faire ce qui suit. Alors que l'expression suivante est vraie, laissez-moi simplement poser une question encore et encore. Alors qu'i est inférieur à 50, laissez-moi y aller et dire, bonjour le monde. Je peux donc simplement imprimer bonjour le monde. Mais je n'ai pas tout à fait fini de construire cette logique. J'ai initialisé une variable à zéro. Je vais, encore et encore, poser la question, est-ce qu'i est inférieur à 50 ? Mais pour que cela fonctionne logiquement, quel autre élément logique dois-je ajouter au code ? Oui ? AUDIENCE : Vous devez incrémenter i de un. DAVID MALAN : Oui, je dois incrémenter i, non ? Donc, même si vous ne vous souvenez pas (et c'est normal), de la syntaxe pour le faire, vous avez besoin d'une ligne de code comme celle-ci. Ainsi, logiquement, vous allez faire ce qui suit : définissez i égal à zéro, puis faites ce qui suit alors qu'i est inférieur à 50. Eh bien, est-ce qu'i est inférieur à 50 ? Évidemment, car 0 est inférieur à 50. Vous imprimez donc bonjour le monde. Et ensuite, comme vous le proposez, nous devons incrémenter i. Donc, maintenant i est égal à i plus 1. Donc, à ce stade de l'histoire, i est égal à 1. Et maintenant, la manière dont le code fonctionne, tout comme notre pseudo-code la semaine dernière, est que vous revenez en quelque sorte implicitement à cette ligne. La semaine dernière, dans le pseudo-code, j'ai littéralement dit, revenez à la ligne 3. Ici, cela se produit automatiquement par nature de la manière dont C interprète ces lignes de code dans ces accolades. Et je peux en fait simplifier cela comme suit. Je peux dire i plus plus. Maintenant, ce n'est pas aussi joli que Scratch, où vous dites simplement répétez ce qui suit 50 fois. Mais en utilisant les principes de la semaine dernière maintenant traduits en C, vous pouvez en quelque sorte relier votre propre logique qui fait quelque chose un certain nombre de fois.