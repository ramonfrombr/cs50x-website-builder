So let me go ahead and open a file called import .py. And I'm going to go ahead and import the CSV module, as always, and I'm going to go ahead and open this file, which is called title.basics.tsv in read-only mode, and I'm going to call this variable titles. What am I next going to do? Let me myself a reader using csv.DictReader, as before, reading in those titles. But csv.DictReader feels like the wrong reader. Why? Just to be clear. 

Yeah, I mean, maybe I want TSV. But it turns out TSV doesn't exist. So even though I might be inclined, for instance, to change this to a T and this to a T, the CSV module does enough for me, but I need to tell it that I want to use a different delimiter. Instead of the default, which looks like this, I can actually override that and say, you know what? Use a tab. And just like backslash n in C and in Python, it's a new line. Backslash t in both languages is a tab character. 

All right, so once I've done this, let me go ahead and open up, now-- let me go ahead and open up shows0.csv. My goal in life now is to make this file a lot more manageable for myself. I want to take a 500megabyte file and extract only the TV shows therein. Moreover, how about only the TV shows from 1970 onward? We won't go even further back than that. 

So let me go ahead and open up, in write mode, a file called show0.csv. And I'm just going to call that variable shows. Then I'm going to go ahead and give myself a writer. And you might recall using this in the past. This is simply going to give me a variable called writer, via which I can write to a new file. Because again, the goal is to read this file and write to this file a subset of the data therein. 

So let me go ahead and write one row first. Write a row, passing in a list of values, specifically tconst, which is the title-- which is the ID field; primaryTitle, which is the title field; startYear, which is the year field; and genres, was one more fields that I mentioned earlier. So my goal is to export only those four columns that I care about for now. 

So I'm going to go ahead and do this. For each row in my reader, I'm going to go ahead and say if that row's titleType == tvSeries, which, recall, The Crown was an example of, then I'm going to go ahead and write to the writer-- whoops-- writer.writeRow, a list containing what? The row's tconst value, the row's primary title value, the row-- whoops-- the row's start year, and lastly, the row's-- [CHUCKLES] the row's genres. 

So what am I doing here, just to be clear? So what I have done is I've first written out-- once and only once-- literally these values, because I want headers in the first line of my file. After that, for each row in the reader, which is currently iterating over this file in read-only mode, I want to print out the current row's tconst, current row's primary title, the current row's start year, and the current row genres. But notice, I'm ignoring movies and shorts and documentaries and bunches of other values as well. 

And you know what? Just for good measure, let's shrink this a little bit. And row, how about, is adult == "0", for today's purposes? So that'll filter the list further. If you'd like to flip that later, that's fine. So let me go ahead and do Python 3, for version 3 on my Mac-- actually, no, let's do Python of import.py, all right? I'm going to cross my fingers here. Hopefully the file is working, working, working. But it's taking a decent amount of time. Like, this is how much time it takes, apparently, to process over millions of rows of data. Still running. Still running. But the goal, again, is to shrink the amount of data I have to ultimately care about so that we can actually search it much more effectively.