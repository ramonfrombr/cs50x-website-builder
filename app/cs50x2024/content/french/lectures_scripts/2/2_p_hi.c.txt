Alors, que pouvons-nous faire avec ces informations ? Eh bien, allons-y, débarrassons-nous du matériel et faisons abstraction, en quelque sorte, comme nous continuons à le faire, et voyons si nous zoomons ici, comment l'ordinateur, la semaine dernière et cette semaine se terminant toujours ici, stocke les informations dans les programmes que vous écrivez. Supposons par exemple que nous ayons un programme comme celui-ci, avec seulement trois caractères. Je vais le créer dans un fichier appelé, disons, hi dot c. Et je vais inclure la norme Io dot h, int main void-- learning.

Maintenant, ici, je vais mettre ces trois lignes de code. Alors, donnez-moi un char appelé c1 arbitrairement et définissez-le égal à un H majuscule. Donnez-moi un autre appelé c2, définissez-le égal à I majuscule. Donnez-moi un troisième appelé c3, et définissez-le égal au point d'exclamation. Vous remarquerez maintenant un détail que je n'ai pas encore souligné, je pense. Quels types de ponctuation est-ce que j'utilise clairement ici ? Donc, des guillemets simples ou des apostrophes ici. Les guillemets simples en C sont nécessaires pour les chars. Les chars ou les caractères uniques, juste un octet. Chaque fois que vous voulez les coder en dur dans un programme comme celui-ci, comme je l'ai fait ici, utilisez des guillemets simples. Bien sûr, pour les chaînes, nous avons utilisé des guillemets doubles. Pourquoi ? Juste parce que. C exige que nous les distinguions. Alors laissez-moi faire quelque chose d'un peu idiot ici. Maintenant que j'ai trois variables, laissez-moi les imprimer toutes. Quel est le code de format que je peux imprimer ? Je peux utiliser pour imprimer un char ? Ouais, un pourcentage …

PUBLIC : [INAUDIBLE]

DAVID MALAN : Pourcentage c pour char, donc pourcentage c, et j'en veux trois. Je vais donc les imprimer toutes les trois à la fois, suivies d'une nouvelle ligne. Et puis si je veux imprimer c1 en premier, c2, c3, c'est la syntaxe avec printf pour insérer trois espaces réservés suivis de trois valeurs, respectivement de gauche à droite, et jespère qu'elle va imprimer probablement hi sur l'écran suivi d'une nouvelle ligne. Alors laissez-moi enregistrer le fichier. Laissez-moi faire make hi. OK, pas d'erreurs, ce qui est bien. Laissez-moi faire dot slash hi, et en effet je vois hi point d'exclamation, mais avec un espace entre chaque caractère. Mais vous savez quoi ? hi point d'exclamation sont en effet des chars, mais qu'est-ce qu'un char ou un caractère ? Qu'est-ce qu'un caractère ASCII sous le capot ?

PUBLIC : [INAUDIBLE]

DAVID MALAN : C'est finalement binaire. Tout est binaire. Et quelle est l'étape intermédiaire, dans un certain sens ?

PUBLIC : [INAUDIBLE]

DAVID MALAN : C'est juste un nombre, un entier. Grâce à ASCII et Unicode dans la semaine zéro, il existe une correspondance entre les caractères et les nombres. Alors, comment imprimer des nombres ? Quel code de format dois-je utiliser pour printf ?

PUBLIC : [INAUDIBLE]

DAVID MALAN : Pourcentage i, pour entier. Alors, supposons que je veuille réellement voir ces valeurs ? Remarquez ce que je peux faire. Je peux dire à l'ordinateur, vous savez quoi ? Même si c1 est un char, allez-y, traitez-le comme un entier. Et je peux littéralement écrire int entre parenthèses avant la variable, ce qu'on appelle le casting, C-A-S-T, qui est juste un verbe décrivant l'acte de convertir un type de données en un autre afin que je puisse réellement voir ces nombres. Alors laissez-moi enregistrer le fichier. Laissez-moi avancer et faire à nouveau make hi. Cela semble bien fonctionner. Dot slash hi, et maintenant ce vieux familier 72, 73, 33.

Et franchement, je n'ai pas besoin d'être aussi pédant ici. Franchement, clang est assez intelligent pour savoir que si je lui passe un char, mais que je lui demande de le formater comme un int, il va implicitement, pas explicitement, le caster pour moi. Donc, si je lance à nouveau make hi et que je fais dot slash hi, je vais voir exactement la même chose. Donc, cette compréhension de ce qui se passe sous le capot peut me permettre en quelque sorte de bricoler maintenant et de jouer avec ce qui se passe à l'intérieur de la mémoire de mon ordinateur. Mais voyons maintenant cela de manière plus visuelle.

Si c'est la mémoire de mon ordinateur vraiment agrandie, de sorte qu'il y ait environ un milliard de carrés à ma disposition et que c'est zéro, c'est un, c'est deux. Supposons que j'ai un programme avec trois variables : c1, c2 et c3 : ce que l'ordinateur va faire est de mettre le h dans l'une de ces cases. Il va mettre le i dans une autre case, et il va mettre le point d'exclamation dans une troisième case, et d'une manière ou d'une autre, il va les étiqueter avec les noms des variables. Ça va en quelque sorte noter comme avec un crayon virtuel, c'est c1, c'est c2, c'est c3. Mais c'est le point d'exclamation H-I qui est réellement stocké à cet endroit.

Mais bien sûr, ce n'est pas juste un char. C'est vraiment techniquement un nombre. Donc, ce qui se passe réellement à l'intérieur de la mémoire de mon ordinateur, c'est que 72, 73 et 33 sont stockés. Mais quelqu'un a dit plus tôt que c'était en fait binaire. Voici donc ce qui se trouve réellement sous le capot. Ces zéros et uns sont en quelque sorte implémentés avec des transistors ou des ampoules ou quelle que soit la technologie, mais ils ne stockent qu'un motif de zéros et de uns. Et j'ai fait les calculs avant le cours. Cela représente bien 72 en décimal, 73 et 33.

Mais ici aussi, nous arrivons à un détail d'implémentation de bas niveau dont nous n'avons généralement pas à nous soucier. L'abstraction, par semaine zéro, est cette belle chose parce que nous pourrions simplement, bof, régler tout cela et y penser à un niveau supérieur que nous voulons, que ce soit décimal ou que ce soit des caractères ASCII réels. Mais c'est tout ce qui se passe sous le capot. Oui ?

PUBLIC : [INAUDIBLE]

DAVID MALAN : Vraiment bonne question. Si vous avez déclaré trois variables comme des entiers et que vous y avez stocké 72, 73, 33 et que vous avez essayé de les imprimer avec le pourcentage c, oui, vous pourriez aussi forcer ce comportement, et littéralement faire le contraire. À ce moment-là, vous devez savoir quels sont les codes ASCII : 72, 73, 33. Et surtout, les programmeurs ne se soucient pas de ça. Tout ce qu'ils savent, c'est qu'il y a une cartographie en dessous du capot, mais absolument.