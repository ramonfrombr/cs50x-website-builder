All right, so let's go ahead now and transition to a few other features that we can do, as well-- namely, implementing the same program that I just had. Let me go ahead and close this file and create a new one called, say, string.c, because I'm now experimenting with strings. And I'm going to start as before-- include stdio.h int main void. And then I'm going to go ahead here and say string answer get get_string, quote unquote, what's your name, question mark, backslash n, semicolon. And as an aside, everything I type on the keyboard today we will post on the course's website after. So no need to type down every little character if you'd prefer not. And then I'm going to go ahead and say printf, quote unquote, hello answer. Not answer, because we claimed that that was bad. That would literally say answer. I want to do a placeholder, percent s. And now backslash n, comma, answer, semicolon. So I think I have transcribed the code from the slide into my programming environment now in a file called string.c. So let me go ahead and zoom out. And if I want to compile this program, convert it from source code to machine code, what command can I type down here? So Clang. So string.c. But that's going to give me a program, by default, called a.out, which is just very non-helpful. So let me go ahead and say -o string, just so that my program is called string. But I could call it anything I want. I could call it program two, if I prefer. So let me go ahead and hit Enter. And oh my god, there are more errors than there are lines of code, which is a little worrisome. And this tier two is where you should take some comfort that that just means the computer's gotten confused, right? You're not that bad at programming that you generate more errors than lines of code you've written yourself. It's just that the computer got really confused at some point, and it kind of starts tripping over itself, so to speak, conceptually. It doesn't know where the error is, so it starts misinterpreting correct code as incorrect code. So the place to start is always with the very first error message. So you'll notice that I already scrolled all the way up to the command that I typed, which was right here, as I've highlighted. Focus on the first error you see, and maybe the others are just phantom errors, confusion that arose instead. So let me go ahead and zoom in on this part of the screen and see if we can't diagnose this issue. The command I ran was Clang -o string string.c. That just means my input is my source code in string.c. I want my output to be machine code in a file called string. All right, string.c line 5 is where the error begins, so that seems to be a familiar location. Use of undeclared identifier string. Did you mean-- anticipation-- stdin? No, I didn't. I meant string in this case. So here, too, the computer's gotten confused, and even it's green helpful message is actually not helpful. No, I want a string. I don't want standard n. But the reason for this is that technically, at least this point in the story, there is no such thing as a string, S-T-R-I-N-G in C. That's actually a training wheel of sorts that we're going to use for just a couple of weeks until, to your question earlier, we're going to show what's really going on underneath the hood of the computer, so to speak, when it comes to implementing a string. So string is something that the CS50 course provides to you in a file called CS50.h. So just as there's a file called standard I/O-- where I/O just means input/output, like printing and getting input. Just as there's a file called stdio.h, in which printf was invented, all of these other functions that I might use in this program, like get_string, happen to be stored in a file called CS50.h. So my problem arose a moment ago when compiling this code, because the computer had no idea what a string is. And it has no idea-- we'll see what the function get_string is. So let me go ahead and recompile this now. I'm going to go ahead and do Clang -o string string.c and zoom in. Here we go. Enter. OK, progress. Still a bug. There's still a mistake, because red can't possibly mean anything good in this context. And indeed, it's an error. But it's many fewer errors. So there's the last piece of commands that we need to introduce now. Notice what the error message is saying. So after I run Clang -o string string.c, there's still a problem in my function main. What is the problem? Undefined reference to get_string.