Disons simplement que c'est le moyen correct d'échanger deux valeurs. Mais le détail clé ici était que Farrah avait accès à une variable temporaire. Donc, on pourrait penser que cette idée, aussi simple qu'elle soit en réalité, se traduirait très naturellement au code aussi. Mais il s'avère que ce n'est pas nécessairement le cas.

Donc, il s'avère que si nous voulions échanger deux variables, vous pourriez implémenter une fonction appelée swap et prendre simplement deux entiers, a et b, dont le but est de faire l'échange. Le violet devient vert, le vert devient violet, tout comme a devient b, b devient a. Et on pourrait penser qu'il nous suffit d'une variable temporaire à l'intérieur de ce code pour que cela se produise.

Je dirais donc que l'équivalent de ce que Farrah a fait en personne, en code C, pourrait ressembler à ceci. Donnez-moi une variable temporaire appelée temp - ou tout ce que vous voulez - stockez-y, a - tout comme elle a d'abord stocké l'une des couleurs dans le verre temporaire, le violet - puis allez-y et modifiez la valeur de a pour qu'elle soit égale à la valeur de b - parce que vous avez déjà conservé une copie de a dans une variable temporaire - puis enfin, stockez dans b ce qui est dans temp. C'est donc l'équivalent en code de ce que Farrah a fait en utilisant ces liquides colorés.

Malheureusement, ce n'est pas aussi simple qu'il n'y paraît. Je vais aller de l'avant et ouvrir, par exemple, un programme que j'ai écrit à l'avance ici aussi, appelé - intentionnellement - no swap. Même si vous aimeriez penser que c'est exactement ce qu'il fait.

Notez donc que dans ce code, nous avons -- y compris l'entrée/sortie standard point h -- nous avons un prototype pour la fonction que je viens de proposer de créer, swap, qui prend deux entiers a et b. Voici ma fonction principale. Et je vais juste initialiser arbitrairement x à 1 et y à 2, tout comme j'ai initialisé un verre en violet et un verre en vert. Ensuite, juste pour que nous puissions voir ce qui se passe à l'intérieur de notre code, je vais simplement imprimer x est tel ou tel, y est tel ou tel - imprimer x et y - puis je vais appeler cette fonction swap, en échangeant x et y. Et ensuite, je vais littéralement imprimer la même phrase. Mais j'espère que cela va dire le contraire la deuxième fois si x et y sont effectivement échangés.

Alors, comment est-ce que j'implémente swap ? Eh bien, il semble que ce soit, avec ce même code, en utilisant une variable temporaire -- ou un verre temporaire, tout comme Farrah l'a fait pour les deux liquides. Malheureusement, lorsque je vais de l'avant et que j'exécute ce programme, no swap - et son nom seul est un peu un spoiler - si je vais de l'avant et que j'exécute point slash no swap avec x et y codés en dur à 1 et 2 respectivement, vous verrez qu'il s'exécute et dit, x est 1, y est 2, x est 1, y est 2, échouant ainsi clairement à échanger.

Mais si vous êtes d'accord avec moi, cela semble être correct. Je n'ai eu aucune erreur de compilation. Pourtant, cette ligne de code, qui utilise swap, semble n'avoir aucun effet. Alors, quelle pourrait être l'intuition ou l'intuition ici pour expliquer pourquoi ce programme n'échange en effet pas ?

PUBLIC : Donc, quand il prend le [INAUDIBLE] dans le -- quand il prend le [INAUDIBLE] toute nouvelle variable qui [INAUDIBLE].

DAVID J. MALAN : Oui, exactement. Lorsque vous passez des entrées à une fonction, vous passez effectivement des copies de vos propres valeurs à cette fonction. Donc, quand vous avez deux variables, x et y -- initialisées à 1 et 2 -- oui, vous les passez en entrée à swap. Mais swap ne récupère pas réellement x et y, il récupère des copies de x et y. Et selon son prototype, les appelle a et b, respectivement.

Il s'avère donc que cette fonction swap fonctionne réellement. Elle échange a et b. Mais elle n'échange pas x et y parce que ce sont des copies. Cela semble maintenant particulièrement inquiétant dans la mesure où je n'arrive pas à implémenter une fonction appelée swap qui puisse même implémenter le tri à bulles ou le tri par sélection. Et franchement, vous avez peut-être rencontré ce problème vous-même si vous essayiez de l'implémenter pour l'un de vos algorithmes de vote. Si vous deviez faire un échange, si vous aviez une fonction d'assistance, vous auriez peut-être dû y penser d'une manière quelque peu différente.

Alors, quelle est l'explication à tout cela ? Eh bien, cette version de swap ne fonctionne pas réellement parce que, encore une fois, si nous revenons aux premiers principes, allons à l'intérieur de la mémoire de l'ordinateur et considérons que notre mémoire n'est qu'une grille d'octets, de haut en bas, de gauche à droite. Que se passe-t-il réellement ?

Eh bien, il s'avère que tout ce temps que nous avons utilisé C, mon ordinateur n'a pas juste mis arbitrairement des choses en mémoire ici, ici, ici. Il utilise en fait la mémoire de votre ordinateur de manière méthodique. Certains types de données descendent ici. Certains types de données montent ici, et ainsi de suite.

Alors, quelle est cette méthodologie ? Eh bien, si nous la considérons abstraitement comme un grand rectangle, il s'avère que si c'est la mémoire de votre ordinateur, tout en haut de celle-ci, conceptuellement, vont tous les 0 et 1 que Clang a compilés pour vous. Le code dit machine, est littéralement chargé dans la RAM de votre ordinateur lorsque vous exécutez point slash something, ou sur un Mac ou un PC, lorsque vous double-cliquez sur une icône, ces 0 et 1 - le code compilé - sont chargés dans la mémoire de votre ordinateur ici - disons - et il peut prendre autant d'espace pour un petit programme, autant d'espace pour un grand programme.

En dessous, si votre programme utilise des variables globales ou tout autre type de données, celles-ci se trouveront juste en dessous, pour ainsi dire, du code machine dans la mémoire de l'ordinateur. Pourquoi ? Tout simplement parce que les humains avaient besoin de décider, lors de la mise en œuvre des compilateurs, où placer des choses dans la mémoire de l'ordinateur.

En dessous se trouve un morceau spécial de mémoire appelé le tas. Et Valgrind lui a donné -- un avant-goût de ce mot il y a un instant. Le tas est un gros morceau de mémoire dans lequel vous pouvez allouer de la mémoire. Et en fait, si vous appelez malloc -- comme je l'ai fait une fois auparavant -- cette mémoire proviendra de cette région de la mémoire de l'ordinateur, en dessous des variables globales, en dessous du code machine, parce que c'est là que les concepteurs de Clang et de compilateur ont décidé d'extraire la mémoire.

Donc, chaque fois que vous appelez malloc, vous découpez de plus en plus d'octets pour que votre programme puisse les utiliser. Et ce tas grandit, conceptuellement, vers le bas. Plus vous utilisez de mémoire, plus elle descend, descend, descend dans cette interprétation de l'artiste.

Cependant, il existe une autre partie de la mémoire ici en dessous qui est utilisée à des fins très différentes. Chaque fois que vous appelez une fonction dans votre programme, il s'avère que ces fonctions variables locales finissent par aller au bas de la mémoire de votre ordinateur sur ce qu'on appelle une pile. Donc, si vous avez main, la fonction par défaut, et qu'elle a un ou plusieurs arguments, ou une ou plusieurs variables locales, ces variables descendent simplement ici, conceptuellement, en mémoire. Et si vous appelez une fonction comme swap, ou toute autre chose, elle ne fait que continuer à utiliser de plus en plus de mémoire au-dessus de cela.

Le tas est donc l'endroit où malloc vous permet d'obtenir des octets. Et la pile est l'endroit où vos variables locales vont lorsque les fonctions sont appelées, de bas en haut.

Voyons cela en action ici. Si nous considérons la pile seule dans le contexte de l'échange infructueux de variables, que se passe-t-il réellement avec un code comme celui-ci ? Eh bien, au bas de ma mémoire lorsque j'appelle main, on me donne -- par nature du fonctionnement des programmes C lorsqu'ils sont compilés -- une tranche de mémoire appelée cadre, un cadre de pile. Et ce n'est qu'un certain nombre d'octets qui stockent peut-être argv, argc, il stocke x et y, mes variables locales.

Toutes les variables que j'ai dans main sont stockées dans ce bloc de mémoire ici. Si main appelle une fonction, comme cette fonction swap, cette fonction obtient son propre cadre de mémoire, sa propre tranche de mémoire, qui, conceptuellement, est au-dessus de main. Swap