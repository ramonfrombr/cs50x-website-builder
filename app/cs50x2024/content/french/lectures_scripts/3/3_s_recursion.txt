Alors, revenons à la semaine 0, où tout était très simple à l'époque. Et nous cherchions juste Mike Smith dans un annuaire téléphonique. Et nous avions ce pseudo-code ici. Cela contenait un exemple d'une construction de programmation que, à l'époque, nous avions mise en évidence et appelée une boucle, revenez à la ligne 3 afin de pouvoir faire quelque chose encore et encore.

Voici un exemple de ce qu'on appelle l'itération, un mot que vous avez peut-être entendu dire à votre [? TF ?] ou à quelqu'un d'autre, où itérer signifie simplement faire une boucle encore et encore. Et c'est très simple. Et nous pourrions implémenter cela dans le code si nous le souhaitions. Mais là, il y a une opportunité de concevoir cet algorithme non seulement différemment, mais peut-être mieux, n'est-ce pas ?

Après tout, laissez-moi effacer cette ligne et me débarrasser de cette itération et voir si je ne peux pas résoudre le problème plus élégamment, si vous voulez, une meilleure conception, si vous voulez, même si cela impliquera invariablement certains compromis. Ici, avec l'ouverture au milieu de la gauche-- ici, avec l'ouverture au milieu de la moitié gauche du livre et ici, ouverture au milieu de la moitié droite du livre, l'intérêt d'ouvrir au milieu à gauche ou au milieu à droite était juste de chercher à nouveau Mike Smith, mais dans la moitié de l'annuaire téléphonique, à gauche ou à droite. Le détail clé étant que c'est la moitié de la taille de l'annuaire téléphonique entier.

Mais l'algorithme est vraiment le même. Alors en fait, pourquoi ne pas simplifier notre pseudo-code et ne pas entrer dans la logistique, du genre, oh, retournez à cette ligne puis faites-le encore et encore. Non, disons simplement : cherchez dans la moitié gauche du livre ou cherchez dans la moitié droite du livre. Et en fait, resserrons le code et faisons-en moins de lignes afin que nous n'ayons même pas besoin d'entrer dans les numéros de ligne spécifiques. Nous pouvons simplement nous dire ce qu'il faut faire.

Maintenant, surlignées en jaune ici se trouvent ces deux nouvelles lignes. Et cela pourrait ressembler à un argument cyclique. Eh bien, comment cherchez-vous Mike Smith ? Eh bien, vous cherchez simplement Mike Smith. Mais le détail clé ici est que je ne vous dis pas simplement de faire la même chose sans fin. Je vous dis, si vous voulez chercher Mike Smith dans un annuaire téléphonique de cette taille, mm-mm. Recherchez Mike Smith dans un annuaire téléphonique de cette taille. Et puis l'étape suivante de cet algorithme devient : cherchez-le dans un annuaire téléphonique de cette taille, cette taille, lorsque vous continuez à réduire le problème de moitié.

Voici donc un exemple d'une technique de programmation appelée récursion, par laquelle vous implémentez un programme ou un algorithme ou un code qui, en un sens, s'appelle lui-même. Si ce que nous regardons ici sur le tableau est une fonction appelée recherche, une fonction est récursive si elle référence littéralement son propre nom dans son propre code. Et c'est là que votre esprit commence peut-être à fléchir. Et nous verrons cela plus concrètement.

Mais la récursion, c'est quand une fonction s'appelle elle-même. Donc, s'il s'agit d'une fonction implémentant la recherche et surlignées en jaune sont deux lignes de code qui disent chercher à nouveau mais sur une plus petite partie du problème, c'est de la récursion, quelque chose qui se reproduit encore et encore.