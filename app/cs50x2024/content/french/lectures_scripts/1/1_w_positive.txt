Permettez-moi de vous présenter un exemple qui s'appuie sur cette même idée. Dans positive.c, nous avons cet exemple ici qui rend tout cela plus clair. Voici donc un programme qui utilise nos deux bibliothèques, CS50 dans les E/S standard. Il s'avère que la bibliothèque CS50 n'est pas fournie avec une fonction appelée get_positive_int. Il est fourni avec get_int. Et vous pouvez imaginer des programmes où vous voulez vraiment un entier positif de l'humain, car les nombres négatifs pour un jeu ou pour un programme n'auraient tout simplement aucun sens. Alors, comment pouvons-nous mettre cela en œuvre ? Eh bien, il serait bien de le créer de manière à ce que vous puissiez simplement écrire un programme de deux lignes comme celui-ci où vous appelez une fonction appelée get_positive_int. Et si je fais défiler vers le bas, remarquez qu'il y a en fait une nouvelle fonctionnalité ici que nous n'avons pas encore vue, mais c'est un exemple intéressant d'une autre fonctionnalité de C. Ce que j'ai mis en évidence ici entre les lignes 15 et 24, c'est cette logique. Voici une fonction appelée get_positive_int. Cela ne prend aucune entrée, je n'ai donc rien à passer entre parenthèses. Je veux juste obtenir un ancien int positif. Mais je veux que cette fonction me rende quelque chose, tout comme get_int m'a rendu une valeur que je pourrais mettre dans une variable, tout comme le fait get_string. Il ne s'agit donc pas de void. C'est int. Donc, ce mot à gauche d'une fonction est le type de sa sortie. Ce mot entre parenthèses est le type de son entrée, le cas échéant. Et s'il n'y a rien, il suffit de dire void dans l'un ou l'autre ou les deux endroits. Maintenant, voici une curiosité — à la ligne 17, nous n'avons jamais vu cela auparavant, mais c'est juste un indice pour l'ordinateur disant, donne-moi une variable appelée n. Je ne sais pas exactement ce que je vais y mettre encore. Donc, vous dites simplement int n point-virgule. Vous n'avez pas encore besoin de lui attribuer quoi que ce soit. Il a ce que nous appellerons une valeur poubelle. Vous n'avez aucune idée de ce qu'il contient, mais cela n'a pas d'importance. Vous y mettrez quelque chose plus tard. Ensuite, il y a cette boucle, que nous n'avons pas encore vue, mais en C, c'est ce qu'on appelle une boucle do-while. Il est littéralement dit de faire ce qui suit tant que cette expression booléenne est vraie. Alors que veux-je faire ? Je veux obtenir un int de l'utilisateur, demandant à l'humain un entier positif et le stocker dans n. Cependant, je veux continuer à faire cela alors que n est inférieur à 1. Parce que si l'humain tape 0 ou négatif 1 ou négatif 50 ou quelque chose de non positif, je veux les inviter encore et encore et encore. Donc, une boucle do-while est plutôt chouette, car elle fera cette première chose au moins une fois. Ensuite, il vérifiera la condition et éventuellement le fera à nouveau si l'humain n'a pas coopéré. Une boucle while, si vous repensez, a en fait vérifié la condition en premier. C'était alors qu'une expression booléenne est vraie, faites ce qui suit. Celui-ci vous donne une telle itération, un passage gratuit, puis il vérifie la condition. C'est donc juste une autre façon de programmer, mais nous pourrions faire tout ce que nous avons fait jusqu'à présent en utilisant des boucles while ou même des boucles for.