[MUSIC PLAYING] SPEAKER 1: This is CS50. And perhaps not unlike past lectures, today is going to feel a bit like a fire hose again, but realize that it's going to be a lot less code today. So there's less syntax, just a few new ideas here and there. And the goal ultimately today really is the concepts and the ideas that we take away. And keep in mind that over the remainder of the semester, we will continue to apply and reapply these same ideas. So the goal today really is exposure. And the goal for the semester is comfort. 

So with that said, let's consider where we left off last time, which was to consider that inside of our computer. Of course, we have memory. We have RAM, Random Access Memory. And it was convenient, we found, to start to divide this up into individual bytes. Like, byte 0 might be in the top left, and 2 gigabytes, 2 billion bytes, might be all the way down there in the bottom right-hand corner. 

And once we started to layout our memory, both conceptually and technologically, in this way, left to right, top to bottom, we had the ability to use a data structure of sorts. We introduced, recall, arrays, whereby if we think of our memory as just a grid of bytes, we can start using it kind of to our advantage to solve problems. And it turns out that perhaps a physical incarnation of this idea of an array might be like these red lockers here. Because even though you and I, every time we've looked at arrays thus far, can kind of get a bird's-eye view of everything that's in the array, computer's actually pretty limited. It doesn't have that instant detection that you and I have when we just scan a list of numbers and [? kind ?] of take it all in. 

A computer is only going to be able to look at the contents of an array step by step by step, consistent with this whole idea of an algorithm. A computer can't just look at all the numbers and take it all in. It can only open, so to speak, one of these lockers at a time. 