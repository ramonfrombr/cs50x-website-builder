Muy bien, veamos otro ejemplo. ¿Cómo se llamaba esto en Scratch? Sí, una condición, una decisión que tienes que tomar. Entonces, si algo es verdadero, haz esto. En C, podríamos convertirlo de la siguiente manera. Si x es menor que y entre paréntesis, que no es exactamente la forma angular que tenemos aquí en verde, pero en C, usas paréntesis aquí. Entonces, si x es menor que y, abre paréntesis, cierra paréntesis, luego continúa y haz lo siguiente. Y así como esta pieza de rompecabezas amarilla o naranja parece abrazar a la pieza de rompecabezas púrpura, también lo hace esta llave de apertura y esta llave de cierre, por así decirlo, que están ahí listas para abrazar o encapsular una o más líneas de código. ¿Cuál es la línea de código? Podría ser algo como esto: printf x es menor que y \n. Entonces, nuevamente, nueva sintaxis, pero hemos visto las llaves antes en el contexto de main. Y hemos visto paréntesis antes en el contexto de entradas. Entonces, esto es solo una especie de patrón que comenzaremos a seguir en C siempre que queramos hacer algo condicionalmente. Ok, en Scratch, vimos algo como esto: si x es menor que y, entonces di que x es menor que y. De lo contrario, concluye que x no es menor que y. En C, casi se ve igual, pero te preparas con un bloque else con dos conjuntos de llaves, algo así como dos caracteres listos para abrazar las líneas de código entre ellos. Y ahora podemos simplemente conectar, literalmente, las traducciones a printf diciendo printf x es menor que y o printf x no es menor que y. Ahora, fíjate, solo hay dos punto y coma en este ejemplo. Por lo general, no terminas cosas como condiciones con punto y coma. Terminas funciones o líneas que involucran funciones con punto y coma. Y esa no es una regla estricta, pero no quieres líneas de código, no quieres punto y coma después de cada línea de código. Generalmente lo quieres después de alguna acción. Y comenzarás a notar este patrón, aunque quizás no sea obvio al principio. Muy bien, ¿qué tal éste? If, else if, else if. Ahora, fíjate que solo estamos reutilizando el bloque if-else if y luego otro bloque if aquí abajo. Resulta que en C, es casi un poco más fácil. Literalmente puedes decir esto: si x es menor que y, haz esto con llaves. De lo contrario, si x es mayor que y, haz esto entre llaves. De lo contrario, si x es igual a y, haz esto entre llaves. ¿Y qué quieres hacer en cada caso? Diferentes printf según los mensajes que queremos mostrar. Pero hay una curiosidad aquí. Casi parece un error tipográfico. Sí, el doble signo igual. Pero no es un error. No es un error. ¿Por qué estoy usando quizás doble igual aquí en lugar de un solo signo igual, como en Scratch? Déjame ir aquí. ¿Sí? AUDIENCIA: [INAUDIBLE]. DAVID MALAN: Exactamente. Dije anteriormente que el signo igual simple se usa para la asignación de derecha a izquierda. Y honestamente, esta es solo una especie de situación humana, en la que nos arrinconamos. Ya usamos el signo igual para la asignación. Entonces, presumiblemente, algún humano se dio cuenta, oh, caramba, ¿cómo hacemos la pregunta, es esto igual a aquello? Bueno, ya hemos usado ese símbolo. Entonces, los humanos, hace décadas, decidieron, muy bien, resolveremos ese problema simplemente usando dos signos de igual seguidos. Entonces este es el llamado operador de igualdad. Un solo signo igual es simplemente la asignación. Este es, sin duda, uno de los errores más comunes al principio, especialmente si usas Scratch u otros lenguajes de antemano. Y simplemente desarrollas la memoria muscular con el tiempo. Una vez que cometas ese error varias veces, desaparecerá. Muy bien, pero resulta que este programa, aunque puede decirse que es correcto, o este código, aunque correcto, en el sentido de que va a hacer esto o esto o aquello, y creo que esas son las tres posibles situaciones. Si tienes dos enteros, x e y, x es menor que y, mayor que y o igual a y. Pero técnicamente no es necesario hacer una de estas preguntas. Técnicamente hay tres expresiones booleanas aquí, ¿verdad? - x menor que y, x mayor que y, x igual a y. Una expresión booleana, recuerda, es una pregunta que tiene una respuesta de sí/no o una respuesta de verdadero/falso o una respuesta de 1/0. Pero no necesito hacer tres preguntas aquí, ¿verdad? Creo que vi tu mano. ¿Por qué no? AUDIENCIA: Bueno, porque si x es menor que [INAUDIBLE]... DAVID MALAN: Exactamente. Esta tercera pregunta, esta expresión booleana, ¿x es igual a y? No hace falta decirla lógicamente. Porque si x no es menor y no es mayor que, si es solo [INAUDIBLE], el único otro escenario en el que puedo pensar es que es igual a y. Así que realmente podemos simplificar tanto el código Scratch como el C simplemente teniendo esta otra condición abajo también. Entonces, hablaremos, durante las próximas semanas, sobre diferentes calidades de código. La corrección, como si hace lo que se supone que debe hacer, pero también la calidad del diseño, como si escribiste este código de la manera más eficiente posible, lo más rápido posible, de una manera que use la menor cantidad de memoria y la menor cantidad de CPU, el cerebro de la computadora. Y esto es solo una alusión a ese tipo de capacidad.