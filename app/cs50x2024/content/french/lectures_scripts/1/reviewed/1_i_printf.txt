Donc à ce stade de l'histoire, nous avons maintenant quelque part dans la mémoire de l'ordinateur, dans ce qu'on appelle une variable, la réponse de l'utilisateur à la question sur son nom. Qu'est-ce que j'ai envie d'en faire ? Eh bien, en C, il n'existe pas de fonction join, nous allons donc devoir faire ça d'une manière légèrement différente. Mais il existe en quelque sorte une fonction "dire", et comment cette fonction "dire" s'appelle-t-elle?  Printf. Donc, printf est la fonction à privilégier à chaque fois que vous voulez imprimer ou dire quelque chose à l'écran. Je vais donc utiliser printf. Et je vais utiliser des parenthèses, parce que les parenthèses indiquent que mes entrées arrivent, autrement dit les arguments ou paramètres en programmation. Mais ces termes sont synonymes en ce qui nous concerne.

Maintenant, c'est un peu moins évident, n'est-ce pas? Parce que je ne veux pas simplement mettre, entre guillemets, bonjour, virgule, réponse. Mais pourquoi? Pourquoi serait-il incorrect de mettre entre guillemets, bonjour, virgule, réponse? Ça affichera juste "réponse". Ça dira littéralement bonjour, virgule, réponse, n'est-ce pas? Et ce n'est pas ce que nous voulons. Nous ne voulons pas dire "bonjour réponse". Nous voulons dire, bonjour, Pierre ou bonjour, Martin, ou qui que ce soit qui joue à ce programme.

Je dois donc d'une manière ou d'une autre joindre le mot bonjour à l'entrée de l'utilisateur. Et la manière de le faire en printf diffère légèrement de Scratch. Vous utilisez ce qu'on appelle un espace réservé. Vous écrivez littéralement la phrase ou l'expression que vous voulez dire ou imprimer à l'écran, mais partout où vous ne connaissez pas encore la valeur à l'avance, vous placez un espace réservé à l'aide du symbole pourcentage, puis d'un s pour désigner une chaîne de caractères. Et ce parce que, bien sûr, si j'écris ce programme aujourd'hui, je n'ai aucune idée de qui va l'exécuter demain. Je veux donc placer dynamiquement un espace réservé afin que si quelqu'un joue à ce programme demain ou le lendemain, son nom soit inséré dynamiquement. 

Bien sûr, je ne connais pas son nom aujourd'hui. Donc entre guillemets, bonjour, virgule, % s. Et ce % s n'est qu'un espace réservé qui permet de brancher tout ce que je veux. Le retour à la ligne, c'est-à_dire, la barre oblique inverse N, bien sûr, signifie simplement une nouvelle ligne. Donc la seule chose nouvelle ici est ce % s.

Maintenant, il s'avère que les fonctions en C, tout comme dans Scratch, peuvent ne prendre aucun argument. Ou elles peuvent prendre un argument. Ou elles peuvent prendre deux arguments ou plus. Et si elles en prennent deux ou plus, vous les séparez par des virgules. La manière dont printf fonctionne (et vous ne pouvez le savoir qu'en étant formé ou en lisant la documentation) est que vous pouvez, oui, fournir juste une chaîne simple comme entrée (entre guillemets). Mais si vous avez des espaces réservés, vous pouvez indiquer à l'ordinateur ce qu'il doit brancher en ajoutant une virgule, puis le nom de la valeur ou de la variable que vous voulez brancher. Donc maintenant, ces deux lignes de code sont équivalentes à celles-ci.

Mais encore une fois, même si à première vue, cela peut sembler particulièrement obscur, si vous le décomposez simplement en composants individuels de droite à gauche, puis de l'extérieur vers l'intérieur, vous pouvez généralement déduire même ce que fait un nouveau code que vous n'avez jamais vu auparavant.

Une question courante est "Puis-je ajouter d'autres variables à la fonction printf?" Et la réponse c'est absolument oui. Si j'avais plus de variables dans ce programme, grâce à d'autres lignes de code, je pourrais simplement mettre une virgule, autre chose, une virgule, autre chose, une virgule. Et je pourrais avoir juste un espace réservé dans cette expression entre guillemets pour toutes ces variables que je veux brancher. Et elles vont de gauche à droite. Donc si j'avais deux % s ici, le premier viendrait après la première virgule. Le second viendrait après la deuxième virgule.

Ça veut dire qu'il faut un % s pour tout espace réservé que vous voulez brancher si c'est une chaîne. Et nous allons voir d'autres espaces réservés dans un instant. 

Une autre question courante est "Que se passerait-il si votre retour à la ligne était en dehors des guillemets?" Eh bien, laissez-moi aller de l'avant et faire ça. Et franchement, c'est le bon instinct à avoir. À l'avenir, chaque fois que vous aurez ces mêmes questions instinctives, essayez simplement. Vous ne pouvez pas faire de mal à l'ordinateur. Alors, laissez-moi aller de l'avant et, si vous voulez, mettre par inadvertance le retour à la ligne en dehors des guillemets. Très bien, voyons ce qu'il se passe. Je vais aller de l'avant maintenant et exécuter Clang. Je sais maintenant comment créer un nom personnalisé, je vais donc adopter cette convention. tiret O (-o) bonjour. Et maintenant, je vais aller de l'avant et dire bonjour.c, ce qui, je pense, va planter. Et en effet, quelque chose, en effet, a planté ici. Voyons quelle est l'erreur. C'est un peu obscur aussi, mais bonjour.c, deux-points 5, deux-points 26. Que se passe-t-il là-dedans? Eh bien, chaque fois que vous faites une erreur dans votre code comme celle-ci, Clang va essayer de vous aider à comprendre où se trouve cette erreur ou ce bogue. Donc bonjour.c deux-points cinq signifie de chercher votre erreur sur la ligne 5. Ensuite, voyez, il dit erreur: j'attendais des parenthèses fermantes juste ici. C'est donc un peu bizarre, parce que non, je ne veux pas de parenthèses fermantes, je pense. Je veux la nouvelle ligne. Il n'est donc pas parfaitement capable de vous dire, hé, ce retour à la ligne devrait être à l'intérieur des guillemets. Mais il peut au moins vous aider à vous concentrer sur l'endroit où se trouve l'erreur. C'est donc quelque part dans le coin, auquel cas votre propre mémoire ou vos propres recherches Google devraient vous aider à comprendre, oh, ça doit être à l'intérieur des guillemets.

