Pero vayamos más adelante y adelantemos, por ejemplo, a algo como esto en Mario, donde tienes una gran cantidad de bloques bajo tierra. Y esta vez, no es solo una columna o una fila de bloques. Esta vez, son dos dimensiones. Bueno, esto es bastante interesante, porque ahora ¿cómo imprimes un bloque, bloque, bloque, bloque, bloque, bloque, bloque, bloque, bloque, bloque, bloque, bloque, y de hecho haces una estructura bidimensional? Bueno, no hay nada que nos impida hacer algo en C, como en Scratch, por ejemplo, con bucles. Déjame mostrarte este ejemplo aquí. Supongamos que con estas primeras líneas de código, le pedí al usuario el tamaño de este bloque. Por lo tanto, quiero crear algo que sea cuadrado como esto: bloque, bloque, bloque, bloque, bloque, bloque, bloque, bloque, bloque, y así sucesivamente. Bueno, puedo seguir adelante y pedirles un número entero una y otra vez hasta que sepa ese tamaño. Y luego da cuenta de esto. Esto está comenzando a escalar nuevamente, pero considera la lógica. Esto ahora es para int i obtener 0, i menor que n, i más más. Entonces, haz lo siguiente n veces, ¿cierto? Esta es una forma muy críptica, similar a C, de decir, haz lo siguiente n veces. ¿Qué pasa con la línea 16? ¿Qué dice la línea 16? Aunque esté usando una variable diferente. Estoy usando j solo porque en lugar de i. AUDIENCIA: Lo mismo. Haz lo siguiente n veces. DAVID MALAN: Sí, dice exactamente lo mismo: haz lo siguiente n veces. Sin embargo, está contando usando j en lugar de i, solo para que mis matemáticas no se mezclen incorrectamente. Entonces, si piensas en lo que es este bloque de Mario, es como imprimir filas y columnas. Algo así como una máquina de escribir de la vieja escuela que tiene que moverse de izquierda a derecha y luego de arriba a abajo, de arriba a abajo, de izquierda a derecha, etc. solo para imprimir diferentes bloques en diferentes líneas. Entonces, el efecto aquí, si abro mario8, podría ser este, hacer... Vaya. Déjame seguir adelante y hacer mario8, ./mario8. ¿Cuál va a ser el tamaño? Bueno, tal vez tres. Y ahora he impreso tres filas y tres columnas. Estos esencialmente representan cada una de mis filas. Estoy contando de i hasta... oh. Ahora solo me estoy enseñando a mí mismo, de acuerdo. Retrocedamos. Esto es lo que me estaba asombrando hace un momento. Cuando estaba ejecutando ¿qué tamaño tiene este programa? Vi una cuadrícula de bloques de tres por tres. Y si lo vuelvo a ejecutar, tal vez con 10, ahora veo una cuadrícula incluso más grande de ladrillos de 10 por 10. Es un poco más alto que ancho, porque las marcas de almohadilla son más altas que anchas. Y verás que ahora este programa es dinámico. Entonces, ¿cómo funciona eso? Bueno, si realmente miro el código aquí, ten en cuenta que, efectivamente, lo que la línea 14 está haciendo es hacer una fila a la vez. Me da n filas y cada una de esas filas las estoy pensando como i en 0, i1, i2, etc. Mientras tanto, dentro de cada fila, estoy usando este bucle interno, que está deliberadamente anidado dentro, para hacer cada uno de los caracteres de izquierda a derecha. Entonces, dentro de cada fila, quiero almohadilla, almohadilla, almohadilla, almohadilla. Dentro de cada fila: almohadilla, almohadilla, almohadilla, almohadilla. Entonces es como implementar este proceso bidimensional. Pero de nuevo, utilizando las mismas ideas fundamentales. Solo un bucle for que está contando muy cuidadosamente desde cero hasta algún valor para hacer algo una y otra vez. Y si piensas en cualquiera de los juegos, gráficos o programas actuales, cada vez que veas redundancia, ya sea en dos dimensiones -quizás sea verticalmente en una dimensión o esto horizontalmente en otra. Lo más probable es que haya alguna repetición que esté sucediendo una y otra vez y que se pueda reducir en C o en Scratch o en algún otro idioma para finalmente convertirse en líneas de código. Y de hecho, esta es una alusión a una de las primeras cosas que harás para el primer conjunto de problemas, el conjunto de problemas 1. Utilizarás CS50 Lab, que es idéntico a CS50 Sandbox, que he estado usando hasta ahora, pero que agrega instrucciones, los problemas reales a resolver, junto con su sandbox.