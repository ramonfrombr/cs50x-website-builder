Ahora hay un último detalle que aún no hemos explicado y es este. ¿Por qué demonios `main` tiene un valor de retorno? Y realmente no hay una razón muy convincente aquí, pero podemos ver que hay una razón de bajo nivel por la que esto es útil, pero no es algo por lo que tengamos que estresarnos mucho. Resulta que `main` por defecto en C sí tiene un valor de retorno. Y aunque todavía no hemos devuelto nada desde `main`, por defecto, `main` devuelve cero. El cero en las computadoras normalmente significa que todo está bien. Es un poco paradójico, porque uno podría pensar que cero es falso o malo. Pero no, el cero tiende a ser bueno.

La razón de esto es que `main` puede devolver valores distintos de cero, como uno, menos uno, 2 mil millones o menos 2 mil millones. De hecho, si alguna vez has visto un mensaje de error en tu Mac o PC, a veces aparece una pequeña ventana emergente y es un código de aspecto críptico, como si hubiera ocurrido un error, menos 42 o lo que sea. Ese número es solo un número arbitrario que algún humano decidió que devolvería su programa `main` si algo salía mal. Y podemos hacer esto de la siguiente manera. Puedo escribir un programa como este en un archivo llamado `exit.c` que tiene, por ejemplo, la biblioteca `CS50`, que incluye `standardio.h`, `int main void` (voy a volver a `void`, porque no voy a tomar ninguno), o en realidad, no, voy a hacer `int rc`, y luego `string argv[]`, para poder tomar un argumento de línea de comando, y voy a empezar a verificar errores.

Supongamos que este es un programa que se supone que el humano debe proporcionar un argumento de línea de comando. Voy a hacer esto. Si `argc` no es igual a dos, ¿sabes lo que voy a hacer? Voy a gritarle al usuario, decir que falta el argumento de la línea de comando \n, pero ahora quiero salir del programa. Quiero hacer el equivalente a salir. Entonces, ¿cómo haces eso en C? En realidad, devuelve un valor. Y si todo salió bien, devolverías cero. Sin embargo, si algo salió mal, el cielo es el límite, hasta 2 mil millones o menos 2 mil millones. Sin embargo, lo mantendremos simple y solo devolveremos uno, si algo salió mal.

Mientras tanto, podría decir `printf`, hola, `%s`. Escribe `argv[1]`, como antes. Y luego, si todo está bien, devuelve cero. Así que no está pasando nada nuevo aquí. Este programa es muy similar al anterior, excepto que en lugar de decir hola mundo por defecto, voy a gritarle al usuario con esto, falta el argumento de la línea de comando, y luego devolveré uno para indicarle a la computadora que este programa no tuvo éxito. Y devolveré cero, si y solo si, lo hizo. ¿Sí?

AUDIENCIA: ¿Por qué `argc` es desigual a cero?

DAVID MALAN: ¿Por qué `argc` no es igual? Realmente buena pregunta. Así que déjame seguir adelante y cambiar esto. ¿Qué hay en `argv[0]` que hace que tenga dos cosas en lugar de una, si ejecuto David, si ejecuto mi nombre, David? Bueno, hola, déjame recompilar. Haz que `argv[1]`, o haz que `argv`, punto barra, `argv`, hola - no, programa incorrecto. Haz exit. Lo siento. No hay ningún programa para detectar ese error. Punto barra exit, falta argumento de línea de comando. Sin embargo, si hago exit David, ahora veo - ¿ejecuté `argv` antes? Revisa la cinta.

Hola punto exit. Entonces, en `argv`, la primera palabra que escribes, el nombre del programa, se almacena en `argv[0]`. La segunda palabra que escribes, el primer argumento que te importa, es `argv[1]`. Y es por eso que `argc` es dos. Literalmente escribí dos palabras en el indicador, aunque técnicamente solo una de ellas sea un argumento que me importa.