Nous y voilà, et maintenant nous commençons à étudier non seulement les comparaisons de C avec Scratch, mais à écrire du code de Scratch en C. L'objectif ici est de commencer à développer la mémoire musculaire qui permet à partir de fichiers vides, d'implémenter en C nos idées. Soyez assurés que tous les exemples que nous allons faire en direct sont déjà précuits en ligne, ainsi vous pourrez télécharger tous ces exemples depuis le site du cours. Dans les super sections de Brian, vous pourrez les découvrir plus en détail. Et un peu plus tard cette semaine, vous aurez l'occasion de travailler de manière pratique sur les mêmes types de programmes. Pour le moment, le but principal est l'exposition à ces concepts et le début du développement de cette mémoire musculaire. Cela dit, laissez-moi créer un nouveau fichier appelé int.c, dont le but va être d'obtenir un entier de l'utilisateur, tout comme j'ai récupéré une chaîne de caractères de l'utilisateur il y a peu. Je vais y aller et, comme précédemment, je vais inclure quelques fichiers familiers. Donc je vais y aller et inclure en amont CS50.h pour avoir accès aux chaînes de caractères, get_string, get_int, get_float et aussi à d'autres fonctions. Je vais inclure stdio.h pour avoir accès à printf, et voir ainsi ce que nous sommes en train de faire. Ensuite, je vais faire cela, qui, encore une fois, pour le moment et pour quelques semaines, consistera simplement à faire du copier-coller. Cela correspond à l'équivalent du clic sur le drapeau vert, mais dans quelques semaines, nous expliquerons exactement pourquoi vous écrivez int et pourquoi vous écrivez void. Ici, je vais faire quelque chose comme ça. Cette fois-ci, je veux obtenir non pas une chaîne de caractères, mais un entier. Alors faisons dans l'âge obtenir get_int, quel âge as-tu ? Maintenant, pour être juste, je peux probablement taper cela assez rapidement, car j'ai déjà la mémoire musculaire pour programmer en C. Mais si nous observons cela méthodiquement pendant un moment, il s'agit simplement d'une autre fonction, get_int, de la bibliothèque CS50 qui va obtenir un entier. C'est l'invite que l'humain verra avec son curseur qui se déplacera vers une nouvelle ligne à cause du backslash n. Et tout ce qu'ils taperont sera copié de droite à gauche dans une variable appelée âge, dont le type, pour ainsi dire, est int, ou entier. Maintenant, laissez-moi y aller et calculer combien de jours cette personne a. Si je veux faire cela, je pourrais faire quelque chose comme ça. Bien, donnez-moi un entier. Appelez cela jours. Et ensuite il suffit de faire l'âge multiplié par 365. J'ai proposé il y a peu qu'il existait un tas d'opérateurs arithmétiques comme plus, moins, multiplication, soustraction et même le reste. Donc cette ligne, 7, dit simplement de multiplier l'âge par 365. De copier cette valeur, de droite à gauche, dans une nouvelle variable appelée jours. Et maintenant je peux y aller et l'imprimer si je veux. Donc printf quelque chose comme, tu as au moins pourcentage — pas s, car ce n'est pas une chaîne de caractères, mais pourcentage i parce que c'est un entier maintenant — jours, backslash n. Mais là encore, il s'agit d'un espace réservé, donc je n'ai pas encore fini. Que dois-je mettre à l'intérieur de ces parenthèses également à la ligne 8 ? Oui, donc une virgule, jours, si c'est la valeur que je veux brancher. Et il me manque encore une chose. L'AUDITOIRE : Un point-virgule. DAVID MALAN : Un point-virgule à la fin de la ligne. J'espère avoir fait cela correctement. Mais il y a fort à parier que la première fois que vous écrirez vos programmes, vous verrez des messages d'erreur. Mais voyons voir, make int est maintenant le moyen le plus rapide de compiler ce code. Entrez. Très bien, la grande et longue commande blanche donne OK. Tant que vous ne voyez pas de sortie rouge, jaune ou colorée indiquant des avertissements ou des erreurs, cela devrait aller. Je vais maintenant effacer mon écran pour pouvoir exécuter ce programme, ./int. Et supposons que votre âge soit, disons, 50. Eh bien, vous avez au moins 18 250 jours. Mais laissez-moi profiter de l'occasion non seulement de faire quelque chose de correct, ce que selon moi représente ce code, mais simplement pour améliorer sa conception. C'est bien de stocker cette valeur, l'âge, dans une variable appelée âge. Et c'est bien de créer une deuxième variable appelée jours, dans laquelle ma réponse mathématique est l'âge multiplié par 365. Mais à proprement parler, je n'ai pas besoin de cette ligne de code supplémentaire. Je pourrais simplement faire ici l'âge multiplié par 365. Le C est bien comme ça. Vous pouvez composer, comme dans Scratch, des idées plus grandes à partir de plusieurs plus petites. Et franchement, si je veux vraiment devenir fou, remarquez que je peux réellement mettre en surbrillance tout cet appel de fonction, pour ainsi dire, me débarrasser de tout l'âge, et simplement brancher cela ici multiplié par 365. Mais à ce stade, nous commençons à franchir un point d'inflexion. Oui, c'est correct, car à proprement parler, je n'ai pas besoin d'une variable, n'est-ce pas ? Je peux transmettre — nous l'avons vu la semaine dernière — la sortie d'une fonction comme entrée d'une autre fonction en les imbriquant simplement de cette façon. Mais honnêtement, nous arrivons maintenant au point où cette ligne de code est relativement longue, elle est tout simplement trop difficile à lire. Donc c'est un exemple où, pour des raisons de conception, vous savez quoi ? La version précédente était probablement un peu meilleure, car je peux lire le code davantage de haut en bas que de gauche à droite. Mais c'est une décision de conception. Et en effet, vous pouvez être d'accord ou pas. Vous pourriez être d'accord ou pas avec votre chargé d'enseignement, ou TF, au final. Ce sont les types de décisions qui entrent dans l'écriture d'un code bon ou mauvais, ou d'un code meilleur ou bon. Tout comme dans une dissertation en anglais ou dans n'importe quelle langue écrite, vous pourriez affirmer qu'une personne a mieux rédigé son document qu'une autre. Nous allons donc commencer à apprécier ces nuances au fil du temps.