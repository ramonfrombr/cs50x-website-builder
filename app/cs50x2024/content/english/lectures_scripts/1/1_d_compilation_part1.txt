All right, so now I claim I've written some code. How do I go about running it? Well, how do you run a program on your Mac or PC? What do you typically do? You double-click it, right? Unfortunately, there doesn't seem to be anything obvious to double-click here. In fact, there's no icon on my screen. And in fact, there's no program, per se, yet. Because computers, recall from last week, don't understand English. They don't technically understand C, per. Se what is the language that computers speak and understand? AUDIENCE: Binary. DAVID MALAN: Yeah, so binary, zeros and ones. And yet, this clearly is not zeros and ones. And frankly, none of us would have a good time if coding involved, these days, literally writing zeros and ones, which, in some sense, it did involve way back in the day. But nowadays, it turns out there's a solution to this problem. This, as cryptic as it looks to most of us in this room, at least you can imagine eventually getting comfortable, probably, with this syntax, once you learn the rules and the syntax and so forth. But we need to convert it somehow to zeros and ones. And how to do that is perhaps not obvious. So it turns out if we want to convert code like this to zeros and ones that the computer understands, there needs to be some intermediate step. I actually need, on my Mac or PC or this cloud-based environment, a program that is going to take as input my source code, which is that language called C, and is going to produce as output what's called machine code. So source code is something like C or Python or Java or C++ and maybe other languages you've heard about. It's English-like syntax in which you write programs. Machine code is the zeros and ones that every computer actually understands. So to get from source code to machine code, there needs to be some kind of algorithm or, more specifically, a piece of software that does that conversion. And that piece of software is what we're going to start calling a compiler. So we're going to write code literally by just typing commands at a keyboard. We're going to save those commands in a file, just like you saved your code in Scratch. But before I can run my program and do the equivalent of double-clicking on it, I need to run it through a compiler and produce output, which is zeros and ones. So how do I go about doing that? This is the first of the more esoteric commands, but it turns out it's relatively straightforward to do. At the top of my programming environment-- again, I have my code here at top left. And if I scroll down to the bottom, I have this, again, so-called terminal window. And the dollar sign is just a weird human convention. The dollar sign just means type something here. That's your so-called prompt, or your shell. But the blinking cursor is just inviting me to type a command at this prompt. The first command I'm going to type is what's called Clang for C language. Clang is the name of a program that exists to compile code. Someone else wrote this. Someone else online built this program called Clang-- a whole group of people, in fact. Made it freely available for me and you to download onto your own Macs or PCs or this sandbox environment. And we can use Clang to convert source code to machine code. So I'm going to go ahead and run Clang hello.c. I've not hit Enter yet, but the moment I hit Enter, we're going to see something happen. Let me go up to this little folder icon up here, and you can actually see all of the files in my current sandbox, so to speak, my programming environment. There's, of course, only one, because the only file I've created thus far is called hello.c. But notice what happens the moment I hit Enter, after having typed out Clang hello.c. So clearly something else exists now, and it's a really stupid name and very cryptic. It's a.out, but you can perhaps guess what's inside of that new file. What might be inside of it? AUDIENCE: Machine code. DAVID MALAN: Yeah, machine code. So it stands for assembly output, but that just means machine code. So inside of this file are a whole bunch of zeros and ones that correspond to this code, but in binary, in the language the computer can understand. So literally what I just did was this-- I took as input code that looks like this, written in C. I ran it as input into the compiler and produced this output, zeros and ones. And those zeros and ones were automatically saved for me inside of a file that, by human convention, is called a.out. All right, but someone proposed earlier, to run a program, typically, on your Mac and PC, you just double-click it. But there's really nothing to double-click. And in fact, if I double-click on this, it's going to look really weird, and the computer's not going to understand it. Because it's zeros and ones that aren't meant to be clicked. They're meant to be executed at this command prompt. So let me go ahead and do this. This, too, is cryptic. But I'm going to go ahead and do ./a.out. And this, weird as this may look at first glance, is how I tell the computer, run the program a.out in my current directory. So that period that I typed first just means it's literally right here, in my current folder, as though you're double-clicking on it on your Mac or PC. And /a.out means look in this directory, and run the program in the file called a.out. So let me go ahead and hit Enter. And voila, hello world. So you were very impressed last week, as I recall, when I made the cat say, hello world. Here, we seem less than underwhelmed. But hello world is now my program in C that's done exactly the same thing. But admittedly, it looks a little stupid at the moment. It looks a little buggy. What rubs you the wrong way, even if you've never programmed before? AUDIENCE: Dollar sign. DAVID MALAN: Yeah, the dollar sign. I didn't mean to say hello world dollar sign, but that dollar sign is just like an artifact, right? What is the dollar sign again? AUDIENCE: Prompt. DAVID MALAN: It's just that prompt. It's waiting for another command, and that's why my cursor is blinking there. But it just looks stupid, right? We could argue that this was my intent, but frankly, I'd be lying. That doesn't quite do what I want it to do. And this is because, unlike Scratch-- which, again, is more user friendly-- C, and many languages like it, literally will only do what you tell them to do. At no point did I tell the computer to move the cursor to a new line. I didn't finish that thought. I said, hello, comma, world, and that's it. I never sent a command to the computer to actually move that cursor, but I can.
