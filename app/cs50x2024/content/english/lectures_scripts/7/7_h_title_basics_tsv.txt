All right, we are back. So we have a whole bunch more data now, because we've downloaded that really big TSV file from IMDB. I've simplified it into some CSV files, but that really gets me half of the way there, because now if I want to search the data, as with search.py, I still have to look over thousands of rows of TV shows, and it's only going to be linear search by nature of just how files are read, top to bottom, left to right. 

But it turns out in Python that you can actually write SQL code itself. And CS50 has a Python library that has not only get string and get int and so forth, but it also has a SQL function built in that allows you to connect to, so to speak, a file that ends in something like .db, which is to say, in a moment, we'll start to write some Python code now toward an end of loading a really large data set like IMDB's into a proper SQL database, thereby allowing us hereafter to use all of the power and expressiveness of SQL, and more examples of that in just a bit like SELECT, UPDATE, DELETE, and INSERT, without having to write a whole bunch of Python code. 

So to be clear, instead of using Python to search and manipulate our data, we're going to write a script, a program in Python, whose sole purpose in life is to get data from one format into another. And you can imagine there's being generally useful, whether it's a Google Spreadsheet you've downloaded or a large data set you found on the internet that you want to use for a final project or for some other class. Python can be a really powerful way of taking one data source as input and producing its output now, as of today, SQL instead. 

So let's go ahead and iterate one final time of our title.basics.tsv. But this time, not just save it into a CSV file. Let's put it into a proper SQL database on my own Mac or your PC. So let me go ahead and do this. First, let me go ahead and say, just like on the slide, db = cs50.sql, and then quote unquote, "sqlite:///--" so the third slash is not a typo. It should indeed be there. And I'm going to say shows3.db, just because this is version 3 now of my import script. I'm going to go ahead, just as last week, and now import CSV-- CS50's library as well. 

But for this to work, the file shows3.db needs to exist first. And there's a couple of ways on a Mac or a PC or a Linux computer, typically, to create an empty file that's ready to receive data. You can literally use the command touch, which just will create an empty file by whatever name you type at the prompt. Or we can do this programmatically. And I'm going to do it programmatically, because I bet I'm going to screw up one or more times here, and it's going to be useful to let my Python program create and recreate the database again and again and again until I get it right. 

So let me go ahead and open a file called shows3.db in write mode. And recall from Python and C, using fopen, anytime you open a file in write mode, it will overwrite any file that exists or create any file that doesn't. That's all I needed to do. So in Python 2, recall that we were able to use this dot notation. And it turns out here, when you open a file, if you want to immediately close it, because your only goal was to create it, you can just do .close on the very thing you just opened. That is equivalent, just to be clear, to doing something a little more pedantic like this, file = open, and then file.close. But we can collapse this into one slick one-liner, so to speak, by just doing instead what I did a moment ago. 

All that does is create empty shows.3 file. Now, open that file for SQLite. And again, SQLite is the light version of SQL that anyone can use on their own Mac or PC. You don't need a special server to get up and running with it. So now let me go ahead and open up title.basics.tsv. And then here, let me go ahead and create myself a DictReader so that I can iterate over the lines in that TSV file. 

And now, let me go ahead, and for row in reader, do the following. I first want to filter out stuff just as before. So I'm going to say if row bracket "titleType" == "tvSeries" and row "isAdult" == quote unquote "0", then I'm going to go ahead and check one other thing. I'm going to go ahead and give myself a start year variable, similar to before, although I called it year earlier. Then let me go ahead and do row "startYear", just so I can cast that to an int. But I only want to do that if row "startYear" does not equal that special backslash N that IMDB told me to watch out for. So I only want to do that if it's not that. 

And then if startYear is greater than or equal to 1970, let's go ahead and do the following. Let's go ahead and do genres, gets row "genres". Let's go ahead and get tconst, gets row "tconst," just so I can put these in some slightly shorter variable names, just to keep myself sane. primaryTitle is going to be from row "primaryTitle." and then let me go ahead and give myself-- we already have startYear, so those are the only other three fields I need. 

So now, I want to go ahead and insert this row from my TSV into a SQLite database. And the operative word that we saw earlier that we haven't used it yet, is INSERT. We did use SELECT. We did use UPDATE. We did use DELETE. We haven't used INSERT yet. So I'm going to do that in a moment. But first, I need my database to actually exist, so I need to create an actual table. 

So I'm going to go up here first and do this, db, is a reference now, a variable representing my database, and I'm going to call the only function inside of it that's useful for our purposes, called execute. What I can now do is execute any SQL I want. So what do I want to load into this database? I think I want to load in the tconst, the primaryTitle, the startYear, and the genres, just like we had earlier from title.basics.tsv. I want to load rows that represent this kind of data, all right? 

So how am I going to do this? Well, let me go ahead and create a table. I'm going to call it shows, because that seems nice and conceptually consistent. I'm going to go ahead and create a list of columns now. tconst is going to be one column. primaryTitle is going to be another. startYear is going to be another. And genres is going to be the last. I can literally, that is to say, write SQL inside of a string that I pass to a Python function called db.execute. And because db.execute-- or rather, because db was configured with shows3.db, when I execute this string in Python, it's going to get executed on that database file, shows3.db. So it's a nice way of bridging these two worlds. 

So I'm going to have to be a little more specific, though. Recall that SQL has a bunch of types. And I'm going to keep it simple. I'm going to go ahead and say that the type of that tconst value is text. The type of the primaryTitle is text. The type of startYear is going to be numeric, kind of a catch all for dates and date times. And then genres is going to be text as well. So the syntax is a little funky. You actually specify the name of the column and then the type, as opposed to the opposite, which we did in C. But that's the way SQL is. 

So I'm going to go ahead and save that now. And just to comment this, this is going to create a table called shows in database file called shows3.db, just to be super explicit. 

So what am I going to do down here? It looks like I have the ability with CS50's library to execute any SQL I want. So let me go ahead and insert into shows the following values, a tconst, a primaryTitle, a startYear, and a genre-- and genres. What values? I want to insert these values. Now, I don't know in advance, so I'm literally going to put some question marks here. And it turns out in SQL, this is valid syntax for the library we're using. This is this INSERT query. INSERT INTO the table name a parenthesized list of the columns you want to insert data into. Then, a set of values in separate parentheses. 

And for now, I'm using question marks for placeholders, for reasons we'll come back to. But I'm going to go ahead and plug the following values into those placeholders, tconst, primaryTitle, startYear, and genres. And what the db.execute function is going to do for me automatically is it's going to look at this SQL query. Notice that, oh, it's got four question marks in it, or placeholders. Those, in SQL, are like the %s was in C or are like the curly braces are and Python f strings. 

So this says, give me 1, 2, 3, 4 placeholders and plug in, ultimately, the following four values, tconst, which is just a variable; primaryTitle, which is the same; startYear, which is the same; and genres, which is the same. So what am I going to do? For every TV series in this file that's not an adult series and that started after 1970, insert it into my database. If I've made no typos, I'm going to go ahead and run this, cross my fingers, and enter. 

This one is going to take more time, because it turns out writing to a CSV file is actually pretty quick. You can just write row, write row, write row, write row, but inserting into a SQLite database is going to take more time. More time upfront, but it's going to be a lot faster to search thereafter. 

So let me go ahead and do the cake in the oven thing and go ahead and now open up a file I made an advance in today's src3 directory called shows3.db using SQLite3, that command line program we used earlier. Recall that I can say .schema to see the types of data in the database. And indeed, look what I've done in advance. I created a table called shows with exactly those columns in a-- with exactly these four columns, tconst, primaryTitle, startYear, and genres. But I did this in advance to save us time so that I can now do SELECT * FROM shows. And let me not get all of them. Let me do the first 10, semicolon. 

All right. So we see the first 10 shows from IMDB in whatever order IMDB distributes them. You can see their ID numbers are incrementing. And All My Children. I remember growing up with that show years ago. And it seems that that's a drama-- it's not really mystery, but so be it, and a romance show there. But it's indeed 1970, as are every show thereafter in 1970 or onward. 

I can go ahead and search for more like this. Let me give myself the first 100 shows. All right, so this is a pretty large data set. And let me go ahead and count them all. Recall that you can use a COUNT function so that we don't have to print them all on my screen. It looks like there are 153,331 TV series in IMDB. Crazier than that, you want to know how many of them came out this year? WHERE startYear = 2019;. There were 6,099 new TV shows in the world this year according to IMDB. Just one of those is The Office that won our-- won our vote earlier. So SELECT *, star denoting wild card, in this case, everything. And unfortunately, SQL has two wild cards. Star means select all of the columns in the table. Percent means let any characters come before or after a quoted string in a WHERE clause. 

So let me go ahead and SELECT * FROM shows WHERE title = The Office, and we'll actually see-- whoops. primaryTitle, sorry. Let me fix that. primaryTitle = The Office. There are all of those Offices. And indeed, 2005 is probably the one we know and love. If I go to a browser and go to IMDB slash title slash that ID, indeed, that's probably the one we're all thinking of, unless you voted for the UK version instead. 

So again, this is actually real, live data that we're now playing with. Well, what more can we do? Well, there's one thing that I don't really like about this, which is that when we select all of the columns-- and let's go ahead and do this. Let's select another hundred of them before. This feels a little messy that we have all of these nice, clean columns except for when we get to genres. Then we just have this arbitrary comma-separated list. Suppose, for instance, I want to search for all of the comedies that came out in 2019. I could say SELECT * FROM shows where genres = "Comedy" AND-- turns out you can use conjunctions like this-- startYear = 2019. 

So that gives me a whole bunch. Let's count them. So COUNT this here, Enter. OK, a thousand of those 6,000 shows are comedies. But I think that's an underestimate. Why is this query buggy at the moment? Yeah? 

AUDIENCE: [INAUDIBLE] 

DAVID MALAN: Yeah, some of them had more than one genre, so comedy is somewhere in that comma-separated list. And so what I should probably do instead is not say genre = "Comedy," but maybe genres LIKE "Comedy," and allow something maybe to appear before, something maybe to appear after. And that's going to give me 1,593 comedies that came out this year in 2019. So that seems a little better. 

But this is not very robust, right? Once you start resorting to techniques like this, it should start, as a programmer, to rub you the wrong way. It's kind of a hack, right? Like, you're searching for comedy, but there could be something before it or something after it, and odds are, there is no other word I can think of in the world of genres that starts with or ends with comedy, so we're probably OK. But this is kind of hack-ish, that you're just kind of searching. It would be nice if we could just search for a specific column called genre. 