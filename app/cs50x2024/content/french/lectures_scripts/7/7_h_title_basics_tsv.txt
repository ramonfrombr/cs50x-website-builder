Ok, nous y sommes. Nous avons donc maintenant beaucoup plus de données, parce que nous avons téléchargé cet énorme fichier TSV à partir d'IMDB. Je l'ai simplifié dans des fichiers CSV, mais cela m'amène vraiment à mi-chemin, parce que maintenant, si je veux rechercher des données, comme avec search.py, je dois toujours examiner des milliers de lignes de séries télévisées, et ce ne sera qu'une recherche linéaire par nature, tout simplement parce que  les fichiers sont lus, du haut vers le bas, de la gauche vers la droite.

Mais il s'avère qu'en Python, vous pouvez réellement écrire du code SQL lui-même. Et CS50 possède une bibliothèque Python qui possède non seulement get string et get int et ainsi de suite, mais elle possède également une fonction SQL intégrée qui vous permet de vous connecter à un fichier qui se termine par quelque chose comme .db, c'est-à-dire que dans un instant, nous allons commencer à écrire du code Python maintenant vers la fin du chargement d'un très grand ensemble de données comme celui d'IMDB dans une base de données SQL appropriée, nous permettant ainsi d'utiliser désormais toute la puissance et l'expressivité de SQL, et plus d'exemples de cela dans un instant comme SELECT, UPDATE, DELETE et INSERT, sans avoir à écrire tout un tas de code Python.

Donc, pour être clair, au lieu d'utiliser Python pour rechercher et manipuler nos données, nous allons écrire un script, un programme en Python, dont le seul but dans la vie est de faire passer les données d'un format à un autre. Et vous pouvez imaginer que cela est généralement utile, qu'il s'agisse d'une feuille de calcul Google que vous avez téléchargée ou d'un grand ensemble de données que vous avez trouvé sur Internet et que vous souhaitez utiliser pour un projet final ou pour une autre classe. Python peut être un moyen très puissant de prendre une source de données en entrée et de produire sa sortie désormais, en SQL.

Alors allons-y et itérons une dernière fois notre title.basics.tsv. Mais cette fois, ne l'enregistrez pas uniquement dans un fichier CSV. Mettons-le dans une base de données SQL appropriée sur mon propre Mac ou votre PC. Alors, laissez-moi faire ça. Tout d'abord, laissez-moi aller de l'avant et dire, comme sur la diapositive, db = cs50.sql, puis entre guillemets, "sqlite:///--" donc la troisième barre oblique n'est pas une faute de frappe. En effet, elle devrait être là. Et je vais dire shows3.db, simplement parce qu'il s'agit maintenant de la version 3 de mon script d'importation. Je vais aller de l'avant, comme la semaine dernière, et maintenant importer CSV - la bibliothèque CS50 également.

Mais pour que cela fonctionne, le fichier shows3.db doit d'abord exister. Et il existe généralement deux façons, sur un Mac, un PC ou un ordinateur Linux, de créer un fichier vide prêt à recevoir des données. Vous pouvez littéralement utiliser la commande touch, qui créera simplement un fichier vide quel que soit le nom que vous tapez à l'invite. Ou nous pouvons le faire par programmation. Et je vais le faire par programmation, parce que je parie que je vais faire une ou plusieurs erreurs ici, et il sera utile de laisser mon programme Python créer et recréer la base de données encore et encore jusqu'à ce que je parvienne à le faire correctement.

Alors laissez-moi aller de l'avant et ouvrir un fichier appelé shows3.db en mode écriture. Et rappelez-vous de Python et C, en utilisant fopen, chaque fois que vous ouvrez un fichier en mode écriture, il écrasera tout fichier existant ou créera tout fichier qui n'existe pas. C'est tout ce que j'avais besoin de faire. Donc en Python 2, rappelez-vous que nous avons pu utiliser cette notation par points. Et il s'avère qu'ici, lorsque vous ouvrez un fichier, si vous souhaitez le fermer immédiatement, parce que votre seul objectif était de le créer, vous pouvez simplement faire .close sur la chose même que vous venez d'ouvrir. Cela équivaut, pour être clair, à faire quelque chose d'un peu plus pédant comme ceci, file = open, puis file.close. Mais nous pouvons réduire cela en une seule ligne lisse, pour ainsi dire, en faisant simplement ce que j'ai fait il y a un instant.

Tout cela fait est de créer un fichier vide shows.3 Maintenant, ouvrez ce fichier pour SQLite. Et encore une fois, SQLite est la version allégée de SQL que tout le monde peut utiliser sur son propre Mac ou PC. Vous n'avez pas besoin d'un serveur spécial pour le mettre en marche. Alors maintenant, laissez-moi aller de l'avant et ouvrir title.basics.tsv. Et puis ici, laissez-moi aller de l'avant et me créer un DictReader pour pouvoir itérer sur les lignes de ce fichier TSV.

Et maintenant, laissez-moi aller de l'avant et pour la ligne dans le reader, faites ce qui suit. Je veux d'abord filtrer les éléments comme avant. Je vais donc dire si row bracket "titleType" == "tvSeries" et row "isAdult" == entre guillemets "0", alors je vais aller de l'avant et vérifier une autre chose. Je vais aller de l'avant et me donner une variable d'année de début, similaire à la précédente, bien que je l'aie appelée year plus tôt. Alors laissez-moi aller de l'avant et faire row "startYear", juste pour pouvoir le caster en int. Mais je ne veux le faire que si la ligne "startYear" n'est pas égale à cette barre oblique inverse spéciale N dont IMDB m'a dit de faire attention. Je ne veux donc le faire que si ce n'est pas cela.

Et puis si startYear est supérieur ou égal à 1970, allons-y et faisons ce qui suit. Allons de l'avant et faisons des genres, obtenons la ligne "genres". Allons-y et obtenons tconst, récupérons la ligne "tconst", juste pour pouvoir les mettre dans des noms de variables un peu plus courts, juste pour rester sain d'esprit. primaryTitle proviendra de la ligne "primaryTitle". et puis laissez-moi aller de l'avant et me donner - nous avons déjà startYear, ce sont donc les trois autres champs dont j'ai besoin.

Donc maintenant, je veux aller de l'avant et insérer cette ligne de mon TSV dans une base de données SQLite. Et le mot opératoire que nous avons vu plus tôt et que nous n'avons pas encore utilisé, est INSERT. Nous avons utilisé SELECT. Nous avons utilisé UPDATE. Nous avons utilisé DELETE. Nous n'avons pas encore utilisé INSERT. Donc je vais le faire dans un instant. Mais d'abord, j'ai besoin que ma base de données existe réellement, je dois donc créer une table réelle.

Je vais donc remonter ici en premier et faire ceci, db est maintenant une référence, une variable représentant ma base de données, et je vais appeler la seule fonction à l'intérieur qui est utile à nos fins, appelée execute. Ce que je peux faire maintenant, c'est exécuter tout SQL que je veux. Alors, qu'est-ce que je veux charger dans cette base de données ? Je pense que je veux charger le tconst, le primaryTitle, le startYear et les genres, tout comme nous l'avons fait précédemment à partir de title.basics.tsv. Je veux charger des lignes qui représentent ce type de données, d'accord ?

Alors, comment vais-je faire cela ? Eh bien, laissez-moi aller de l'avant et créer une table. Je vais l'appeler shows, parce que cela semble agréable et conceptuellement cohérent. Je vais aller de l'avant et créer une liste de colonnes maintenant. tconst va être une colonne. primaryTitle en sera une autre. startYear en sera une autre. Et genres sera le dernier. Je peux littéralement, c'est-à-dire écrire du SQL à l'intérieur d'une chaîne que je passe à une fonction Python appelée db.execute. Et parce que db.execute - ou plutôt, parce que db a été configuré avec shows3.db, lorsque j'exécute cette chaîne en Python, elle sera exécutée sur ce fichier de base de données, shows3.db. C'est donc une bonne façon de relier ces deux mondes.

Je vais donc devoir être un peu plus précis, cependant. Rappelez-vous que SQL a un tas de types. Et je vais rester simple. Je vais aller de l'avant et dire que le type de cette valeur tconst est du texte. Le type de primaryTitle est du texte. Le type de startYear va être numérique, une sorte de prise en charge pour les dates et les heures. Et puis les genres vont être du texte également. Donc la syntaxe est un peu bizarre. Vous spécifiez en fait le nom de la colonne puis le type, contrairement à l'inverse, ce que nous avons fait en C. Mais c'est comme ça que SQL est.

Je vais donc aller de l'avant et enregistrer cela maintenant. Et juste pour commenter cela, cela va créer une table appelée shows dans un fichier de base de données appelé shows3.db, juste pour être super explicite.

Alors, que vais-je faire ici ? Il semble que j'ai la possibilité avec la bibliothèque de