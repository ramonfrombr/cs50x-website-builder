Alors laissez-moi démarrer et ouvrir un fichier appelé import.py. Et je vais importer le module CSV, comme d'habitude, et j'ouvrirai ce fichier, appelé title.basics.tsv en mode lecture seule, et j'appellerai cette variable titles. Qu'est-ce que je vais faire ensuite ? Laissez-moi me créer un lecteur en utilisant csv.DictReader, comme je l'ai fait précédemment, en lisant ces titres. Mais csv.DictReader ne me semble pas être le bon lecteur. Pourquoi ? Soyez clair.

Oui, je veux dire, peut-être que je veux TSV. Mais il s'avère que TSV n'existe pas. Donc, même si je serais enclin, par exemple, à changer ceci en un T et ceci en un T, le module CSV fait suffisamment pour moi, mais je dois lui dire que je veux utiliser un délimiteur différent. Au lieu du délimiteur par défaut, qui ressemble à cela, je peux en fait le remplacer et dire, vous savez quoi ? Utilisez une tabulation. Et tout comme \n en C et en Python, c'est une nouvelle ligne. \t dans les deux langues est un caractère de tabulation.

Très bien, une fois que j'aurai fait cela, laissez-moi ouvrir, maintenant - laissez-moi ouvrir shows0.csv. Mon but dans la vie est de rendre ce fichier beaucoup plus facile à gérer pour moi-même. Je veux prendre un fichier de 500 mégaoctets et extraire uniquement les émissions de télévision qu'il contient. De plus, que diriez-vous uniquement des émissions de télévision à partir de 1970 ? Nous n'irons pas plus loin que cela.

Laissez-moi donc ouvrir, en mode écriture, un fichier appelé show0.csv. Et je vais appeler cette variable shows. Ensuite, je vais me créer un écrivain. Et vous vous souvenez peut-être avoir utilisé cela dans le passé. Cela va simplement me donner une variable appelée writer, via laquelle je peux écrire dans un nouveau fichier. Car encore une fois, le but est de lire ce fichier et d'écrire dans ce fichier un sous-ensemble des données qu'il contient.

Alors laissez-moi écrire une première ligne. Écrire une ligne, en passant une liste de valeurs, en particulier tconst, qui est le titre - qui est le champ d'identification ; primaryTitle, qui est le champ du titre ; startYear, qui est le champ de l'année ; et genres, était un de plus champs que j'ai mentionné plus tôt. Mon objectif est donc d'exporter uniquement les quatre colonnes qui m'intéressent pour l'instant.

Je vais donc faire ça. Pour chaque ligne de mon lecteur, je vais dire si le titleType de cette ligne == tvSeries, ce dont The Crown était un exemple, alors je vais écrire dans le writer - oups - writer.writeRow, une liste contenant quoi ? La valeur tconst de la ligne, la valeur du titre principal de la ligne, la ligne - oups - l'année de début de la ligne, et enfin, la ligne - [RIRE] les genres de la ligne.

Qu'est-ce que je fais ici, pour être clair ? J'ai d'abord écrit une seule fois - littéralement ces valeurs, car je veux des en-têtes dans la première ligne de mon fichier. Après cela, pour chaque ligne du lecteur, qui parcourt actuellement ce fichier en mode lecture seule, je veux imprimer le tconst de la ligne courante, le titre principal de la ligne courante, l'année de début de la ligne courante et les genres de la ligne courante. Mais remarquez, j'ignore les films, les courts métrages, les documentaires et bien d'autres valeurs également.

Et vous savez quoi ? Juste pour faire bonne mesure, réduisons un peu ça. Et row, que diriez-vous, est-ce que adult == "0", pour les besoins d'aujourd'hui ? Cela filtrera encore plus la liste. Si vous souhaitez l'inverser plus tard, c'est très bien. Alors laissez-moi faire Python 3, pour la version 3 sur mon Mac - en fait, non, faisons Python d'import.py, d'accord ? Je vais croiser les doigts ici. J'espère que le fichier fonctionne, fonctionne, fonctionne. Mais cela prend un temps considérable. C'est, apparemment, le temps qu'il faut pour traiter des millions de lignes de données. Toujours en cours d'exécution. Toujours en cours d'exécution. Mais le but, encore une fois, est de réduire la quantité de données dont je dois finalement me soucier afin que nous puissions réellement les rechercher beaucoup plus efficacement.