So we are back. And just as a teaser for this coming week, the week is ultimately about algorithms and the implementation thereof. And it turns out that certainly on campus and in the real world, our [? election's ?] quite often, an algorithmic process to which there's actually multiple possible solutions. Indeed, when you vote for someone, how those votes are tabulated can actually differ based on the algorithm being used. And those can actually had very real-world effects on the outcomes of those elections. 

So among the challenges ahead for the coming week with problem set three is to implement a number of algorithms related to elections. For instance, it might be a very simple ballot, whereby whoever has the most votes among all among all of the candidates, or whoever has a plurality wins. Or you can implement some kind of runoff election, whereby you don't just vote for one candidate, but you rank your preferences. And then you use software or a more manual human process to adjudicate who wins based on the ranking of those candidates. And there's even more possibilities that ultimately can influence real-world outcomes, whether it's here on campus or in the real world. And so that's what we'll explore this week in code. 

But now let's see if we can't fundamentally do better than both bubble sort and selection sort. And let me stipulate, there's actually dozens of sorting algorithms. We're looking just at a couple of representative algorithms here. But let's see if we can't do fundamentally better than the n squared big O that we kept bumping up against. 

And to do that, let me propose that we introduce a fundamentally new idea that, frankly, among the ideas we explore in computer science will kind of bend your mind a little bit. So again, here comes that fire hose. But again, the goal today is exposure, not yet comfort. Comfort will come in the coming weeks as we apply [? this ?] [? ideas ?] and others. 