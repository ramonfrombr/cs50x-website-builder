Bien, alors la transition est exactement celle-là. Je vais y aller maintenant et fermer favorites.py. Et je vais juste maximiser la taille de ma fenêtre de terminal ici. Et je vais lancer un programme appelé SQLite3. SQLite3 est un programme en ligne de commande que vous pouvez installer sur votre Mac ou PC (il est déjà sur CS50 IDE) qui vous permet d'utiliser un autre langage appelé SQL de manière interactive. Et il a cette fonctionnalité vraiment cool où si j'ai ce fichier appelé, de manière très verbeuse, CS520 2019 Lecture 7, et ainsi de suite, je vais le copier après l'avoir mis en surbrillance. Je vais lancer SQLite3, et je vais mettre SQLite3 en mode .CSV. C'est une syntaxe bizarre, .mode CSV, mais vous n'avez pas besoin d'utiliser ces commandes très souvent. Ensuite, je vais utiliser une autre commande ici, qui s'appelle import. Et je vais y aller et importer cela dans une base de données.

Mais de quelle base de données, exactement ? Eh bien, laissez-moi y aller et plus précisément... laissez-moi sortir d'ici. Oups. Laissez-moi sortir d'ici et lancer SQLite3 au nom d'une base de données. Je m'occupe des émissions préférées, alors peut-être que je vais appeler ça favorites.db, DB désignant database (base de données). Je vais maintenant y aller et faire .mode CSV. Je vais maintenant faire .import, en citant le nom du fichier, et les guillemets sont importants, parce qu'il y a des espaces bizarres dedans, et je vais importer cela dans une table, un peu comme une feuille de calcul, que je vais appeler simplement favorites, en minuscules. Et appuyez sur Entrée. Rien ne semble se passer maintenant.

Mais si je retourne à ma fenêtre de terminal et que je tape ls, remarquez qu'en plus de mon fichier CSV et de favorites.py et src7, que j'ai téléchargés à l'avance avec le code du jour, j'ai maintenant ce fichier appelé favorites.db. Et si je relance SQLite, il s'avère que lorsque je passe le nom de cette base de données, je peux maintenant poser les mêmes types de questions qu'avant, mais je peux le faire avec une syntaxe différente. Je peux y aller et sélectionner tous les titres de mes favoris en tapant cette commande, SELECT title FROM favorites ; Enter, et hop, on obtient tous les titres là.

Supposons que je veuille trier ces titres comme avant, ou je peux SELECT title FROM favorites, ORDER BY title ; se terminant par ... oh, désolé. Les points-virgules sont de retour. Ensuite, je vais y aller et appuyer ici. Et vous verrez que maintenant c'est alphabétisé, et il y a tous ces Offices par première lettre. Maintenant, il y a quelques bogues. Si vous faites défiler vers le bas, vous verrez également des lettres minuscules, nous devrons donc également gérer cette situation. Mais cela semble être un moyen convivial de simplement sélectionner les données qui m'intéressent.

Et regarde ça. Laissez-moi essayer de regrouper les choses. Je vais y aller et sélectionner le titre, et je vais y aller et dire de compter le nombre de titres de cette table appelée favorites. Mais je veux regrouper ces choses par titre. Maintenant, nous verrons dans un instant ce que cela signifie, mais l'effet est ce qui est cool. Hop, j'ai maintenant une sortie comme mon programme Python. Ce n'est pas vraiment aussi ordonné que je le voudrais, mais remarquez ce qu'il a fait tout en haut. La toute première ligne de sortie, si je continue à faire défiler, c'est ici. Sur la gauche, il y a mon titre, puis une barre verticale. Sur la droite, il y a littéralement le nombre de titres, combien de titres correspondent à cela.

Alors laissez-moi y aller et faire ça. Laissez-moi y aller et limiter d'abord cela aux 10 premiers titres, afin de pouvoir simplement gérer cela et voir tout cela à la fois. Donc, ici, nous avons une liste de titres alphabétisés. Mais maintenant, supposons que je veuille y aller et renommer cette chose. Laissez-moi y aller et dire ça. Laissez-moi y aller et dire, en tant que ... COUNT AS n. Maintenant, remarquez que le titre de cette sortie est title, puis n. Mais la raison pour laquelle j'ai fait cela, c'est pour pouvoir faire ceci. Je vais maintenant faire ORDER BY n, dans l'ordre décroissant, puis limiter aux 10 premiers. Entrée, et hop. Maintenant, en utilisant un langage complètement différent, je pense avoir obtenu les mêmes résultats, à l'exception du problème de minuscules, sur lequel nous pourrons revenir à un autre moment. Mais The Office est ici en tant que hit numéro un. Friends ensuite, 19. Game of Thrones, 18, et ainsi de suite.

Alors, quelle est donc la motivation en partie pour ce nouveau langage appelé SQL ? Et vous n'en avez vu que des extraits ici. Il nous permet de résoudre le même type de problèmes beaucoup plus facilement, car je n'ai pas à m'asseoir et à écrire tout un programme Python, aussi rapide soit-il que C. Je n'ai pas à écrire de code personnalisé simplement pour répondre à des questions sur mes données. Et en fait, si vous poursuivez la piste web dans quelques semaines ou la piste mobile, elles offriront toutes deux une prise en charge pour SQL afin que si vous souhaitez stocker des données sur des utilisateurs ou des informations interactives sur une application ou un site web, SQL sera finalement l'endroit où vous pourrez mettre ces données et y accéder plus tard, en écrivant ainsi encore moins de code qu'aujourd'hui.