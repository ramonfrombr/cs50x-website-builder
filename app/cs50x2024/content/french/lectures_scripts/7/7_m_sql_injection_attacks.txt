Et un dernier exemple de ça, parce que celui-ci, vous pouvez l'éviter tout au long des prochaines semaines dans CS50 et au-delà. Une attaque par injection SQL est quand vous écrivez du mauvais code qui permet en quelque sorte à un mauvais acteur sur Internet ou une application de duper votre code pour exécuter un code SQL que vous n'aviez pas prévu. Par exemple, c'est ainsi que les étudiants de Yale se connectent à New Haven. Bien sûr, c'est ainsi que les étudiants de Harvard se connectent ici à Cambridge. On vous demande un identifiant et un mot de passe, ou une clef Harvard et un mot de passe. Supposons, cependant, qu'en tant qu'utilisateur, vous ne coopériez pas, et qu'au lieu de saisir votre adresse e-mail et mot de passe, vous saisissiez quelque chose comme ça, comme votre adresse e-mail, Malan@Harvard.edu, puis peut-être une simple guillemet, puis tiret tiret.

Et bien, il s'avère qu'en SQL, tiret tiret est la façon dont vous commencez un commentaire, similaire au dièse en Python ou slash slash en C. Mais supposons que Harvard ait implémenté son site Internet de telle sorte qu'il y ait une requête comme celle-ci en cours d'exécution sous le capot, si la clef Harvard est implémentée en Python, qui dise ceci, SELECT * FROM users WHERE username = placeholder AND password = placeholder, en transmettant username et password. C'est bien. C'est du code correct, parce que ces espaces réservés sont importants.

Ce que fait la bibliothèque CS50, et d'autres bibliothèques dans le monde comme elle, c'est qu'elle échappe l'entrée de l'utilisateur. Si un utilisateur essaie de duper votre code pour insérer des commentaires ou guillemets simples, db execute et d'autres bibliothèques désinfecteront l'entrée de l'utilisateur et empêcheront que ce qui suit ne se produise. Cependant, si vous faites ça-- pas bien, mais mal. Supposons que vous pratiquiez vraiment ce qu'on a prêché la semaine dernière en utilisant les chaînes de format f, c'est maintenant mauvais dans le contexte de SQL. Si vous créez une chaîne de format comme celle-ci avec un petit f qui est littéralement SELECT * from users WHERE username =, puis utilisez la notation Python sophistiquée pour les accolades, et password = accolades, c'est une construction SQL correcte tant que l'humain coopère et met son identifiant ici et son mot de passe ici.

Mais que se passe-t-il si l'utilisateur est malveillant, comme moi, et inclut en réalité une guillemet simple dans son entrée, puis tiret tiret ? Ainsi, Malan@Harvard.edu guillemet tiret tiret aurait pour effet d'injecter cela dans l'entrée de l'utilisateur. Mais je revendique tiret tiret comme un commentaire, donc c'est une façon de duper l'ordinateur en exécutant non pas SELECT * WHERE user-- SELECT * FROM users where username = ceci AND password = cela, ça a pour effet de juste dire SELECT * FROM users where username equals Malan@Harvard.edu.

Et si-- et vous verrez ça dans p set 7-- db.execute renvoie une ou plusieurs lignes de la table-- c'est comme ça que vous pouvez en réalité sélectionner des données en utilisant le code Python-- et le nombre de lignes est égal à 1, parce qu'il a sélectionné Malan@Harvard.edu, vous pourriez vous connecter en tant que moi parce que vous avez tout simplement dupé l'ordinateur pour qu'il exécute le code que vous avez injecté.

Et le plus grand à retenir ici, c'est qu'il s'agit d'un problème résoluble à 100 %. Vous avez juste besoin de savoir qu'il est résolu et ne pas écrire du code comme ça en utilisant les chaînes de format f en Python, mais plutôt utiliser le code de bibliothèque comme db. execute, ou après ce cours, quelque chose comme ça.

Cela dit, nous finirons avec une blague.

OK. C'est tout pour CS50. On se voit la prochaine fois.