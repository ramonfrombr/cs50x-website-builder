Now there's one last detail that we've not explained yet and that's this one here. Why the heck does main have a return value? And there's not really a super compelling reason here, but we can see that there's a low-level reason that this is useful, but it's not something to stress over much. It turns out that main by default in C does have a return value. And even though we have never returned anything from main yet, by default, main returns zero. Zero in computers typically means all is well. It's a little paradoxical, because you would think zero-- false-- bad. But no, zero tends to be good. 

The reason for this is that main can return non-zero values, like one, or negative one, or 2 billion, or negative 2 billion. In fact, if you've ever seen an error message on your Mac or PC, sometimes there's a little window that pops up and it's a cryptic looking code, like an error has happened, negative 42, or whatever. That number is just an arbitrary number some human decided that their main program will return if something went wrong. And we can do this as follows. I can write a program like this in a file called exit dot c that has, say, the CS50 library, that has includes standard Io dot h, int main void-- I'm going to go back to void, because I'm not going to take any-- or actually, no, I'm going to do int rc, and then string arg v brackets, so I can take a command line argument, and I'm going to start to error check. 

Suppose this is a program that the human is supposed to provide a command line argument. I'm going to do this. If arg c does not equal two, you know what I'm going to do? I'm going to yell at the user, say missing command line argument backslash n, but now I want to quit from the program. I want to do the equivalent of exit. So how do you do that in C? You actually return a value. And if all was well, you would return zero. However, if something went wrong, the sky's the limit, up to 2 billion or negative 2 billion. However, we'll keep it simple, and just return one, if something went wrong. 

Meanwhile, I might then say printf, hello, percent s. Type in arg v one, just as before. And then, if all is well, return zero. So not much new is happening here. This program is very similar to the last, except instead of saying hello world by default, I'm going to yell at the user with this, missing command line argument, and then return one to signal to the computer, this program did not succeed. And I'm going to return zero, if and only if, it did. Yeah? 

AUDIENCE: Why is arg c unequal to zero? 

DAVID MALAN: Why is arg c not equal-- really good question. So let me go ahead and change this. What is in arg v zero that makes it have two things instead of one, if I run David-- if I run my name, David. Well, hello-- let me recompile. Make arg v one, or make arg v, dot slash, arg v, hello-- no, wrong program. Make exit. Sorry. There's no program to detect that mistake. Dot slash exit, missing command line argument. However, if I do exit David, now I see-- oh, did I run arg v before? Check the tape. 

Hello dot exit. So in arg v, the first word you type, the program's name, is stored at arg v zero. The second word you type, the first argument you care about, is an arg v one. And that's why arg c is two. I literally typed two words at the prompt, even though only one of them is technically an argument I care about.