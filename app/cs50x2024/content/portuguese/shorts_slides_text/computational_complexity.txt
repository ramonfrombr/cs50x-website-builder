[0]

Complexidade Computacional

[1]

Complexidade Computacional
• Para fazer uso mais eficaz de nossos recursos computacionais, é importante que tenhamos um conjunto de habilidades para analisar a complexidade dos algoritmos, para sabermos quais recursos esses algoritmos requerem.
• Ser capaz de analisar um algoritmo nos permite ter uma ideia de quão bem ele é escalado à medida que colocamos conjuntos de dados cada vez maiores.

[2]

Complexidade Computacional
• Quando falamos sobre a complexidade de um algoritmo, geralmente nos referimos ao pior cenário possível.
• Nós nos referimos a isso como O.
• Às vezes também nos importamos com o melhor cenário possível (também conhecido como Ω)
• Em CS50, deixaremos de lado a análise rigorosa e focaremos mais no raciocínio da complexidade com senso comum.

[3]

Complexidade Computacional
• O que é um conjunto de dados?
• O que fizer mais sentido no contexto.
• Podemos medir um algoritmo com base em como ele lida com essas entradas. Vamos chamar essa medida de f(n).
• Não nos importamos com o que f(n) é precisamente. Em vez disso, nos importamos apenas com sua tendência, que é ditada por seu termo de ordem mais alta.

[4]

Complexidade Computacional
n
f(n) = n3
f(n) = n3 + n2
f(n) = n3 – 8n2 + 20n
1
1
2
13
10
1.000
1.100
400
1.000
1.000.000.000
1.001.000.000
992.020.000
1.000.000
1,0 x 1018
1.000001 x 1018
9,99992 x 1017

[5]

Complexidade Computacional
n
f(n) = n3
f(n) = n3 + n2
f(n) = n3 – 8n2 + 20n
1
1
2
13
10
1.000
1.100
400
1.000
1.000.000.000
1.001.000.000
992.020.000
1.000.000
1,0 x 1018
1.000001 x 1018
9,99992 x 1017

[6]

Complexidade Computacional
n
f(n) = n3
f(n) = n3 + n2
f(n) = n3 – 8n2 + 20n
1
1
2
13
10
1.000
1.100
400
1.000
1.000.000.000
1.001.000.000
992.020.000
1.000.000
1,0 x 1018
1.000001 x 1018
9,99992 x 1017

[7]

Complexidade Computacional
n
f(n) = n3
f(n) = n3 + n2
f(n) = n3 – 8n2 + 20n
1
1
2
13
10
1.000
1.100
400
1.000
1.000.000.000
1.001.000.000
992.020.000
1.000.000
1,0 x 1018
1.000001 x 1018
9,99992 x 1017

[8]

Complexidade Computacional
n
f(n) = n3
f(n) = n3 + n2
f(n) = n3 – 8n2 + 20n
1
1
2
13
10
1.000
1.100
400
1.000
1.000.000.000
1.001.000.000
992.020.000
1.000.000
1,0 x 1018
1.000001 x 1018
9,99992 x 1017

[9]

Complexidade Computacional
O(1)
tempo constante
O(log n)
tempo logarítmico
O(n)
tempo linear
O(n log n)
tempo linearítmico
O(n2)
tempo quadrático
O(nc)
tempo polinomial
O(cn)
tempo exponencial
O(n!)
tempo fatorial
O(∞)
tempo infinito

[10]

Complexidade Computacional
• O(1)
• Sempre leva uma única operação no pior cenário.
int four_for_you(int array[1000])
{
return 4;
}
int add_two_nums(int a, int b)
{
return a + b;
}

[11]

Complexidade Computacional
• O(n)
• Sempre leva n operações no pior cenário.
2
5
4
1
3

[12]

Complexidade Computacional
• O(n)
• Sempre leva n operações no pior cenário.
2
5
4
1
3

[13]

Complexidade Computacional
• O(n)
• Sempre leva n operações no pior cenário.
1
2
3
4
5

[14]

Complexidade Computacional
• O(n)
• Sempre leva n operações no pior cenário.
1
2
3
4
5

[15]

Complexidade Computacional
• O(n)
• Sempre leva n operações no pior cenário.
2
6
1
3
4
5

[16]

Complexidade Computacional
• O(n)
• Sempre leva n operações no pior cenário.
2
6
1
3
4
5

[17]

Complexidade Computacional
• O(n)
• Sempre leva n operações no pior cenário.
3
1
6
7
4
2
5

[18]

Complexidade Computacional
• O(n)
• Sempre leva n operações no pior cenário.
3
1
6
7
4
2
5

[19]

Complexidade Computacional
• Qual é o tempo de execução?
for (int j = 0; j < m; j++)
{
// corpo do laço que roda em O(1)
}

[20]

Complexidade Computacional
• Qual é o tempo de execução?
for (int j = 0; j < m; j++)
{
// corpo do laço que roda em O(1)
}
O(m)

[21]

Complexidade Computacional
• Qual é o tempo de execução?
for (int j = 0; j < p; j++)
{
for (int k = 0; k < p; k++)
{
// corpo do laço que roda em O(1)
}
}

[22]

Complexidade Computacional
• Qual é o tempo de execução?
for (int j = 0; j < p; j++)
{
for (int k = 0; k < p; k++)
{
// corpo do laço que roda em O(1)
}
}
O(p2)