Il s'avère que lorsque vous utilisez la bibliothèque CS50, vous devez faire deux choses. Dans votre code source, vous devez dire à l'ordinateur d'inclure ce fichier CS50.h, où, encore une fois, des fonctions comme get_string et le mot string sont implémentées pour vous. Mais lors de la compilation de votre code, vous devez, un peu inutilement, mais pour différentes raisons, dire à l'ordinateur d'ajouter tout le code que le personnel de CS50 a écrit pour implémenter get_string, string et d'autres fonctions comme celle-ci. Je vais aller de l'avant et écrire Clang -o string string.c, comme avant, mais je dois dire à l'ordinateur cette instruction spéciale pour le lier à CS50. Et cela aura plus de sens dans quelques semaines. Mais c'est juste un -l pour le lien et CS50. Et tout cela indique à l'ordinateur que les zéros et les uns de mon programme proviennent de string.c, juste ici. C'est mon code source. Mais le personnel de CS50, il y a des années, a également écrit du code en C afin de vous fournir des fonctions comme get_string, afin de vous fournir des variables comme des chaînes. Les zéros et les uns de la bibliothèque CS50 sont stockés ailleurs dans le cloud. Ils doivent être liés au vôtre. Donc, tout comme votre code est dans ce fichier, notre code est dans ce fichier. Ainsi, en disant à l'ordinateur de l'inclure dans votre code source et de le lier dans cette commande, c'est simplement une façon absconse de dire, de combiner mon code avec celui de CS50 en un seul programme que je peux réellement exécuter. Maintenant, tout cela, franchement, devient très rapidement très accablant, je pense, et très inutilement compliqué. Il existe donc une meilleure façon que cela. Il s'avère que pour aller de l'avant, si vous souhaitez compiler votre code, vous n'avez pas besoin de vous souvenir de -o. Vous n'avez pas besoin de vous souvenir de -l CS50. Vous n'avez à vous souvenir d'aucune de ces commandes, idéalement uniquement des idées. Vous pouvez plutôt dire, créez-moi un programme appelé string, et en finir avec. Toute cette sortie blanche est simplement générée automatiquement pour vous lorsque vous dites à l'ordinateur, créez mon programme. Et le programme make déterminera quels arguments de ligne de commande utiliser, quel nom donner au fichier, quelles bibliothèques ou quel code d'autres personnes ont écrit pour établir un lien. Donc désormais, lorsque vous souhaitez compiler votre programme, dites simplement make et le nom du programme. Mais ce n'est pas make string.c. C'est make et le nom du programme. Make, cet autre programme, comprendra que vous voulez parler de quelque chose appelé string.c. Et je peux revenir en arrière et le faire pour hello aussi. Faites hello. Oh, je n'ai jamais réglé le problème d'avant. Alors laissez-moi aller dans hello.c en ouvrant ce fichier. Permettez-moi de résoudre ce problème pour la postérité. Enregistrez ce fichier ou laissez-le enregistrer automatiquement. Maintenant, faites make hello. Et hop, il a fait la même chose pour moi maintenant. Oui? AUDIENCE : Est-ce que make est une chose standard [INAUDIBLE] .. DAVID MALAN : Très bonne question. Est-ce que make est quelque chose de standard ou spécifique à CS50 ? Ce n'est pas une spécificité CS50. Il s'agit d'un outil standard qui existe sur Mac, PC et ordinateurs exécutant généralement Unix ou Linux. Et en effet, l'outil sandbox que nous utilisons est lui-même un ordinateur dans le cloud, même s'il n'a que ces deux fenêtres, onglets en haut et la fenêtre du terminal en bas. Lorsque vous vous connectez à CS50 Sandbox, vous avez accès à votre propre serveur dans le cloud exécutant un système d'exploitation appelé Linux. Et Clang, make et d'autres outils que nous allons voir, comme ls et rm, existent tous dans ce système d'exploitation. Ils ne sont pas du tout spécifiques à CS50. Oui? AUDIENCE : Avec cela, hello serait-il du code machine, pas [INAUDIBLE] ?? DAVID MALAN : Correct. Hello est le code machine. Hello.c est le code source. AUDIENCE : Donc [INAUDIBLE] ? DAVID MALAN : Correct. Make est un programme intelligent conçu pour nous rendre la vie plus facile, sans jeu de mots, grâce auquel si vous faites make hello, il recherchera un fichier appelé hello.c. Et s'il le trouve, il créera le programme appelé hello du code source au code machine, respectivement. Oui? AUDIENCE : [INAUDIBLE]. DAVID MALAN : Pas exactement. Make est donc un programme fourni avec un système d'exploitation appelé Linux, et il est également fourni avec Mac OS. Et ces jours-ci, il est également livré avec Windows. C'est un programme que vous pouvez exécuter en tapant son nom, que vous n'exécutez pas en double-cliquant sur une icône. Bonne question. Oui? AUDIENCE : [INAUDIBLE] ? DAVID MALAN : Bonne question. Cela signifie-t-il que make est stocké sur votre ordinateur ou sur l'ordinateur basé sur le cloud ? Dans l'ordinateur basé sur le cloud. Donc, à ce stade du semestre, et pendant les premières semaines, tout ce que nous ferons sera dans le cloud dans un environnement standardisé appelé CS50 Sandbox et, bientôt, quelque chose appelé CS50 Lab. Mais il est conçu pour être représentatif d'un ordinateur Linux standard et aussi d'un Mac ou PC. Mais le logiciel a tendance à différer quelque peu, nous standardisons donc sur Linux, qui est un système d'exploitation très populaire dans le monde du développement logiciel.