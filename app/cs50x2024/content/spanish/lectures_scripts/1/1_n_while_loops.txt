Muy bien, solo un par de comparaciones más antes de que volvamos a escribir algo de código. ¿Qué tal algo como esto? En Scratch, desde luego, a esto lo llamamos un bucle, un ciclo que se repite una y otra vez. Y un bucle como este se puede implementar en C no exactamente de la misma forma, pero así. Resulta que la palabra en Scratch más cercana a la palabra para siempre es while. Sugiere la idea de hacer algo una y otra vez. Esta fue la palabra que los humanos eligieron hace años. Pero no solo dices while. No solo tienes que decir lo que quieres hacer para siempre, sino que tienes que responder a una expresión booleana. Por lo tanto, en C, si quieres implementar un bucle, literalmente tienes que ser capaz de decir while something is true. Tienes que hacer una pregunta a la que la respuesta sea sí, verdadero o uno. Todos esos términos son equivalentes para un programador. Entonces, ¿cuál es un ejemplo de una expresión, una expresión booleana, que siempre es verdadera, si mi objetivo es hacer algo para siempre? AUDIENCIA: Cinco es igual a cinco. DAVID MALAN: Cinco es igual igual a cinco, está bien. Podría utilizar cuatro es igual igual a cuatro. Podría utilizar dos es mayor que uno. Podría utilizar uno es menor que dos. Podría ocurrirseme un infinidad de expresiones booleanas que son lógicas y siempre verdaderas. Pero la forma más simple es simplemente decir literalmente verdadero. En cierto modo es un truco, pero esta es probablemente la pregunta más simple que puedes utilizar, porque verdadero, por definición, resulta que siempre es verdadero, así como falso siempre es falso. Por lo tanto, puedo decir literalmente while true para inducir un bucle infinito, por así decirlo, que hace algo para siempre. Muy bien, intentemos otro tipo de construcción de bucle. Este era un bucle que hacía algo 50 veces. Este, ahora tenemos que ser más listos y tenemos que conectar las cosas. Por lo tanto, si quiero hacer algo 50 veces, he aquí una forma. ¿Por qué no utilizo una variable y la llamo contador? Pero podría llamarla como quisiera e inicializarla a cero. Luego, déjame adelantarte, ¿sabes qué? Contador es en realidad muy detallado. La mayoría de los programadores, cuando están contando, según la convención, utilizan la letra i, i de entero. Pero puedes llamarla como quieras. Por lo tanto, la voy a llamar int i es igual a cero. Luego voy a ir más adelante y haré lo siguiente. Mientras la siguiente expresión sea verdadera, déjame hacerte una pregunta una y otra vez. Mientras i sea menor que 50, diré, hola mundo. Por lo tanto, puedo simplemente imprimir hola mundo. Pero no he terminado de construir esta lógica. He inicializado una variable a cero. Voy a hacer, una y otra vez, la pregunta: ¿i es menor que 50? Pero para que esto funcione lógicamente, ¿qué otra parte de lógica tengo que añadir al código? ¿Sí? AUDIENCIA: Tienes que incrementar i en uno. DAVID MALAN: Sí, tengo que incrementar i, ¿verdad? Por lo tanto, aunque no recuerdes, y está bien, la sintaxis para hacer eso, necesitas una línea de código como esta. Para que, lógicamente, vayas a hacer lo siguiente: establecer i igual a cero y luego hacer lo siguiente while i sea menor que 50. Bien, ¿i es menor que 50? Obviamente, porque 0 es menor que 50. Por lo tanto, imprimes hola mundo. Y luego, como propones, tenemos que incrementar i. Por lo tanto, ahora i es igual a i más 1. Entonces, en este punto de la historia, i es igual a 1. Y ahora el código funciona del mismo modo que nuestro pseudocódigo de la semana pasada, se vuelve implícita a esta línea. La semana pasada, en pseudocódigo, dije literalmente, vuelve a la línea 3. Aquí, sucede automáticamente por la naturaleza de cómo C interpreta estas líneas de código en estas llaves. De hecho, puedo simplificarlo como sigue. Puedo utilizar i más más. Bien, no es tan bonito como Scratch, donde simplemente dices, repite lo siguiente 50 veces. Pero utilizando los principios de la semana pasada traducidos a C, puedes conectar tu propia lógica que hace algo cualquier cantidad de veces.