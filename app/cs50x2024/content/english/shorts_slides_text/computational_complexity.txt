
[0]

Computational Complexity

[1]

Computational Complexity
• In order to make most effective use of our computational resources, it’s important that we have the skill set to analyze the complexity of algorithms, so we know what resources those algorithms require.
• Being able to analyze an algorithm allows us to have an idea of how well it scales as we throw larger and larger data sets at it.

[2]

Computational Complexity
• When we talk about the complexity of an algorithm, we generally refer to the worst-case scenario.
• We refer to this as O.
• We sometimes also care about the best-case scenario (also known as Ω)
• In CS50, we’ll leave the rigorous analysis aside and focus more on reasoning complexity with common sense.

[3]

Computational Complexity
• What is a data set?
• Whatever makes the most sense in context.
• We can measure an algorithm based on how it handles these inputs. Let’s call this measure f(n).
• We don’t actually care about what f(n) is precisely. Rather, we care only about its tendency, which is dictated by its highest-order term.

[4]

Computational Complexity
n
f(n) = n3
f(n) = n3 + n2
f(n) = n3 – 8n2 + 20n
1
1
2
13
10
1,000
1,100
400
1,000
1,000,000,000
1,001,000,000
992,020,000
1,000,000
1.0 x 1018
1.000001 x 1018
9.99992 x 1017

[5]

Computational Complexity
n
f(n) = n3
f(n) = n3 + n2
f(n) = n3 – 8n2 + 20n
1
1
2
13
10
1,000
1,100
400
1,000
1,000,000,000
1,001,000,000
992,020,000
1,000,000
1.0 x 1018
1.000001 x 1018
9.99992 x 1017

[6]

Computational Complexity
n
f(n) = n3
f(n) = n3 + n2
f(n) = n3 – 8n2 + 20n
1
1
2
13
10
1,000
1,100
400
1,000
1,000,000,000
1,001,000,000
992,020,000
1,000,000
1.0 x 1018
1.000001 x 1018
9.99992 x 1017

[7]

Computational Complexity
n
f(n) = n3
f(n) = n3 + n2
f(n) = n3 – 8n2 + 20n
1
1
2
13
10
1,000
1,100
400
1,000
1,000,000,000
1,001,000,000
992,020,000
1,000,000
1.0 x 1018
1.000001 x 1018
9.99992 x 1017

[8]

Computational Complexity
n
f(n) = n3
f(n) = n3 + n2
f(n) = n3 – 8n2 + 20n
1
1
2
13
10
1,000
1,100
400
1,000
1,000,000,000
1,001,000,000
992,020,000
1,000,000
1.0 x 1018
1.000001 x 1018
9.99992 x 1017

[9]

Computational Complexity
O(1)
constant time
O(log n)
logarithmic time
O(n)
linear time
O(n log n)
linearithmic time
O(n2)
quadratic time
O(nc)
polynomial time
O(cn)
exponential time
O(n!)
factorial time
O(∞)
infinite time

[10]

Computational Complexity
• O(1)
• Always takes a single operation in the worst case.
int four_for_you(int array[1000])
{
return 4;
}
int add_two_nums(int a, int b)
{
return a + b;
}

[11]

Computational Complexity
• O(n)
• Always takes n operations in the worst case.
2
5
4
1
3

[12]

Computational Complexity
• O(n)
• Always takes n operations in the worst case.
2
5
4
1
3

[13]

Computational Complexity
• O(n)
• Always takes n operations in the worst case.
1
2
3
4
5

[14]

Computational Complexity
• O(n)
• Always takes n operations in the worst case.
1
2
3
4
5

[15]

Computational Complexity
• O(n)
• Always takes n operations in the worst case.
2
6
1
3
4
5

[16]

Computational Complexity
• O(n)
• Always takes n operations in the worst case.
2
6
1
3
4
5

[17]

Computational Complexity
• O(n)
• Always takes n operations in the worst case.
3
1
6
7
4
2
5

[18]

Computational Complexity
• O(n)
• Always takes n operations in the worst case.
3
1
6
7
4
2
5

[19]

Computational Complexity
• What’s the runtime?
for (int j = 0; j < m; j++)
{
// loop body that runs in O(1)
}

[20]

Computational Complexity
• What’s the runtime?
for (int j = 0; j < m; j++)
{
// loop body that runs in O(1)
}
O(m)

[21]

Computational Complexity
• What’s the runtime?
for (int j = 0; j < p; j++)
{
for (int k = 0; k < p; k++)
{
// loop body that runs in O(1)
}
}

[22]

Computational Complexity
• What’s the runtime?
for (int j = 0; j < p; j++)
{
for (int k = 0; k < p; k++)
{
// loop body that runs in O(1)
}
}
O(p2)
