Cet algorithme me donnerait donc la solution beaucoup plus vite. Et nous pouvons le voir en observant simplement certains chiffres, comme ci-dessous. Si je commence avec, disons, 1 024 pages au total dans l'annuaire téléphonique et que je recherche Mike Smith, et que je divise et conquiers ce problème, qu'en divisant le problème en deux, puis en deux, j'arrive à 512, 256, 128, 64, 32, 16, 8, 4, 2 et 1. Après seulement 10 étapes, j'ai trouvé la page de Mike Smith. En revanche, ce premier algorithme où je n'ai fait qu'une page à la fois, combien d'étapes, peut-être, cela aurait-il pu me prendre de trouver Mike Smith ? Peut-être, 700, 800, plus ou moins là où pourrait se trouver le S. Donc, dans le pire des cas, 1 000 pages, si je regarde l'ensemble de la chose. Le deuxième algorithme, peut-être 500 pages, car j'avance de deux pages à la fois. Mais bon sang, 10 étapes avec cet algorithme ici. Et il y a de fortes chances que cet algorithme, la plupart d'entre nous dans cette salle le choisirait par défaut, ce qui veut dire que beaucoup de résolution de problèmes, comme nous le verrons, consiste juste à exploiter votre intuition existante et votre aisance avec des idées que vous devez maintenant simplement traduire de manière à ce que les machines et les autres humains puissent les comprendre. Alors, comment pouvons-nous simplement penser à quel point cet algorithme est meilleur ? Eh bien, considérons cette première ligne. Sur cet axe des y, ou axe vertical, permettez-moi de le décrire comme le temps nécessaire pour résoudre un problème. Et sur l'horizontale, ou axe des x, la taille du problème. Ainsi, le nombre de pages dans l'annuaire téléphonique augmentera au fur et à mesure que vous vous déplacerez vers la droite, et le nombre de secondes ou de tours de page nécessaires augmentera le long de l'axe des y ici. Ainsi, ce premier algorithme, représenté ici en rouge, suggère une relation de un à un entre le nombre de pages dans le livre et le nombre de secondes nécessaires pour trouver quelqu'un. On a donc cette ligne droite. Une pente de 1 sur 1, si vous voulez. Et donc, si nous considérons le deuxième algorithme, le deuxième algorithme va également être une ligne droite, mais une ligne droite plus basse sur le graphe. Pourquoi ? Parce que pour tout problème de taille, il me faudra moitié moins de temps pour chercher dans cet annuaire téléphonique, parce que, bien sûr, j'avance de deux pages à la fois. Donc, si nous voyons cela, par exemple, si cette ligne pointillée représente un certain nombre de pages dans l'annuaire téléphonique, peut-être 1 024, eh bien, vous pouvez voir qu'il faudra peut-être autant de secondes ou de tours de page pour trouver Mike Smith avec ce deuxième algorithme. Mais dans le premier algorithme, ce même nombre de pages prendrait beaucoup plus de temps à résoudre, littéralement deux fois plus de temps dans ce cas. Et qu'en est-il du troisième algorithme ? Eh bien, même si votre souvenir de ce qu'est un logarithme est un peu flou, cela décrit simplement une forme fondamentalement différente. La ligne verte décrit ce troisième et dernier algorithme selon lequel vous avez divisé le problème non pas une page à la fois ou deux pages à la fois, mais 50 % encore et encore. Et cela encore et encore. Notez qu'à mesure que le nombre de pages dans l'annuaire téléphonique augmente, cela n'a presque aucun impact sur le temps nécessaire pour résoudre ce problème. Par exemple, si Cambridge et Allston, deux villes du Massachusetts, fusionnent l'année prochaine et que leurs annuaires téléphoniques ne font plus qu'un, deux fois plus grand, donc pas 1 000 pages chacun, mais 2 000 pages au total, combien d'étapes supplémentaires faudra-t-il pour trouver Mike Smith dans l'annuaire téléphonique de l'année prochaine s'il comporte 2 000 pages au lieu de 1 000 ? Une seule étape de plus. Mais les deux premiers algorithmes, c'est encore 1 000 étapes, peut-être, ou encore 500. Ce sont, pour ainsi dire, des différences d'efficacité fondamentalement importantes. Alors traduisons cette idée, cette intuition dans le premier exemple de code.