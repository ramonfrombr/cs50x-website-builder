Muy bien, hagamos un ejemplo diferente, esta vez basado en una idea de la última clase, la abstracción. Recuerden que en Scratch, no había una pieza de rompecabezas para toser que hiciera que el gato [TOSIERA] en la pantalla. Entonces, implementamos esto con nuestra propia pieza de rompecabezas personalizada, en última instancia. Entonces, permítanme crear un programa llamado cough0.c. Esa es una definición generosa de inactividad, pero está bien. Voy a volver a cargar la pantalla. Cuando tengas dudas en CS50, como en la vida, vuelve a cargar. Eso probablemente lo arreglará. Desafortunadamente, con la programación y el internet, eso a veces sucede. Entonces, en un momento, lo que voy a hacer es traducir esa idea de Scratch para implementar la noción de toser. Pero en lugar del bloque say, voy a usar el bloque printf o la función printf. Y luego voy a seguir adelante y diseño esta versión del código un poco mejor y un poco mejor cada vez. Entonces, voy a seguir adelante y abrir un archivo cough0.c. Y voy a seguir adelante e incluiré, digamos, stdio.h. Voy a seguir adelante y haré int main void, que de nuevo, es solo nuestro texto estándar o copiar/pegar para hoy. Entonces, seguiré adelante y diré printf, entre comillas simples, cough con una nueva línea. Y recuerda, en Scratch, quería que esto sucediera tres veces, así que voy a hacerlo así: cough, cough, cough. Muy bien, me voy a dar una ventana de terminal aquí abajo para poder seguir adelante y decir make cough0, Enter. No parece pasar nada malo. ./cough0 y cough, cough, cough. Entonces, la semana pasada, dije que, eh, puedes diseñar esto mejor, ¿verdad? Cada vez que copies y pegues, lo más probable es que debas comenzar a resistir esa tentación, porque dará lugar a un código desordenado, un código más largo de lo necesario. ¿Cuál es la solución a este problema de la semana pasada? AUDIENCIA: Un bucle. DAVID MALAN: Sí, un bucle, un bucle for.