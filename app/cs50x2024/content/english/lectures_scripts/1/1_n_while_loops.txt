All right, just a couple of more comparisons before we go back to writing some code. How about something like this? In Scratch, we, of course, called this a loop-- a cycle that happens again and again and again. And a loop like this can be implemented in C not quite in the same way, but like this. It turns out the closest word to the word forever in Scratch is the word while. It kind of suggests the idea of doing something again and again. This was the word that humans chose years ago. But you don't just say while. You have to say not only what you want to do forever, but you need to answer a Boolean expression. So in C, if you want to implement a loop, you need to literally be able to say while something is true. You need to ask a question to which the answer is yes or true or one. All of those are equivalent to a programmer. So what's an example of an expression, a Boolean expression, that is always true, if my goal is to do something forever? AUDIENCE: Five equals five. DAVID MALAN: Is five equal equal to five, all right. I could do is four equal equal to four. I could do is two greater than one. I could do is one less than two. I could come up with an infinite number of Boolean expressions that just logically are always true. But the simplest way is just to say literally true. So it's a little hackish, but this is perhaps the simplest question you can ask, because true, by definition, it turns out, is always true, just as false is always false. And so I can literally just say while true in order to induce a infinite loop, so to speak, that does something forever. All right, let's try another type of looping construct. This was a loop that did something 50 times. This one, now we have to get a little more clever, and we have to kind of wire things up. So if I want to do something 50 times, here's one way. Why don't I give myself a variable and call it counter. But I could call it anything I want and initialize it to zero. Then, let me go ahead-- you know what? Counter is actually pretty verbose. Most programmers, when they're just counting, they, by convention, just use the letter i, i for integer. But you can call it anything you want. So I'm going to call it int i equals zero. Then I'm going to go ahead and do the following. While the following expression is true, let me just ask a question again and again. While i is less than 50, let me go ahead and say, hello world. So I can just print out, hello world. But I'm not quite done sort of building this logic. I've initialized a variable to zero. I'm going to, again and again, ask the question, is i less than 50? But for this to work out logically, what other piece of logic do I need to add to the code? Yeah? AUDIENCE: You have to increment i by one. DAVID MALAN: Yeah, I have to increment i, right? So even if you don't recall-- and that's fine-- the syntax for doing that, you do need a line of code like this. So that, logically, you're going to do the following-- set i equal to zero, and then do the following while i is less than 50. Well, is i less than 50? Obviously, because 0 is less than 50. So you print out, hello world. And then, as you propose, we need to increment i. So now i equals i plus 1. So at this point in the story, i equals 1. And now the way the code works, much like our pseudo code last week, is you sort of implicitly go back to this line. Last week, in pseudocode, I literally said, go back to line 3. Here, it happens automatically by nature of how C interprets these lines of code in these curly braces. And I can actually simplify this as follows. I can say i plus plus. Now, it's not quite as pretty as Scratch, where you just say, repeat the following 50 times. But using the principles of last week now translated to C, you can kind of wire together your own logic that does something any number of times.