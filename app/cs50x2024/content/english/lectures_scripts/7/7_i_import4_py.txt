So how can we go about doing that? Well, let me go ahead and do the following instead. Let me go ahead and open up a final version of my import script, this one that does two things up top. At the top, I'm going to create two tables, one called shows, which has-- I'm to clean up the column names, too. IMDB is a little nonconventional. What most people would do when describing a unique identifier, they're going to call it ID, not tconst. So we're going to rename it to ID. They're not going to call their title primaryTitle. They're going to call it title, so we're going to rename it title. They're not going to name it startYear. We're going to call it year. And then that's it. We'll come back to primary key in just a moment. 

But notice this. In my new and final version of this script, I'm creating, I propose, a second table called genres whose purpose in life is to contain a value called show_id and another one called genre. So what's going on? Well, let me go ahead and show this. If I load the resulting database from this one, shows4.db, and I do .schema, you'll see that I indeed have two tables. Let me go ahead and SELECT * FROM shows WHERE title, this time, because I've renamed it from primaryTitle, = The Office. OK. That's a lot of Offices. But let's go, AND year = 2005, which is the one we're all thinking about. And it's that one. 

And now, notice this. Notice that I'm getting back what? An ID, I'm getting back a title, and I'm getting back a year, but no genres. That's because there's another table now called genres that's separate. And you know, I'm kind of curious. I see that a genre table has show_id. Let me go and do this. SELECT * FROM genres WHERE show_id =, and let me do a little copy paste here, = this show_id. And what might I see? Comedy. 

So what have we done now? For any TV show that was in IMDB's database that was a comma-separated list of genres, I've exploded it, so to speak. I've split that value on the commas. And if the show is a comedy, I've added a row in these genres table, but then I've jotted down the show's ID next to that genre so I remember that that show was of that genre. But if another show has multiple fields-- for instance, let's go ahead and search for not The Office but, say, The Crown. And there's only one of those. And now I do SELECT * FROM genres WHERE show_id = this number, we'll see that, oh, The Crown now has drama and history as a genre. And so therefore, in the genres table, notice that there's two IDs and two genres. But now we can use a quality. I can now search for all of the comedies from 2019 in kind of a powerful way, SELECT * FROM shows WHERE id IN-- and here's the cool part-- SELECT show_id FROM genres WHERE genre = "Comedy" AND year = 2019. 

So this is admittedly a mouthful, but let's consider what's happening. First, I'm selecting star from shows. That means give me all the shows in all of the columns. But filter as follows, only show me those shows where the ID of the show is in the following list of IDs. Now, you can look at a nested query inside the parentheses here. This list here selects all of the show IDs from the genres table where genre = "Comedy". So the highlighted parenthetical right now returns essentially a list of all of the ID numbers of shows that are associated with comedy, even if they're associated with other things, too. And we're making sure that the year equals 2019. 

So if I now hit Enter, we'll see a whole bunch of results, but we should see, if I count these by using my usual syntax, there were 1,593 shows that are comedies in 2019. That does happen to equal the same count we did earlier by using like, but this is better designed in the sense that there's no ambiguity. You're not just hackishly looking for a substring, so to speak, in a comma-separated list. You can actually now search more robustly by having redesigned your data. 

And what we've done really is something like this. Instead of storing our data in just one table called shows, and every show has an ID, a title, a year, and genres, we've instead exploded those genres into two separate tables, such that now our shows table looks like this. We have an ID, a title, and a year. And notice that the ID of a show can also appear over here in another table called genres, and just by convention, to keep us sane, instead of calling it ID here, we've called it show_id to connote that it came from a table called shows, plural, but it's a single ID from a show. So by convention, humans often call them table name, minus the S, underscore ID. And then the keyword here or genre is comedy or drama or documentary or some other genre as well. 

And now, this is a little subtle, but the fact that this little symbol here, drawn from the database world, flails out into three separate places, this is a one-to-many relationship, so to speak. You can have one show over here mapping to many genres over here, or maybe zero, but it's zero or more possible genres. 

All right. Any questions just yet? 

All right. So the real power then, to be clear, is coming, now, from this kind of expressiveness. So now, let's play around with some other queries and features. But first, let's give ourselves a bit more data. It turns out besides the file called title.basics.tsv, IMDB.com makes a bunch of others available to us as well. There is one called name.basics.tsv. And this is one that has information on all of the names of actors and actresses and directors and writers and other people in the world. So for instance, there is an nconst, which is like a name constant or an ID, nm2946516, which happens to belong to the actor whose primary name is Claire Foy, the star of The Crown. She was born in 1984, and there are some other fields in that file as well. 

But also juicy is this file, title.principals.tsv, and this is where it gets interesting, too. In this file, notice there are no actual titles. There's no primary titles. There's no actual human names. Instead, there's just two unique identifiers, a tconst and an nconst, which IMDB speak for a title identifier and a name identifier. So for instance, in one of the rows in this TSV file called title.principals.tsv, there is a row that starts with tt4786824; also has nm2946516, and has the word actress, thereby implying that if you look up the nm-- the nconst in the names file and you look up the tconst in the titles file, you will be able to, by transitivity, infer that Claire Foy is in The Crown. 

This allows us to have a many-to-many relationship. A one movie or show can have many actors, and one actor can be in many shows, so we're using a sort of join file here, a join table, that's going to somehow allow us to link two different data sets together, and more on that in a moment. But what's really fun in IMDB is that it also has a bunch of ratings that humans have typed in saying, I get this 10 out of 10, a 0 out of 10, and so forth. And they keep track of the number of votes that shows have gotten. And so in title.ratings.tsv, yet another file you can download from IMDB, you can look up a given tconst, the unique identifier for a title, what its average rating is and the number of votes. 

And in fact, if I pull this up, for instance, on The Crown, if I go back to IMDB itself-- IMDB, search for The Crown, the 2016 version, you'll see that indeed, it is an 8.7, which lines up with exactly what we have here. But over time, that number is going to go up or down, because IMDB is updating their data set every day as well. 

So besides this data, we also then have the ability to consider what this all looks like collectively. So in this case here, here is another diagram. It's more complicated now, but it just captures the intuition that you would derive by just reading through IMDB's documentation, which defines the following. It turns out if you read closely among those files, you'll see that, oh, we can glean a whole bunch of shows that are going to have IDs, title, year, and episodes. I want to go ahead and associate those shows with a whole bunch of stars. But people are the entities in the world that have IDs, names, and birth. So now things get a little weird. Let's focus only on these two tables here. 

This is a diagram of the goal at hand, and this is a script I wrote in advance. And in a moment, we'll open up a SQL database that represents this. There's going to be a table called shows, every row of which has an ID, title, year, and some number of episodes, so you can see how long-running it is. There's also going to be a table called people. Claire Foy is going to be among them. She and the other humans will have an ID, name, and birth year associated with them as well. 

But there's going to be this other table here called stars. And you'll notice there's a line that links shows to stars to people, again by transitivity. If there is, in the stars table, a show ID, a.k.a. tconst, and a person ID, a.k.a. nconst, that links, for instance, Claire Foy to The Crown. It's going to link Steve Carell to The Office. It's going to link every other actor to their show as well. Similarly for writers, we won't play too much with the writers today, but writers are people, too, just as stars are people. And so here's another feature or design goal of SQL. You want to ideally factor out the commonalities, so that Claire Foy appears only in one place by name, but her unique identifier might appear in bunches of places. There's a lot of actors in the world who are also writers themselves. They are, at the end of the day, people, but they might appear both in the stars table and in the writers table by way of their person ID. 

So the goal of SQL is to not copy and paste Claire Foy, Claire Foy, Claire Foy, or Steve Carell, Steve Carell, Steve Carell, all over the place. You want to have one authoritative place for all of your people, one authoritative place for all of your shows, and then you have these other tables called join tables, which are similar in spirit to the TSV files you can download that somehow link these identifiers together.